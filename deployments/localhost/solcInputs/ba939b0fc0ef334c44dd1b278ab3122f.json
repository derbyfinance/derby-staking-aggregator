{
  "language": "Solidity",
  "sources": {
    "contracts/MainVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"./Vault.sol\";\r\n\r\nimport \"./Interfaces/IXProvider.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract MainVault is Vault, VaultToken {\r\n  using SafeERC20 for IERC20;\r\n\r\n  address public derbyToken;\r\n  address public game;\r\n  address public xProvider;\r\n\r\n  bool public vaultOff;\r\n  // True when rewards should be swapped to derby tokens\r\n  bool private swapRewards;\r\n\r\n  // total amount of withdrawal requests for the vault to pull extra during a cross-chain rebalance, will be upped when a user makes a withdrawalRequest\r\n  // during a cross-chain rebalance the vault will pull extra funds by the amount of totalWithdrawalRequests and the totalWithdrawalRequests will turn into actual reservedFunds\r\n  uint256 internal totalWithdrawalRequests;\r\n\r\n  uint256 public exchangeRate;\r\n  uint16 public homeChain;\r\n  uint256 public amountToSendXChain;\r\n\r\n  // (userAddress => withdrawalAllowance): amount in vaultCurrency the vault owes to the user\r\n  mapping(address => uint256) internal withdrawalAllowance;\r\n  // (userAddress => requestPeriod): rebalancing period the withdrawal request is made\r\n  mapping(address => uint256) internal withdrawalRequestPeriod;\r\n  // (userAddress => rewardAllowance): amount in vaultCurrency the vault owes to the user\r\n  mapping(address => uint256) internal rewardAllowance;\r\n  // (userAddress => requestPeriod): rebalancing period the reward request is made\r\n  mapping(address => uint256) internal rewardRequestPeriod;\r\n\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint8 _decimals,\r\n    uint256 _vaultNumber,\r\n    address _dao,\r\n    address _game,\r\n    address _controller,\r\n    address _vaultCurrency,\r\n    uint256 _uScale,\r\n    uint256 _gasFeeLiquidity\r\n  )\r\n    VaultToken(_name, _symbol, _decimals)\r\n    Vault(_vaultNumber, _dao, _controller, _vaultCurrency, _uScale, _gasFeeLiquidity)\r\n  {\r\n    exchangeRate = _uScale;\r\n    game = _game;\r\n  }\r\n\r\n  modifier onlyXProvider() {\r\n    require(msg.sender == xProvider, \"only xProvider\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyWhenVaultIsOn() {\r\n    require(state == State.Idle, \"Rebalancing\");\r\n    require(!vaultOff, \"Vault is off\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyWhenIdle() {\r\n    require(state == State.Idle, \"Rebalancing\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGame() {\r\n    require(msg.sender == game, \"only game\");\r\n    _;\r\n  }\r\n\r\n  event PushTotalUnderlying(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  );\r\n  event RebalanceXChain(uint256 _vaultNumber, uint256 _amount, address _asset);\r\n  event PushedRewardsToGame(uint256 _vaultNumber, uint16 _chain, int256[] _rewards);\r\n\r\n  /// @notice Deposit in Vault\r\n  /// @dev Deposit VaultCurrency to Vault and mint LP tokens\r\n  /// @param _amount Amount to deposit\r\n  /// @return shares Tokens received by buyer\r\n  function deposit(uint256 _amount)\r\n    external\r\n    nonReentrant\r\n    onlyWhenVaultIsOn\r\n    returns (uint256 shares)\r\n  {\r\n    uint256 balanceBefore = getVaultBalance();\r\n    vaultCurrency.safeTransferFrom(msg.sender, address(this), _amount);\r\n    uint256 balanceAfter = getVaultBalance();\r\n\r\n    uint256 amount = balanceAfter - balanceBefore;\r\n    shares = (amount * (10**decimals())) / exchangeRate;\r\n\r\n    _mint(msg.sender, shares);\r\n  }\r\n\r\n  /// @notice Withdraw from Vault\r\n  /// @dev Withdraw VaultCurrency from Vault and burn LP tokens\r\n  /// @param _amount Amount to withdraw in LP tokens\r\n  /// @return value Amount received by seller in vaultCurrency\r\n  function withdraw(uint256 _amount)\r\n    external\r\n    nonReentrant\r\n    onlyWhenVaultIsOn\r\n    returns (uint256 value)\r\n  {\r\n    value = (_amount * exchangeRate) / (10**decimals());\r\n\r\n    require(value > 0, \"No value\");\r\n\r\n    require(getVaultBalance() >= value, \"Not enough funds\");\r\n\r\n    _burn(msg.sender, _amount);\r\n    vaultCurrency.safeTransfer(msg.sender, value);\r\n  }\r\n\r\n  /// @notice Withdrawal request for when the vault doesnt have enough funds available\r\n  /// @dev Will give the user allowance for his funds and pulls the extra funds at the next rebalance\r\n  /// @param _amount Amount to withdraw in LP token\r\n  function withdrawalRequest(uint256 _amount)\r\n    external\r\n    nonReentrant\r\n    onlyWhenVaultIsOn\r\n    returns (uint256 value)\r\n  {\r\n    require(withdrawalRequestPeriod[msg.sender] == 0, \"Already a request\");\r\n\r\n    value = (_amount * exchangeRate) / (10**decimals());\r\n\r\n    _burn(msg.sender, _amount);\r\n\r\n    withdrawalAllowance[msg.sender] = value;\r\n    withdrawalRequestPeriod[msg.sender] = rebalancingPeriod;\r\n    totalWithdrawalRequests += value;\r\n  }\r\n\r\n  /// @notice Withdraw the allowance the user requested on the last rebalancing period\r\n  /// @dev Will send the user funds and reset the allowance\r\n  function withdrawAllowance() external nonReentrant onlyWhenIdle returns (uint256 value) {\r\n    require(withdrawalAllowance[msg.sender] > 0, \"No allowance\");\r\n    require(rebalancingPeriod > withdrawalRequestPeriod[msg.sender], \"Funds not arrived\");\r\n\r\n    value = withdrawalAllowance[msg.sender];\r\n\r\n    require(vaultCurrency.balanceOf(address(this)) >= value, \"No funds\");\r\n\r\n    reservedFunds -= value;\r\n    delete withdrawalAllowance[msg.sender];\r\n    delete withdrawalRequestPeriod[msg.sender];\r\n\r\n    vaultCurrency.safeTransfer(msg.sender, value);\r\n  }\r\n\r\n  /// @notice Function for the game to set a withdrawalRequest for the rewards of the game user\r\n  /// @param _value Amount to set a request in vaultCurrency\r\n  /// @param _user Address of the user\r\n  function redeemRewardsGame(uint256 _value, address _user)\r\n    external\r\n    onlyGame\r\n    nonReentrant\r\n    onlyWhenVaultIsOn\r\n  {\r\n    require(rewardAllowance[_user] == 0, \"No allowance\");\r\n\r\n    rewardAllowance[_user] = _value;\r\n    rewardRequestPeriod[_user] = rebalancingPeriod;\r\n    totalWithdrawalRequests += _value;\r\n  }\r\n\r\n  /// @notice Withdraw the reward allowance set by the game with redeemRewardsGame\r\n  /// @dev Will swap vaultCurrency to Derby tokens, send the user funds and reset the allowance\r\n  function withdrawRewards() external nonReentrant onlyWhenIdle returns (uint256 value) {\r\n    require(rewardAllowance[msg.sender] > 0, \"No allowance\");\r\n    require(rebalancingPeriod > rewardRequestPeriod[msg.sender], \"Funds not arrived\");\r\n\r\n    value = rewardAllowance[msg.sender];\r\n\r\n    require(vaultCurrency.balanceOf(address(this)) >= value, \"No funds\");\r\n\r\n    reservedFunds -= value;\r\n    delete rewardAllowance[msg.sender];\r\n    delete rewardRequestPeriod[msg.sender];\r\n\r\n    if (swapRewards) {\r\n      uint256 tokensReceived = Swap.swapTokensMulti(\r\n        Swap.SwapInOut(value, address(vaultCurrency), derbyToken),\r\n        controller.getUniswapParams()\r\n      );\r\n      IERC20(derbyToken).safeTransfer(msg.sender, tokensReceived);\r\n    } else {\r\n      vaultCurrency.safeTransfer(msg.sender, value);\r\n    }\r\n  }\r\n\r\n  /// @notice Step 2 trigger; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\r\n  /// @notice Pushes totalUnderlying, totalSupply and totalWithdrawalRequests of the vault for this chainId to xController\r\n  function pushTotalUnderlyingToController() external onlyWhenIdle {\r\n    require(rebalanceNeeded(), \"No rebalance needed\");\r\n\r\n    setTotalUnderlying();\r\n    uint256 underlying = savedTotalUnderlying + getVaultBalance();\r\n\r\n    IXProvider(xProvider).pushTotalUnderlying(\r\n      vaultNumber,\r\n      homeChain,\r\n      underlying,\r\n      totalSupply(),\r\n      totalWithdrawalRequests\r\n    );\r\n\r\n    state = State.PushedUnderlying;\r\n    lastTimeStamp = block.timestamp;\r\n\r\n    emit PushTotalUnderlying(\r\n      vaultNumber,\r\n      homeChain,\r\n      underlying,\r\n      totalSupply(),\r\n      totalWithdrawalRequests\r\n    );\r\n  }\r\n\r\n  /// @notice See setXChainAllocationInt below\r\n  function setXChainAllocation(uint256 _amountToSend, uint256 _exchangeRate)\r\n    external\r\n    onlyXProvider\r\n  {\r\n    require(state == State.PushedUnderlying, \"Wrong state\");\r\n    setXChainAllocationInt(_amountToSend, _exchangeRate);\r\n  }\r\n\r\n  /// @notice Step 3 end; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\r\n  /// @notice Will set the amount to send back to the xController by the xController\r\n  /// @dev Sets the amount and state so the dao can trigger the rebalanceXChain function\r\n  /// @dev When amount == 0 the vault doesnt need to send anything and will wait for funds from the xController\r\n  /// @param _amountToSend amount to send in vaultCurrency\r\n  function setXChainAllocationInt(uint256 _amountToSend, uint256 _exchangeRate) internal {\r\n    amountToSendXChain = _amountToSend;\r\n    exchangeRate = _exchangeRate;\r\n\r\n    if (_amountToSend == 0) state = State.WaitingForFunds;\r\n    else state = State.SendingFundsXChain;\r\n  }\r\n\r\n  /// @notice Step 4 trigger; Push funds from vaults to xChainController\r\n  /// @notice Send vaultcurrency to the xController for xChain rebalance\r\n  function rebalanceXChain() external {\r\n    if (state != State.SendingFundsXChain) return;\r\n\r\n    if (amountToSendXChain > getVaultBalance()) pullFunds(amountToSendXChain);\r\n\r\n    vaultCurrency.safeIncreaseAllowance(xProvider, amountToSendXChain);\r\n    IXProvider(xProvider).xTransferToController(\r\n      vaultNumber,\r\n      amountToSendXChain,\r\n      address(vaultCurrency)\r\n    );\r\n\r\n    amountToSendXChain = 0;\r\n    settleReservedFunds();\r\n\r\n    emit RebalanceXChain(vaultNumber, amountToSendXChain, address(vaultCurrency));\r\n  }\r\n\r\n  /// @notice Step 5 end; Push funds from xChainController to vaults\r\n  /// @notice Receiving feedback from xController when funds are received, so the vault can rebalance\r\n  function receiveFunds() external onlyXProvider {\r\n    if (state != State.WaitingForFunds) return;\r\n    settleReservedFunds();\r\n  }\r\n\r\n  /// @notice Helper to settle reserved funds when funds arrived and up to the next State\r\n  function settleReservedFunds() internal {\r\n    reservedFunds += totalWithdrawalRequests;\r\n    totalWithdrawalRequests = 0;\r\n    state = State.RebalanceVault;\r\n  }\r\n\r\n  /// @notice See receiveProtocolAllocations below\r\n  function receiveProtocolAllocations(int256[] memory _deltas) external onlyXProvider {\r\n    receiveProtocolAllocationsInt(_deltas);\r\n  }\r\n\r\n  /// @notice Step 6 end; Game pushes deltaAllocations to vaults\r\n  /// @notice Receives protocol allocation array from the game and settles the allocations\r\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\r\n  function receiveProtocolAllocationsInt(int256[] memory _deltas) internal {\r\n    for (uint i = 0; i < _deltas.length; i++) {\r\n      int256 allocation = _deltas[i];\r\n      if (allocation == 0) continue;\r\n      setDeltaAllocationsInt(i, allocation);\r\n    }\r\n\r\n    deltaAllocationsReceived = true;\r\n  }\r\n\r\n  /// @notice Step 8 trigger; Vaults push rewardsPerLockedToken to game\r\n  function sendRewardsToGame() external {\r\n    require(state == State.SendRewardsPerToken, \"Wrong state\");\r\n\r\n    int256[] memory rewards = rewardsToArray();\r\n    IXProvider(xProvider).pushRewardsToGame(vaultNumber, homeChain, rewards);\r\n\r\n    state = State.Idle;\r\n\r\n    emit PushedRewardsToGame(vaultNumber, homeChain, rewards);\r\n  }\r\n\r\n  /// @notice Receive feedback for the vault if the vault is set to on or off\r\n  /// @param _state bool for chainId on or off\r\n  function toggleVaultOnOff(bool _state) external onlyXProvider {\r\n    vaultOff = _state;\r\n  }\r\n\r\n  /// @notice Returns the amount in vaultCurrency the user is able to withdraw\r\n  function getWithdrawalAllowance() external view returns (uint256) {\r\n    return withdrawalAllowance[msg.sender];\r\n  }\r\n\r\n  /*\r\n  Only Dao functions\r\n  */\r\n\r\n  /// @notice Setter for xProvider address\r\n  /// @param _xProvider new address of xProvider on this chain\r\n  function setHomeXProvider(address _xProvider) external onlyDao {\r\n    xProvider = _xProvider;\r\n  }\r\n\r\n  /// @notice Setter for derby token address\r\n  /// @param _token New address of the derby token\r\n  function setDaoToken(address _token) external onlyDao {\r\n    derbyToken = _token;\r\n  }\r\n\r\n  /// @notice Setter for new game address\r\n  /// @param _game New address of the game\r\n  function setGame(address _game) external onlyDao {\r\n    game = _game;\r\n  }\r\n\r\n  /// @notice Setter for swapping rewards to derby tokens\r\n  /// @param _state True when rewards should be swapped to derby tokens\r\n  function setSwapRewards(bool _state) external onlyDao {\r\n    swapRewards = _state;\r\n  }\r\n\r\n  /*\r\n  Only Guardian functions\r\n  */\r\n\r\n  /// @notice Step 3: Guardian function\r\n  function setXChainAllocationGuard(uint256 _amountToSend, uint256 _exchangeRate)\r\n    external\r\n    onlyGuardian\r\n  {\r\n    setXChainAllocationInt(_amountToSend, _exchangeRate);\r\n  }\r\n\r\n  /// @notice Step 5: Guardian function\r\n  function receiveFundsGuard() external onlyGuardian {\r\n    settleReservedFunds();\r\n  }\r\n\r\n  /// @notice Step 6: Guardian function\r\n  function receiveProtocolAllocationsGuard(int256[] memory _deltas) external onlyGuardian {\r\n    receiveProtocolAllocationsInt(_deltas);\r\n  }\r\n\r\n  /// @notice Guardian function to set state when vault gets stuck for whatever reason\r\n  function setVaultStateGuard(State _state) external onlyGuardian {\r\n    state = _state;\r\n  }\r\n\r\n  /// @notice Setter for new homeChain Id\r\n  function setChainIds(uint16 _homeChain) external onlyGuardian {\r\n    homeChain = _homeChain;\r\n  }\r\n}\r\n"
    },
    "contracts/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\nimport \"./Interfaces/IController.sol\";\r\nimport \"./Interfaces/IProvider.sol\";\r\n\r\nimport \"./VaultToken.sol\";\r\nimport \"./libraries/Swap.sol\";\r\n\r\ncontract Vault is ReentrancyGuard {\r\n  using SafeERC20 for IERC20;\r\n\r\n  // state 0 Rebalance done and ready for xController to rebalance again\r\n  // state 1 Allocation amount received and ready to send funds over to xController\r\n  // state 2 Allocation amount 0 received => will receive funds from xController\r\n  // state 3 Allocation amount sent or received and ready to rebalance the vault itself\r\n  enum State {\r\n    Idle,\r\n    PushedUnderlying,\r\n    SendingFundsXChain,\r\n    WaitingForFunds,\r\n    RebalanceVault,\r\n    SendRewardsPerToken\r\n  }\r\n\r\n  IERC20 public vaultCurrency;\r\n  IController public controller;\r\n  State public state;\r\n\r\n  bool public deltaAllocationsReceived;\r\n\r\n  address private dao;\r\n  address private guardian;\r\n  address public vaultCurrencyAddr;\r\n  address public xController;\r\n\r\n  uint256 public vaultNumber;\r\n  uint256 public liquidityPerc = 10;\r\n  uint256 public performanceFee = 10;\r\n  uint256 public rebalancingPeriod = 1;\r\n  uint256 public uScale;\r\n  int256 public marginScale = 1E10; // 10000 USDC\r\n\r\n  // UNIX timestamp\r\n  uint256 public rebalanceInterval; // SHOULD BE REPLACED FOR REALISTIC NUMBER\r\n  uint256 public lastTimeStamp;\r\n  uint256 public gasFeeLiquidity;\r\n\r\n  // total underlying of all protocols in vault, excluding vault balance\r\n  uint256 public savedTotalUnderlying;\r\n\r\n  // total amount of funds the vault reserved for users that made a withdrawalRequest\r\n  uint256 internal reservedFunds;\r\n\r\n  // total number of allocated Derby tokens currently\r\n  int256 public totalAllocatedTokens;\r\n  // delta of the total number of Derby tokens allocated on next rebalancing\r\n  int256 private deltaAllocatedTokens;\r\n\r\n  // (protocolNumber => currentAllocation): current allocations over the protocols\r\n  mapping(uint256 => int256) internal currentAllocations;\r\n\r\n  // (protocolNumber => deltaAllocation): delta of the portfolio on next rebalancing\r\n  mapping(uint256 => int256) internal deltaAllocations;\r\n\r\n  // historical reward per protocol per token, formula: TVL * yield * perfFee / totalLockedTokens\r\n  // (rebalancingPeriod => protocolId => rewardPerLockedToken)\r\n  mapping(uint256 => mapping(uint256 => int256)) public rewardPerLockedToken;\r\n\r\n  // (protocolNumber => lastPrice): last price of underlying protocol vault\r\n  mapping(uint256 => uint256) public lastPrices;\r\n\r\n  event GasPaidRebalanceETF(uint256 gasInVaultCurrency);\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"Vault: only DAO\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == guardian, \"only Guardian\");\r\n    _;\r\n  }\r\n\r\n  modifier returnGasFee() {\r\n    uint256 gasStart = gasleft();\r\n    _;\r\n    uint256 gasUsed = gasStart - gasleft();\r\n    // console.log(\"gasUsed %s\", gasUsed);\r\n    swapAndPayGasFee(gasUsed);\r\n  }\r\n\r\n  constructor(\r\n    uint256 _vaultNumber,\r\n    address _dao,\r\n    address _controller,\r\n    address _vaultCurrency,\r\n    uint256 _uScale,\r\n    uint256 _gasFeeLiquidity\r\n  ) {\r\n    controller = IController(_controller);\r\n    vaultCurrency = IERC20(_vaultCurrency);\r\n\r\n    vaultNumber = _vaultNumber;\r\n    dao = _dao;\r\n    uScale = _uScale;\r\n    gasFeeLiquidity = _gasFeeLiquidity;\r\n    lastTimeStamp = block.timestamp;\r\n  }\r\n\r\n  /// @notice Withdraw from protocols on shortage in Vault\r\n  /// @dev Keeps on withdrawing until the Vault balance > _value\r\n  /// @param _value The total value of vaultCurrency an user is trying to withdraw.\r\n  /// @param _value The (value - current underlying value of this vault) is withdrawn from the underlying protocols.\r\n  function pullFunds(uint256 _value) internal {\r\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\r\n    for (uint i = 0; i < latestID; i++) {\r\n      if (currentAllocations[i] == 0) continue;\r\n\r\n      uint256 shortage = _value - getVaultBalance();\r\n      uint256 balanceProtocol = balanceUnderlying(i);\r\n\r\n      uint256 amountToWithdraw = shortage > balanceProtocol ? balanceProtocol : shortage;\r\n      savedTotalUnderlying -= amountToWithdraw;\r\n\r\n      withdrawFromProtocol(i, amountToWithdraw);\r\n\r\n      if (_value <= getVaultBalance()) break;\r\n    }\r\n  }\r\n\r\n  /// @notice Step 7 trigger, end; Vaults rebalance\r\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\r\n  /// @dev amountToProtocol = totalAmount * currentAllocation / totalAllocatedTokens\r\n  /// @dev amountToDeposit = amountToProtocol - currentBalanceProtocol\r\n  /// @dev if amountToDeposit < 0 => withdraw\r\n  /// @dev Execute all withdrawals before deposits\r\n  function rebalanceETF() external returnGasFee nonReentrant {\r\n    require(state == State.RebalanceVault, \"Wrong state\");\r\n    require(deltaAllocationsReceived, \"!Delta allocations\");\r\n\r\n    rebalancingPeriod++;\r\n\r\n    claimTokens();\r\n    settleDeltaAllocation();\r\n\r\n    uint256 underlyingIncBalance = calcUnderlyingIncBalance();\r\n    uint256[] memory protocolToDeposit = rebalanceCheckProtocols(underlyingIncBalance);\r\n\r\n    executeDeposits(protocolToDeposit);\r\n    setTotalUnderlying();\r\n\r\n    if (getVaultBalance() < gasFeeLiquidity) pullFunds(gasFeeLiquidity);\r\n\r\n    state = State.SendRewardsPerToken;\r\n    deltaAllocationsReceived = false;\r\n  }\r\n\r\n  /// @notice Helper to return underlying balance plus totalUnderlying - liquidty for the vault\r\n  /// @return underlying totalUnderlying - liquidityVault\r\n  function calcUnderlyingIncBalance() internal view returns (uint256) {\r\n    uint256 totalUnderlyingInclVaultBalance = savedTotalUnderlying + getVaultBalance();\r\n    uint256 liquidityVault = (totalUnderlyingInclVaultBalance * liquidityPerc) / 100;\r\n    return totalUnderlyingInclVaultBalance - liquidityVault;\r\n  }\r\n\r\n  /// @notice Adds deltaAllocatedTokens to totalAllocatedTokens\r\n  function settleDeltaAllocation() internal {\r\n    totalAllocatedTokens += deltaAllocatedTokens;\r\n    deltaAllocatedTokens = 0;\r\n  }\r\n\r\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\r\n  /// @dev Loops over all protocols in ETF, calculate new currentAllocation based on deltaAllocation\r\n  /// @dev Also calculate the performance fee here. This is an amount, based on the current TVL (before the rebalance),\r\n  /// @dev the performanceFee and difference between the current exchangeRate and the exchangeRate of the last rebalance of the vault.\r\n  /// @param _newTotalUnderlying this will be the new total underlying: Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\r\n  /// @return uint256[] with amounts to deposit in protocols, the index being the protocol number.\r\n  function rebalanceCheckProtocols(uint256 _newTotalUnderlying)\r\n    internal\r\n    returns (uint256[] memory)\r\n  {\r\n    uint256[] memory protocolToDeposit = new uint[](controller.latestProtocolId(vaultNumber));\r\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\r\n    for (uint i = 0; i < latestID; i++) {\r\n      bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, i);\r\n\r\n      storePriceAndRewards(_newTotalUnderlying, i);\r\n\r\n      if (isBlacklisted) continue;\r\n      setAllocation(i);\r\n\r\n      int256 amountToProtocol = calcAmountToProtocol(_newTotalUnderlying, i);\r\n      uint256 currentBalance = balanceUnderlying(i);\r\n\r\n      int256 amountToDeposit = amountToProtocol - int(currentBalance);\r\n      uint256 amountToWithdraw = amountToDeposit < 0 ? currentBalance - uint(amountToProtocol) : 0;\r\n\r\n      if (amountToDeposit > marginScale) protocolToDeposit[i] = uint256(amountToDeposit);\r\n      if (amountToWithdraw > uint(marginScale) || currentAllocations[i] == 0)\r\n        withdrawFromProtocol(i, amountToWithdraw);\r\n    }\r\n\r\n    return protocolToDeposit;\r\n  }\r\n\r\n  /// @notice Calculates the amount to deposit or withdraw to protocol during a vault rebalance\r\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\r\n  /// @param _protocol Protocol id number\r\n  /// @return amountToProtocol amount to deposit or withdraw to protocol\r\n  function calcAmountToProtocol(uint256 _totalUnderlying, uint256 _protocol)\r\n    internal\r\n    view\r\n    returns (int256 amountToProtocol)\r\n  {\r\n    if (totalAllocatedTokens == 0) amountToProtocol = 0;\r\n    else\r\n      amountToProtocol =\r\n        (int(_totalUnderlying) * currentAllocations[_protocol]) /\r\n        totalAllocatedTokens;\r\n  }\r\n\r\n  /// @notice Stores the historical price and the reward per rounded locked token, ignoring decimals.\r\n  /// @dev formula yield protocol i at time t: y(it) = (P(it) - P(it-1)) / P(it-1).\r\n  /// @dev formula rewardPerLockedToken for protocol i at time t: r(it) = y(it) * TVL(t) * perfFee(t) / totalLockedTokens(t)\r\n  /// @dev later, when the total rewards are calculated for a game player we multiply this (r(it)) by the locked tokens on protocol i at time t\r\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault.\r\n  /// @param _protocolId Protocol id number.\r\n  function storePriceAndRewards(uint256 _totalUnderlying, uint256 _protocolId) internal {\r\n    uint256 price = price(_protocolId);\r\n    if (lastPrices[_protocolId] == 0) return;\r\n    int256 priceDiff = int256(price - lastPrices[_protocolId]);\r\n    int256 nominator = (int256(_totalUnderlying * performanceFee) * priceDiff);\r\n    int256 totalAllocatedTokensRounded = totalAllocatedTokens / 1E18;\r\n    int256 denominator = totalAllocatedTokensRounded * int256(lastPrices[_protocolId]) * 100; // * 100 cause perfFee is in percentages\r\n    if (totalAllocatedTokensRounded == 0) {\r\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = 0;\r\n    } else {\r\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = nominator / denominator;\r\n    }\r\n    lastPrices[_protocolId] = price;\r\n  }\r\n\r\n  /// @notice Creates array out of the rewardsPerLockedToken mapping to send to the game\r\n  /// @return rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\r\n  function rewardsToArray() internal view returns (int256[] memory rewards) {\r\n    uint256 latestId = controller.latestProtocolId(vaultNumber);\r\n    rewards = new int[](latestId);\r\n\r\n    for (uint256 i = 0; i < latestId; i++) {\r\n      rewards[i] = rewardPerLockedToken[rebalancingPeriod][i];\r\n    }\r\n  }\r\n\r\n  /// @notice Swaps the gas used from RebalanceETF, from vaultcurrency to ETH and send it to the dao\r\n  /// @notice This way the vault will pay the gas for the RebalanceETF function\r\n  /// @param _gasUsed total gas used by RebalanceETF\r\n  function swapAndPayGasFee(uint256 _gasUsed) internal {\r\n    uint256 amountEtherToVaultCurrency = Swap.amountOutSingleSwap(\r\n      Swap.SwapInOut(\r\n        (_gasUsed + Swap.gasUsedForSwap) * controller.getGasPrice(),\r\n        Swap.WETH,\r\n        address(vaultCurrency)\r\n      ),\r\n      controller.getUniswapQuoter(),\r\n      controller.getUniswapPoolFee()\r\n    );\r\n\r\n    uint256 wethReceived = Swap.swapTokensSingle(\r\n      Swap.SwapInOut(amountEtherToVaultCurrency, address(vaultCurrency), Swap.WETH),\r\n      controller.getUniswapParams()\r\n    );\r\n    Swap.unWrapWETHtoGov(payable(dao), wethReceived);\r\n\r\n    emit GasPaidRebalanceETF(amountEtherToVaultCurrency);\r\n  }\r\n\r\n  /// @notice Helper function to set allocations\r\n  /// @param _i Protocol number linked to an underlying protocol e.g compound_usdc_01\r\n  function setAllocation(uint256 _i) internal {\r\n    currentAllocations[_i] += deltaAllocations[_i];\r\n    deltaAllocations[_i] = 0;\r\n    require(currentAllocations[_i] >= 0, \"Allocation underflow\");\r\n  }\r\n\r\n  /// @notice Helper function so the rebalance will execute all withdrawals first\r\n  /// @dev Executes and resets all deposits set in mapping(protocolToDeposit) by rebalanceETF\r\n  /// @param protocolToDeposit array with amounts to deposit in protocols, the index being the protocol number.\r\n  function executeDeposits(uint256[] memory protocolToDeposit) internal {\r\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\r\n    for (uint i = 0; i < latestID; i++) {\r\n      uint256 amount = protocolToDeposit[i];\r\n      if (amount == 0) continue;\r\n      // console.log(\"protocol: %s, deposit: %s\", i, amount);\r\n      depositInProtocol(i, amount);\r\n    }\r\n  }\r\n\r\n  /// @notice Deposit amount to underlying protocol\r\n  /// @dev Deposits VaultCurrency in Protocol e.g USDC\r\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\r\n  /// @param _amount in VaultCurrency to deposit\r\n  function depositInProtocol(uint256 _protocolNum, uint256 _amount) internal {\r\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\r\n      vaultNumber,\r\n      _protocolNum\r\n    );\r\n\r\n    if (getVaultBalance() < _amount) _amount = getVaultBalance();\r\n\r\n    if (protocol.underlying != address(vaultCurrency)) {\r\n      _amount = Swap.swapStableCoins(\r\n        Swap.SwapInOut(_amount, address(vaultCurrency), protocol.underlying),\r\n        uScale,\r\n        controller.underlyingUScale(protocol.underlying),\r\n        controller.getCurveParams(address(vaultCurrency), protocol.underlying)\r\n      );\r\n    }\r\n\r\n    IERC20(protocol.underlying).safeIncreaseAllowance(protocol.provider, _amount);\r\n    IProvider(protocol.provider).deposit(_amount, protocol.LPToken, protocol.underlying);\r\n  }\r\n\r\n  /// @notice Withdraw amount from underlying protocol\r\n  /// @dev shares = amount / PricePerShare\r\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\r\n  /// @param _amount in VaultCurrency to withdraw\r\n  function withdrawFromProtocol(uint256 _protocolNum, uint256 _amount) internal {\r\n    if (_amount <= 0) return;\r\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\r\n      vaultNumber,\r\n      _protocolNum\r\n    );\r\n\r\n    _amount = (_amount * protocol.uScale) / uScale;\r\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\r\n\r\n    IERC20(protocol.LPToken).safeIncreaseAllowance(protocol.provider, shares);\r\n    uint256 amountReceived = IProvider(protocol.provider).withdraw(\r\n      shares,\r\n      protocol.LPToken,\r\n      protocol.underlying\r\n    );\r\n\r\n    if (protocol.underlying != address(vaultCurrency)) {\r\n      _amount = Swap.swapStableCoins(\r\n        Swap.SwapInOut(amountReceived, protocol.underlying, address(vaultCurrency)),\r\n        controller.underlyingUScale(protocol.underlying),\r\n        uScale,\r\n        controller.getCurveParams(protocol.underlying, address(vaultCurrency))\r\n      );\r\n    }\r\n  }\r\n\r\n  /// @notice Set total balance in VaultCurrency in all underlying protocols\r\n  function setTotalUnderlying() public {\r\n    uint totalUnderlying;\r\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\r\n    for (uint i = 0; i < latestID; i++) {\r\n      if (currentAllocations[i] == 0) continue;\r\n      totalUnderlying += balanceUnderlying(i);\r\n    }\r\n    savedTotalUnderlying = totalUnderlying;\r\n  }\r\n\r\n  /// @notice Get balance in VaultCurrency in underlying protocol\r\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\r\n  /// @return Balance in VaultCurrency e.g USDC\r\n  function balanceUnderlying(uint256 _protocolNum) public view returns (uint256) {\r\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\r\n      vaultNumber,\r\n      _protocolNum\r\n    );\r\n    uint256 underlyingBalance = (IProvider(protocol.provider).balanceUnderlying(\r\n      address(this),\r\n      protocol.LPToken\r\n    ) * uScale) / protocol.uScale;\r\n\r\n    return underlyingBalance;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount in vault currency\r\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _protocolNum, uint256 _amount) public view returns (uint256) {\r\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\r\n      vaultNumber,\r\n      _protocolNum\r\n    );\r\n    uint256 shares = IProvider(protocol.provider).calcShares(\r\n      (_amount * protocol.uScale) / uScale,\r\n      protocol.LPToken\r\n    );\r\n\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get price for underlying protocol\r\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\r\n  /// @return protocolPrice Price per lp token\r\n  function price(uint256 _protocolNum) public view returns (uint256) {\r\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\r\n      vaultNumber,\r\n      _protocolNum\r\n    );\r\n    return IProvider(protocol.provider).exchangeRate(protocol.LPToken);\r\n  }\r\n\r\n  /// @notice Set the delta allocated tokens by game contract\r\n  /// @dev Allocation can be negative\r\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\r\n  /// @param _allocation Delta allocation in tokens\r\n  function setDeltaAllocationsInt(uint256 _protocolNum, int256 _allocation) internal {\r\n    require(!controller.getProtocolBlacklist(vaultNumber, _protocolNum), \"Protocol on blacklist\");\r\n    deltaAllocations[_protocolNum] += _allocation;\r\n    deltaAllocatedTokens += _allocation;\r\n  }\r\n\r\n  /// @notice Harvest extra tokens from underlying protocols\r\n  /// @dev Loops over protocols in ETF and check if they are claimable in controller contract\r\n  function claimTokens() public {\r\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\r\n    for (uint i = 0; i < latestID; i++) {\r\n      if (currentAllocations[i] == 0) continue;\r\n      bool claim = controller.claim(vaultNumber, i);\r\n      if (claim) {\r\n        address govToken = controller.getGovToken(vaultNumber, i);\r\n        uint256 tokenBalance = IERC20(govToken).balanceOf(address(this));\r\n        Swap.swapTokensMulti(\r\n          Swap.SwapInOut(tokenBalance, govToken, address(vaultCurrency)),\r\n          controller.getUniswapParams()\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  function getVaultBalance() public view returns (uint256) {\r\n    return vaultCurrency.balanceOf(address(this)) - reservedFunds;\r\n  }\r\n\r\n  /// @notice Checks if a rebalance is needed based on the set interval\r\n  /// @return bool True of rebalance is needed, false if not\r\n  function rebalanceNeeded() public view returns (bool) {\r\n    return (block.timestamp - lastTimeStamp) > rebalanceInterval;\r\n  }\r\n\r\n  /// @notice Getter for dao address\r\n  function getDao() public view returns (address) {\r\n    return dao;\r\n  }\r\n\r\n  /// @notice Getter for guardian address\r\n  function getGuardian() public view returns (address) {\r\n    return guardian;\r\n  }\r\n\r\n  /*\r\n  Only Dao functions\r\n  */\r\n\r\n  /// @notice Set the performanceFee, the percentage of the yield that goes to the game players.\r\n  /// @dev The actual performanceFee could be a bit more or a bit less than the performanceFee set here due to approximations in the game.\r\n  /// @param _performanceFee Value at which to set the performanceFee.\r\n  function setPerformanceFee(uint256 _performanceFee) external onlyDao {\r\n    require(_performanceFee <= 100, \"Cannot exceed 100%\");\r\n    performanceFee = _performanceFee;\r\n  }\r\n\r\n  /// @notice Set the governance address\r\n  /// @param _dao New address of the governance / DAO\r\n  function setDao(address _dao) external onlyDao {\r\n    dao = _dao;\r\n  }\r\n\r\n  /// @notice Setter for guardian address\r\n  /// @param _guardian new address of the guardian\r\n  function setGuardian(address _guardian) external onlyDao {\r\n    guardian = _guardian;\r\n  }\r\n\r\n  /*\r\n  Only Guardian functions\r\n  */\r\n\r\n  /// @notice Set the gasFeeLiquidity, liquidity in vaultcurrency which always should be kept in vault to pay for rebalance gas fee\r\n  /// @param _gasFeeLiquidity Value at which to set the gasFeeLiquidity in vaultCurrency\r\n  function setGasFeeLiquidity(uint256 _gasFeeLiquidity) external onlyGuardian {\r\n    gasFeeLiquidity = _gasFeeLiquidity;\r\n  }\r\n\r\n  /// @notice Set minimum interval for the rebalance function\r\n  /// @param _timestampInternal UNIX timestamp\r\n  function setRebalanceInterval(uint256 _timestampInternal) external onlyGuardian {\r\n    rebalanceInterval = _timestampInternal;\r\n  }\r\n\r\n  /// @notice The DAO should be able to blacklist protocols, the funds should be sent to the vault.\r\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\r\n  function blacklistProtocol(uint256 _protocolNum) external onlyGuardian {\r\n    uint256 balanceProtocol = balanceUnderlying(_protocolNum);\r\n    currentAllocations[_protocolNum] = 0;\r\n    controller.setProtocolBlacklist(vaultNumber, _protocolNum);\r\n    savedTotalUnderlying -= balanceProtocol;\r\n    withdrawFromProtocol(_protocolNum, balanceProtocol);\r\n  }\r\n\r\n  /// @notice Set the marginScale, the threshold used for deposits and withdrawals.\r\n  /// @notice If the threshold is not met the deposit/ withdrawal is not executed.\r\n  /// @dev Take into account the uScale (scale of the underlying).\r\n  /// @param _marginScale Value at which to set the marginScale.\r\n  function setMarginScale(int256 _marginScale) external onlyGuardian {\r\n    marginScale = _marginScale;\r\n  }\r\n\r\n  /// @notice Set the liquidityPerc, the amount of liquidity which should be held in the vault after rebalancing.\r\n  /// @dev The actual liquidityPerc could be a bit more or a bit less than the liquidityPerc set here.\r\n  /// @dev This is because some deposits or withdrawals might not execute because they don't meet the marginScale.\r\n  /// @param _liquidityPerc Value at which to set the liquidityPerc.\r\n  function setLiquidityPerc(uint256 _liquidityPerc) external onlyGuardian {\r\n    require(_liquidityPerc <= 100, \"Cannot exceed 100%\");\r\n    liquidityPerc = _liquidityPerc;\r\n  }\r\n\r\n  /// @notice callback to receive Ether from unwrapping WETH\r\n  receive() external payable {\r\n    require(msg.sender == Swap.WETH, \"Not WETH\");\r\n  }\r\n}\r\n"
    },
    "contracts/Interfaces/IXProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\ninterface IXProvider {\r\n  function xCall(\r\n    address _xProvider,\r\n    uint16 _chainId,\r\n    bytes memory _callData\r\n  ) external;\r\n\r\n  function xSend(uint256 _value) external; // sending a (permissioned) value crosschain.\r\n\r\n  // function xSendCallback() external; // sending a (permissioned) vaule crosschain and receive a callback to a specified address.\r\n  function xReceive(uint256 _value) external; // receiving a (permissioned) value crosschain.\r\n\r\n  function pushAllocations(uint256 _vaultNumber, int256[] memory _deltas) external;\r\n\r\n  function receiveTotalUnderlying(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _underlying\r\n  ) external;\r\n\r\n  function pushSetXChainAllocation(\r\n    address _vault,\r\n    uint16 _chainId,\r\n    uint256 _amountToWithdraw,\r\n    uint256 _exchangeRate\r\n  ) external;\r\n\r\n  function xTransferToController(\r\n    uint256 _vaultNumber,\r\n    uint256 _amount,\r\n    address _asset\r\n  ) external;\r\n\r\n  function receiveFeedbackToXController(uint256 _vaultNumber) external;\r\n\r\n  function xTransferToVaults(\r\n    address _vault,\r\n    uint16 _chainId,\r\n    uint256 _amount,\r\n    address _asset\r\n  ) external;\r\n\r\n  function pushProtocolAllocationsToVault(\r\n    uint16 _chainId,\r\n    address _vault,\r\n    int256[] memory _deltas\r\n  ) external;\r\n\r\n  function getDecimals(address _vault) external view returns (uint256);\r\n\r\n  function pushTotalUnderlying(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) external;\r\n\r\n  function pushStateFeedbackToVault(\r\n    address _vault,\r\n    uint16 _chainId,\r\n    bool _state\r\n  ) external;\r\n\r\n  function pushRewardsToGame(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    int256[] memory _rewards\r\n  ) external;\r\n\r\n  function homeChain() external returns (uint16);\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/Interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\ninterface IController {\r\n  struct ProtocolInfoS {\r\n    address LPToken;\r\n    address provider;\r\n    address underlying; // address of underlying token of the protocol eg USDC\r\n    uint256 uScale; // uScale of protocol LP Token\r\n  }\r\n\r\n  struct UniswapParams {\r\n    address router;\r\n    address quoter;\r\n    uint24 poolFee;\r\n  }\r\n\r\n  struct CurveParams {\r\n    int128 indexTokenIn;\r\n    int128 indexTokenOut;\r\n    address pool;\r\n    uint256 poolFee;\r\n  }\r\n\r\n  function claim(uint256 _ETFnumber, uint256 protocolNumber) external returns (bool);\r\n\r\n  function addProtocol(\r\n    string calldata name,\r\n    uint256 _ETFnumber,\r\n    address provider,\r\n    address protocolLPToken,\r\n    address underlying,\r\n    address govToken,\r\n    uint256 _uScale\r\n  ) external returns (uint256);\r\n\r\n  function curve3Pool() external view returns (address);\r\n\r\n  function curve3PoolFee() external view returns (uint256);\r\n\r\n  function curveIndex(address _token) external view returns (int128);\r\n\r\n  function getProtocolInfo(uint256 _ETFnumber, uint256 protocolNumber)\r\n    external\r\n    view\r\n    returns (ProtocolInfoS memory);\r\n\r\n  function getUniswapParams() external view returns (UniswapParams memory);\r\n\r\n  function getCurveParams(address _in, address _out) external view returns (CurveParams memory);\r\n\r\n  function latestProtocolId(uint256 _ETFnumber) external view returns (uint256);\r\n\r\n  function addVault(address _vault) external;\r\n\r\n  function addCurveIndex(address _token, int128 _index) external;\r\n\r\n  function underlyingUScale(address _token) external view returns (uint256);\r\n\r\n  function setUniswapRouter(address _uniswapRouter) external;\r\n\r\n  function setUniswapQuoter(address _uniswapQuoter) external;\r\n\r\n  function setUniswapPoolFee(uint24 _poolFee) external;\r\n\r\n  function getUniswapPoolFee() external view returns (uint24);\r\n\r\n  function getUniswapQuoter() external view returns (address);\r\n\r\n  function getProtocolBlacklist(uint256 _ETFnumber, uint256 _protocolNum)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  function setProtocolBlacklist(uint256 _ETFnumber, uint256 _protocolNum) external;\r\n\r\n  function getGasPrice() external returns (uint256);\r\n\r\n  function setGasPriceOracle(address _chainlinkGasPriceOracle) external;\r\n\r\n  function getGovToken(uint256 _vaultNumber, uint256 _protocolNum) external view returns (address);\r\n\r\n  function getDao() external view returns (address);\r\n}\r\n"
    },
    "contracts/Interfaces/IProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\ninterface IProvider {\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _uToken,\r\n    address _protocolLPToken\r\n  ) external returns (uint256);\r\n\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _uToken,\r\n    address _protocolLPToken\r\n  ) external returns (uint256);\r\n\r\n  function exchangeRate(address _protocolLPToken) external view returns (uint256);\r\n\r\n  function balanceUnderlying(address _address, address _protocolLPToken)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function calcShares(uint256 _amount, address _protocolLPToken) external view returns (uint256);\r\n\r\n  function balance(address _address, address _protocolLPToken) external view returns (uint256);\r\n\r\n  function claim(address _protocolLPToken, address _claimer) external returns (bool);\r\n}\r\n"
    },
    "contracts/VaultToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract VaultToken is ERC20 {\r\n  uint8 private decimals_;\r\n\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint8 _decimals\r\n  ) ERC20(_name, _symbol) {\r\n    decimals_ = _decimals;\r\n  }\r\n\r\n  function decimals() public view virtual override returns (uint8) {\r\n    return decimals_;\r\n  }\r\n}\r\n"
    },
    "contracts/libraries/Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../Interfaces/IController.sol\";\r\n\r\nimport \"../Interfaces/ExternalInterfaces/ISwapRouter.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IUniswapV3Factory.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IUniswapV3Pool.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IStableSwap3Pool.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IWETH.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IQuoter.sol\";\r\n\r\nlibrary Swap {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct SwapInOut {\r\n    uint256 amount;\r\n    address tokenIn;\r\n    address tokenOut;\r\n  }\r\n\r\n  address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n  uint256 internal constant gasUsedForSwap = 210000;\r\n\r\n  /// @notice Swap stable coins on Curve\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _tokenInUScale Scale of tokenIn e.g 1E6\r\n  /// @param _tokenOutUScale Scale of tokenOut e.g 1E6\r\n  /// @param _curve Curve pool index number of TokenIn address, tokenOut address, pool address and pool fee\r\n  function swapStableCoins(\r\n    SwapInOut memory _swap,\r\n    uint256 _tokenInUScale,\r\n    uint256 _tokenOutUScale,\r\n    IController.CurveParams memory _curve\r\n  ) public returns (uint256) {\r\n    uint256 amountOutMin = (((_swap.amount * (10000 - _curve.poolFee)) / 10000) * _tokenOutUScale) /\r\n      _tokenInUScale;\r\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_curve.pool, _swap.amount);\r\n\r\n    uint256 balanceBefore = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    IStableSwap3Pool(_curve.pool).exchange(\r\n      _curve.indexTokenIn,\r\n      _curve.indexTokenOut,\r\n      _swap.amount,\r\n      amountOutMin\r\n    );\r\n\r\n    uint256 balanceAfter = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    return balanceAfter - balanceBefore;\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswap Address of uniswapRouter, uniswapQuoter and poolfee\r\n  /// @return Amountout Number of tokens received\r\n  function swapTokensMulti(SwapInOut memory _swap, IController.UniswapParams memory _uniswap)\r\n    public\r\n    returns (uint256)\r\n  {\r\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_uniswap.router, _swap.amount);\r\n\r\n    uint256 amountOutMinimum = IQuoter(_uniswap.quoter).quoteExactInput(\r\n      abi.encodePacked(_swap.tokenIn, _uniswap.poolFee, WETH, _uniswap.poolFee, _swap.tokenOut),\r\n      _swap.amount\r\n    );\r\n\r\n    ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\r\n      path: abi.encodePacked(\r\n        _swap.tokenIn,\r\n        _uniswap.poolFee,\r\n        WETH,\r\n        _uniswap.poolFee,\r\n        _swap.tokenOut\r\n      ),\r\n      recipient: address(this),\r\n      deadline: block.timestamp,\r\n      amountIn: _swap.amount,\r\n      amountOutMinimum: amountOutMinimum\r\n    });\r\n\r\n    uint256 balanceBefore = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n    ISwapRouter(_uniswap.router).exactInput(params);\r\n    uint256 balanceAfter = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    return balanceAfter - balanceBefore;\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswap Address of uniswapRouter, uniswapQuoter and poolfee\r\n  /// @return Amountout Number of tokens received\r\n  function swapTokensSingle(SwapInOut memory _swap, IController.UniswapParams memory _uniswap)\r\n    public\r\n    returns (uint256)\r\n  {\r\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_uniswap.router, _swap.amount);\r\n\r\n    uint256 amountOutMinimum = amountOutSingleSwap(\r\n      SwapInOut(_swap.amount, _swap.tokenIn, _swap.tokenOut),\r\n      _uniswap.quoter,\r\n      _uniswap.poolFee\r\n    );\r\n\r\n    ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\r\n      tokenIn: _swap.tokenIn,\r\n      tokenOut: _swap.tokenOut,\r\n      fee: _uniswap.poolFee,\r\n      recipient: address(this),\r\n      deadline: block.timestamp,\r\n      amountIn: _swap.amount,\r\n      amountOutMinimum: amountOutMinimum,\r\n      sqrtPriceLimitX96: 0\r\n    });\r\n\r\n    // The call to `exactInputSingle` executes the swap.\r\n    return ISwapRouter(_uniswap.router).exactInputSingle(params);\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswapQuoter Address of uniswapQuoter\r\n  /// @param _poolFee Current uniswap pool fee set in router e.g 3000\r\n  /// @return amountOutMin minimum amount out of tokens to receive when executing swap\r\n  function amountOutSingleSwap(\r\n    SwapInOut memory _swap,\r\n    address _uniswapQuoter,\r\n    uint24 _poolFee\r\n  ) public returns (uint256) {\r\n    return\r\n      IQuoter(_uniswapQuoter).quoteExactInputSingle(\r\n        _swap.tokenIn,\r\n        _swap.tokenOut,\r\n        _poolFee,\r\n        _swap.amount,\r\n        0\r\n      );\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap Multi route\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswapQuoter Address of uniswapQuoter\r\n  /// @param _poolFee Current uniswap pool fee set in router e.g 3000\r\n  /// @return amountOutMin minimum amount out of tokens to receive when executing swap\r\n  function amountOutMultiSwap(\r\n    SwapInOut memory _swap,\r\n    address _uniswapQuoter,\r\n    uint24 _poolFee\r\n  ) public returns (uint256) {\r\n    return\r\n      IQuoter(_uniswapQuoter).quoteExactInput(\r\n        abi.encodePacked(_swap.tokenIn, _poolFee, WETH, _poolFee, _swap.tokenOut),\r\n        _swap.amount\r\n      );\r\n  }\r\n\r\n  /// @notice Will unwrap WETH and send to DAO / governed address\r\n  /// @param _governed DAO / governed address\r\n  /// @param _amount amount to unwrap and transfer\r\n  function unWrapWETHtoGov(address payable _governed, uint256 _amount) internal {\r\n    IWETH9(WETH).withdraw(_amount);\r\n    (bool sent, ) = _governed.call{value: _amount}(\"\");\r\n    require(sent, \"Ether not sent\");\r\n  }\r\n}\r\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/Interfaces/ExternalInterfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface ISwapRouter {\r\n  struct ExactInputSingleParams {\r\n    address tokenIn;\r\n    address tokenOut;\r\n    uint24 fee;\r\n    address recipient;\r\n    uint256 deadline;\r\n    uint256 amountIn;\r\n    uint256 amountOutMinimum;\r\n    uint160 sqrtPriceLimitX96;\r\n  }\r\n\r\n  /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n  /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n  /// @return amountOut The amount of the received token\r\n  function exactInputSingle(ISwapRouter.ExactInputSingleParams memory params)\r\n    external\r\n    returns (uint256 amountOut);\r\n\r\n  struct ExactInputParams {\r\n    bytes path;\r\n    address recipient;\r\n    uint256 deadline;\r\n    uint256 amountIn;\r\n    uint256 amountOutMinimum;\r\n  }\r\n\r\n  /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n  /// @return amountOut The amount of the received token\r\n  function exactInput(ExactInputParams calldata params)\r\n    external\r\n    payable\r\n    returns (uint256 amountOut);\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IUniswapV3Factory {\r\n  function getPool(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint24 fee\r\n  ) external view returns (address pool);\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IUniswapV3Pool {\r\n  /// @notice The first of the two tokens of the pool, sorted by address\r\n  /// @return The token contract address\r\n  function token0() external view returns (address);\r\n\r\n  /// @notice The second of the two tokens of the pool, sorted by address\r\n  /// @return The token contract address\r\n  function token1() external view returns (address);\r\n\r\n  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\r\n  /// when accessed externally.\r\n  /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\r\n  /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\r\n  /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\r\n  /// boundary.\r\n  /// observationIndex The index of the last oracle observation that was written,\r\n  /// observationCardinality The current maximum number of observations stored in the pool,\r\n  /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\r\n  /// feeProtocol The protocol fee for both tokens of the pool.\r\n  /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\r\n  /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\r\n  /// unlocked Whether the pool is currently locked to reentrancy\r\n  function slot0()\r\n    external\r\n    view\r\n    returns (\r\n      uint160 sqrtPriceX96,\r\n      int24 tick,\r\n      uint16 observationIndex,\r\n      uint16 observationCardinality,\r\n      uint16 observationCardinalityNext,\r\n      uint8 feeProtocol,\r\n      bool unlocked\r\n    );\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IStableSwap3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IStableSwap3Pool {\r\n  function exchange(\r\n    int128 i,\r\n    int128 j,\r\n    uint256 dx,\r\n    uint256 min_dy\r\n  ) external;\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/// @title Interface for WETH9\r\ninterface IWETH9 is IERC20 {\r\n  /// @notice Deposit ether to get wrapped ether\r\n  function deposit() external payable;\r\n\r\n  /// @notice Withdraw wrapped ether to get ether\r\n  function withdraw(uint256) external;\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IQuoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\n/// @title Quoter Interface\r\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\r\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\r\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\r\ninterface IQuoter {\r\n  /// @notice Returns the amount out received for a given exact input swap without executing the swap\r\n  /// @param path The path of the swap, i.e. each token pair and the pool fee\r\n  /// @param amountIn The amount of the first token to swap\r\n  /// @return amountOut The amount of the last token that would be received\r\n  function quoteExactInput(bytes memory path, uint256 amountIn)\r\n    external\r\n    returns (uint256 amountOut);\r\n\r\n  /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\r\n  /// @param tokenIn The token being swapped in\r\n  /// @param tokenOut The token being swapped out\r\n  /// @param fee The fee of the token pool to consider for the pair\r\n  /// @param amountIn The desired input amount\r\n  /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\r\n  /// @return amountOut The amount of `tokenOut` that would be received\r\n  function quoteExactInputSingle(\r\n    address tokenIn,\r\n    address tokenOut,\r\n    uint24 fee,\r\n    uint256 amountIn,\r\n    uint160 sqrtPriceLimitX96\r\n  ) external returns (uint256 amountOut);\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/Tests/FeeTestContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"../MainVault.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract FeeTestContract is MainVault {\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint8 _decimals,\r\n    string memory _vaultName,\r\n    uint256 _vaultNumber,\r\n    address _governed,\r\n    address _Game,\r\n    address _router,\r\n    address _vaultCurrency,\r\n    uint256 _uScale,\r\n    uint256 _gasFeeLiquidity\r\n  )\r\n    MainVault(\r\n      _name,\r\n      _symbol,\r\n      _decimals,\r\n      _vaultNumber,\r\n      _governed,\r\n      _Game,\r\n      _router,\r\n      _vaultCurrency,\r\n      _uScale,\r\n      _gasFeeLiquidity\r\n    )\r\n  {}\r\n\r\n  uint256 public latestProtocol;\r\n\r\n  uint256 private testmooi = 12;\r\n\r\n  uint256[] public protocolsInETF;\r\n\r\n  mapping(uint256 => int256) private test;\r\n\r\n  function loopArray() public {\r\n    for (uint i = 0; i < protocolsInETF.length; i++) {\r\n      int256 amount = currentAllocations[protocolsInETF[i]];\r\n      test[i] = amount;\r\n    }\r\n  }\r\n\r\n  function loopMapping() public {\r\n    for (uint i = 0; i <= latestProtocol; i++) {\r\n      int256 amount = currentAllocations[i];\r\n      if (amount == 0) continue;\r\n      test[i] = amount;\r\n    }\r\n  }\r\n\r\n  function setArray(uint256 _protocol) public {\r\n    protocolsInETF.push(_protocol);\r\n  }\r\n\r\n  function setMapping(uint256 _protocol, int256 _amount) public {\r\n    currentAllocations[_protocol] = _amount;\r\n  }\r\n\r\n  function setLatestProtol(uint256 _amount) public {\r\n    latestProtocol = _amount;\r\n  }\r\n\r\n  function deleteArray() public {\r\n    delete protocolsInETF;\r\n  }\r\n}\r\n"
    },
    "contracts/Mocks/MainVaultMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"../MainVault.sol\";\r\n\r\ncontract MainVaultMock is MainVault {\r\n  mapping(uint256 => uint256) private players;\r\n\r\n  event MinAmountOut(uint256 minAmountOut);\r\n\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint8 _decimals,\r\n    uint256 _vaultNumber,\r\n    address _dao,\r\n    address _Game,\r\n    address _controller,\r\n    address _vaultCurrency,\r\n    uint256 _uScale,\r\n    uint256 _gasFeeLiquidity\r\n  )\r\n    MainVault(\r\n      _name,\r\n      _symbol,\r\n      _decimals,\r\n      _vaultNumber,\r\n      _dao,\r\n      _Game,\r\n      _controller,\r\n      _vaultCurrency,\r\n      _uScale,\r\n      _gasFeeLiquidity\r\n    )\r\n  {}\r\n\r\n  function getAllocationTEST(uint256 _protocolNum) external view returns (int256) {\r\n    return currentAllocations[_protocolNum];\r\n  }\r\n\r\n  function getDeltaAllocationTEST(uint256 _protocolNum) external view returns (int256) {\r\n    return deltaAllocations[_protocolNum];\r\n  }\r\n\r\n  function setDeltaAllocations(uint256 _protocolNum, int256 _allocation) external {\r\n    return setDeltaAllocationsInt(_protocolNum, _allocation);\r\n  }\r\n\r\n  function setDeltaAllocationsReceivedTEST(bool _state) external {\r\n    deltaAllocationsReceived = _state;\r\n  }\r\n\r\n  function setTotalAllocatedTokensTest(int256 _tokens) external {\r\n    totalAllocatedTokens = _tokens;\r\n  }\r\n\r\n  function setAmountToSendXChainTEST(uint256 _amount) external {\r\n    amountToSendXChain = _amount;\r\n  }\r\n\r\n  function getLastPriceTEST(uint256 _protocolId) external view returns (uint256) {\r\n    return lastPrices[_protocolId];\r\n  }\r\n\r\n  function balanceSharesTEST(uint256 _protocolNum, address _address)\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    IController.ProtocolInfoS memory p = controller.getProtocolInfo(vaultNumber, _protocolNum);\r\n    uint256 balance = IProvider(p.provider).balance(_address, p.LPToken);\r\n\r\n    return balance;\r\n  }\r\n\r\n  function getWithdrawalAllowanceTEST(address _address) external view returns (uint256) {\r\n    return withdrawalAllowance[_address];\r\n  }\r\n\r\n  function getRewardAllowanceTEST(address _address) external view returns (uint256) {\r\n    return rewardAllowance[_address];\r\n  }\r\n\r\n  function getTotalWithdrawalRequestsTEST() external view returns (uint256) {\r\n    return totalWithdrawalRequests;\r\n  }\r\n\r\n  function getReservedFundsTEST() external view returns (uint256) {\r\n    return reservedFunds;\r\n  }\r\n\r\n  function setExchangeRateTEST(uint256 _exchangeRate) external {\r\n    exchangeRate = _exchangeRate;\r\n  }\r\n\r\n  function setReservedFundsTEST(uint256 _amount) external {\r\n    reservedFunds = _amount;\r\n  }\r\n\r\n  function upRebalancingPeriodTEST() external {\r\n    rebalancingPeriod++;\r\n  }\r\n\r\n  function setCurrentAllocation(uint256 _protocolNum, int256 _allocation) external {\r\n    currentAllocations[_protocolNum] = _allocation;\r\n  }\r\n\r\n  function resetDeltaAllocations(uint256 _protocolNum) external {\r\n    deltaAllocations[_protocolNum] = 0;\r\n  }\r\n\r\n  function clearCurrencyBalance(uint256 _balance) external {\r\n    vaultCurrency.transfer(getDao(), _balance);\r\n  }\r\n\r\n  function toggleVaultOnOffTEST(bool _state) external {\r\n    vaultOff = _state;\r\n  }\r\n\r\n  function swapTokensMultiTest(\r\n    uint256 _amount,\r\n    address _tokenIn,\r\n    address _tokenOut\r\n  ) external returns (uint256) {\r\n    return\r\n      Swap.swapTokensMulti(\r\n        Swap.SwapInOut(_amount, _tokenIn, _tokenOut),\r\n        controller.getUniswapParams()\r\n      );\r\n  }\r\n\r\n  function swapMinAmountOutMultiTest(\r\n    uint256 _amount,\r\n    address _tokenIn,\r\n    address _tokenOut\r\n  ) external {\r\n    uint256 minAmountOut = Swap.amountOutMultiSwap(\r\n      Swap.SwapInOut(_amount, _tokenIn, _tokenOut),\r\n      controller.getUniswapQuoter(),\r\n      controller.getUniswapPoolFee()\r\n    );\r\n\r\n    emit MinAmountOut(minAmountOut);\r\n  }\r\n\r\n  function curveSwapTest(\r\n    uint256 _amount,\r\n    address _tokenIn,\r\n    address _tokenOut\r\n  ) external {\r\n    Swap.swapStableCoins(\r\n      Swap.SwapInOut(_amount, _tokenIn, _tokenOut),\r\n      uScale,\r\n      1000000000000000000,\r\n      controller.getCurveParams(_tokenIn, _tokenOut)\r\n    );\r\n  }\r\n\r\n  function testLargeGameplayerSet(uint256 _amountOfPlayers) public {\r\n    for (uint256 i = 0; i < _amountOfPlayers; i++) {\r\n      players[i] = exchangeRate;\r\n    }\r\n  }\r\n\r\n  function setVaultState(uint256 _state) external {\r\n    if (_state == 0) state = State.Idle;\r\n    if (_state == 1) state = State.SendingFundsXChain;\r\n    if (_state == 2) state = State.WaitingForFunds;\r\n    if (_state == 3) state = State.RebalanceVault;\r\n  }\r\n\r\n  // function testFormulaWithNRoot(uint256 _g, uint256 _n) public view returns(int128) {\r\n  //   int128 g_casted = ABDKMath64x64.fromUInt(_g);\r\n  //   int128 n_casted = ABDKMath64x64.fromUInt(_n);\r\n  //   int128 log2 = ABDKMath64x64.log_2(g_casted);\r\n  //   int128 endResult = ABDKMath64x64.exp_2(log2 / n_casted);\r\n  //   return endResult;\r\n  // }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 5
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}