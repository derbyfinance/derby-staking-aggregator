{
  "language": "Solidity",
  "sources": {
    "contracts/Controller.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"./Interfaces/IProvider.sol\";\r\nimport \"./Interfaces/IController.sol\";\r\nimport \"./Interfaces/ExternalInterfaces/IChainlinkGasPrice.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract Controller is IController {\r\n  UniswapParams public uniswapParams;\r\n\r\n  address private dao;\r\n  address public curve3Pool;\r\n  address public chainlinkGasPriceOracle;\r\n\r\n  uint256 public curve3PoolFee = 15; // 0.15% including slippage\r\n\r\n  // (vaultNumber => protocolNumber => protocolInfoStruct): struct in IController\r\n  mapping(uint256 => mapping(uint256 => ProtocolInfoS)) public protocolInfo;\r\n  // (vaultNumber => protocolNumber => protocolName): name of underlying protocol vaults\r\n  mapping(uint256 => mapping(uint256 => string)) public protocolNames;\r\n\r\n  // (vaultAddress => bool): true when address is whitelisted\r\n  mapping(address => bool) public vaultWhitelist;\r\n  // (vaultAddress => bool): true when protocol has claimable tokens / extra rewards\r\n  mapping(address => bool) public claimable;\r\n\r\n  // (vaultNumber => protocolNumber => bool): true when protocol is blacklisted\r\n  mapping(uint256 => mapping(uint256 => bool)) public protocolBlacklist;\r\n  // (vaultNumber => protocolNumber => address): address of the governance token\r\n  mapping(uint256 => mapping(uint256 => address)) public protocolGovToken;\r\n  // (vaultNumber => latestProtocolId)\r\n  mapping(uint256 => uint256) public latestProtocolId;\r\n\r\n  // (stableCoinAddress => curveIndex): curve index for stable coins\r\n  mapping(address => int128) public curveIndex;\r\n  // (stableCoinAddress => uScale): uScale for vault currency coins (i.e. stables) used for swapping\r\n  mapping(address => uint256) public underlyingUScale; // index is address of vaultcurrency erc20 contract\r\n\r\n  event SetProtocolNumber(uint256 protocolNumber, address protocol);\r\n\r\n  constructor(\r\n    address _dao,\r\n    address _curve3Pool,\r\n    address _uniswapRouter,\r\n    address _uniswapQuoter,\r\n    uint24 _poolFee,\r\n    address _chainlinkGasPriceOracle\r\n  ) {\r\n    dao = _dao;\r\n    curve3Pool = _curve3Pool;\r\n    uniswapParams.router = _uniswapRouter;\r\n    uniswapParams.quoter = _uniswapQuoter;\r\n    uniswapParams.poolFee = _poolFee;\r\n    chainlinkGasPriceOracle = _chainlinkGasPriceOracle;\r\n    underlyingUScale[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = 1E6; // USDC\r\n    underlyingUScale[0x6B175474E89094C44Da98b954EedeAC495271d0F] = 1E18; // DAI\r\n    underlyingUScale[0xdAC17F958D2ee523a2206206994597C13D831ec7] = 1E6; // USDT\r\n  }\r\n\r\n  // Modifier for only vault?\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"Controller: only DAO\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyVault() {\r\n    require(vaultWhitelist[msg.sender] == true, \"Controller: only Vault\");\r\n    _;\r\n  }\r\n\r\n  /// @notice Harvest tokens from underlying protocols\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _protocolNumber Protocol number linked to protocol vault\r\n  function claim(uint256 _vaultNumber, uint256 _protocolNumber)\r\n    external\r\n    override\r\n    onlyVault\r\n    returns (bool)\r\n  {\r\n    if (claimable[protocolInfo[_vaultNumber][_protocolNumber].provider]) {\r\n      return\r\n        IProvider(protocolInfo[_vaultNumber][_protocolNumber].provider).claim(\r\n          protocolInfo[_vaultNumber][_protocolNumber].LPToken,\r\n          msg.sender\r\n        );\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /// @notice Set if provider have claimable tokens\r\n  /// @param _provider Address of the underlying protocol\r\n  /// @param _bool True of the underlying protocol has claimable tokens\r\n  function setClaimable(address _provider, bool _bool) external onlyDao {\r\n    claimable[_provider] = _bool;\r\n  }\r\n\r\n  function getUniswapParams() external view returns (UniswapParams memory) {\r\n    return uniswapParams;\r\n  }\r\n\r\n  function getUniswapPoolFee() external view returns (uint24) {\r\n    return uniswapParams.poolFee;\r\n  }\r\n\r\n  function getUniswapQuoter() external view returns (address) {\r\n    return uniswapParams.quoter;\r\n  }\r\n\r\n  function getCurveParams(address _in, address _out) external view returns (CurveParams memory) {\r\n    CurveParams memory curveParams;\r\n    curveParams.indexTokenIn = curveIndex[_in];\r\n    curveParams.indexTokenOut = curveIndex[_out];\r\n    curveParams.pool = curve3Pool;\r\n    curveParams.poolFee = curve3PoolFee;\r\n\r\n    return curveParams;\r\n  }\r\n\r\n  /// @notice Getter for protocol blacklist, given an vaultnumber and protocol number returns true if blacklisted. Can only be called by vault.\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _protocolNum Protocol number linked to protocol vault\r\n  function getProtocolBlacklist(uint256 _vaultNumber, uint256 _protocolNum)\r\n    external\r\n    view\r\n    override\r\n    onlyVault\r\n    returns (bool)\r\n  {\r\n    return protocolBlacklist[_vaultNumber][_protocolNum];\r\n  }\r\n\r\n  /// @notice Getter for the ProtocolInfo struct\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _protocolNum Protocol number linked to protocol vault\r\n  function getProtocolInfo(uint256 _vaultNumber, uint256 _protocolNum)\r\n    external\r\n    view\r\n    override\r\n    returns (ProtocolInfoS memory)\r\n  {\r\n    return protocolInfo[_vaultNumber][_protocolNum];\r\n  }\r\n\r\n  /// @notice Setter for protocol blacklist, given an vaultnumber and protocol number puts the protocol on the blacklist. Can only be called by vault.\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _protocolNum Protocol number linked to protocol vault\r\n  function setProtocolBlacklist(uint256 _vaultNumber, uint256 _protocolNum)\r\n    external\r\n    override\r\n    onlyVault\r\n  {\r\n    protocolBlacklist[_vaultNumber][_protocolNum] = true;\r\n  }\r\n\r\n  /// @notice Gets the gas price from Chainlink oracle\r\n  /// @return gasPrice latest gas price from oracle\r\n  function getGasPrice() external override returns (uint256) {\r\n    return IChainlinkGasPrice(chainlinkGasPriceOracle).latestAnswer();\r\n  }\r\n\r\n  /// @notice Gets the gas price from Chainlink oracle\r\n  /// @return gasPrice latest gas price from oracle\r\n  function getGovToken(uint256 _vaultNumber, uint256 _protocolNum) external view returns (address) {\r\n    return protocolGovToken[_vaultNumber][_protocolNum];\r\n  }\r\n\r\n  /// @notice Getter for dao address\r\n  function getDao() public view returns (address) {\r\n    return dao;\r\n  }\r\n\r\n  /*\r\n  Only Dao functions\r\n  */\r\n\r\n  /// @notice Add protocol and vault to Controller\r\n  /// @param _name Name of the protocol vault combination\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _provider Address of the protocol provider\r\n  /// @param _protocolLPToken Address of protocolToken eg cUSDC\r\n  /// @param _underlying Address of underlying protocol vault eg USDC\r\n  /// @param _govToken Address governance token of the protocol\r\n  function addProtocol(\r\n    string calldata _name,\r\n    uint256 _vaultNumber,\r\n    address _provider,\r\n    address _protocolLPToken,\r\n    address _underlying,\r\n    address _govToken,\r\n    uint256 _uScale\r\n  ) external onlyDao returns (uint256) {\r\n    uint256 protocolNumber = latestProtocolId[_vaultNumber];\r\n\r\n    protocolNames[_vaultNumber][protocolNumber] = _name;\r\n    protocolGovToken[_vaultNumber][protocolNumber] = _govToken;\r\n    protocolInfo[_vaultNumber][protocolNumber] = ProtocolInfoS(\r\n      _protocolLPToken,\r\n      _provider,\r\n      _underlying,\r\n      _uScale\r\n    );\r\n\r\n    emit SetProtocolNumber(protocolNumber, _protocolLPToken);\r\n\r\n    latestProtocolId[_vaultNumber]++;\r\n\r\n    return protocolNumber;\r\n  }\r\n\r\n  /// @notice Add protocol and vault to Controller\r\n  /// @param _vault Vault address to whitelist\r\n  function addVault(address _vault) external onlyDao {\r\n    vaultWhitelist[_vault] = true;\r\n  }\r\n\r\n  /// @notice Set the Uniswap Router address\r\n  /// @param _uniswapRouter New Uniswap Router address\r\n  function setUniswapRouter(address _uniswapRouter) external onlyDao {\r\n    uniswapParams.router = _uniswapRouter;\r\n  }\r\n\r\n  /// @notice Set the Uniswap Factory address\r\n  /// @param _uniswapQuoter New Uniswap Quoter address\r\n  function setUniswapQuoter(address _uniswapQuoter) external onlyDao {\r\n    uniswapParams.quoter = _uniswapQuoter;\r\n  }\r\n\r\n  /// @notice Set the Uniswap Pool fee\r\n  /// @param _poolFee New Pool fee\r\n  function setUniswapPoolFee(uint24 _poolFee) external onlyDao {\r\n    uniswapParams.poolFee = _poolFee;\r\n  }\r\n\r\n  /// @notice Set the Curve3Pool fee\r\n  /// @param _poolFee New Pool fee\r\n  function setCurvePoolFee(uint24 _poolFee) external onlyDao {\r\n    curve3PoolFee = _poolFee;\r\n  }\r\n\r\n  /// @notice Set curve pool index for underlying token\r\n  /// @param _token Address of Token\r\n  /// @param _index Curve index as decribed in Swap pool\r\n  function addCurveIndex(address _token, int128 _index) external onlyDao {\r\n    curveIndex[_token] = _index;\r\n  }\r\n\r\n  function addUnderlyingUScale(address _stable, uint256 _uScale) external onlyDao {\r\n    underlyingUScale[_stable] = _uScale;\r\n  }\r\n\r\n  /// @notice Setter for the Chainlink Gas price oracle contract address in case it changes\r\n  /// @param _chainlinkGasPriceOracle Contract address\r\n  function setGasPriceOracle(address _chainlinkGasPriceOracle) external override onlyDao {\r\n    chainlinkGasPriceOracle = _chainlinkGasPriceOracle;\r\n  }\r\n\r\n  /// @notice Setter for DAO address\r\n  /// @param _dao DAO address\r\n  function setDao(address _dao) external onlyDao {\r\n    dao = _dao;\r\n  }\r\n}\r\n"
    },
    "contracts/Interfaces/IProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\ninterface IProvider {\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _uToken,\r\n    address _protocolLPToken\r\n  ) external returns (uint256);\r\n\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _uToken,\r\n    address _protocolLPToken\r\n  ) external returns (uint256);\r\n\r\n  function exchangeRate(address _protocolLPToken) external view returns (uint256);\r\n\r\n  function balanceUnderlying(address _address, address _protocolLPToken)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function calcShares(uint256 _amount, address _protocolLPToken) external view returns (uint256);\r\n\r\n  function balance(address _address, address _protocolLPToken) external view returns (uint256);\r\n\r\n  function claim(address _protocolLPToken, address _claimer) external returns (bool);\r\n}\r\n"
    },
    "contracts/Interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\ninterface IController {\r\n  struct ProtocolInfoS {\r\n    address LPToken;\r\n    address provider;\r\n    address underlying; // address of underlying token of the protocol eg USDC\r\n    uint256 uScale; // uScale of protocol LP Token\r\n  }\r\n\r\n  struct UniswapParams {\r\n    address router;\r\n    address quoter;\r\n    uint24 poolFee;\r\n  }\r\n\r\n  struct CurveParams {\r\n    int128 indexTokenIn;\r\n    int128 indexTokenOut;\r\n    address pool;\r\n    uint256 poolFee;\r\n  }\r\n\r\n  function claim(uint256 _ETFnumber, uint256 protocolNumber) external returns (bool);\r\n\r\n  function addProtocol(\r\n    string calldata name,\r\n    uint256 _ETFnumber,\r\n    address provider,\r\n    address protocolLPToken,\r\n    address underlying,\r\n    address govToken,\r\n    uint256 _uScale\r\n  ) external returns (uint256);\r\n\r\n  function curve3Pool() external view returns (address);\r\n\r\n  function curve3PoolFee() external view returns (uint256);\r\n\r\n  function curveIndex(address _token) external view returns (int128);\r\n\r\n  function getProtocolInfo(uint256 _ETFnumber, uint256 protocolNumber)\r\n    external\r\n    view\r\n    returns (ProtocolInfoS memory);\r\n\r\n  function getUniswapParams() external view returns (UniswapParams memory);\r\n\r\n  function getCurveParams(address _in, address _out) external view returns (CurveParams memory);\r\n\r\n  function latestProtocolId(uint256 _ETFnumber) external view returns (uint256);\r\n\r\n  function addVault(address _vault) external;\r\n\r\n  function addCurveIndex(address _token, int128 _index) external;\r\n\r\n  function underlyingUScale(address _token) external view returns (uint256);\r\n\r\n  function setUniswapRouter(address _uniswapRouter) external;\r\n\r\n  function setUniswapQuoter(address _uniswapQuoter) external;\r\n\r\n  function setUniswapPoolFee(uint24 _poolFee) external;\r\n\r\n  function getUniswapPoolFee() external view returns (uint24);\r\n\r\n  function getUniswapQuoter() external view returns (address);\r\n\r\n  function getProtocolBlacklist(uint256 _ETFnumber, uint256 _protocolNum)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  function setProtocolBlacklist(uint256 _ETFnumber, uint256 _protocolNum) external;\r\n\r\n  function getGasPrice() external returns (uint256);\r\n\r\n  function setGasPriceOracle(address _chainlinkGasPriceOracle) external;\r\n\r\n  function getGovToken(uint256 _vaultNumber, uint256 _protocolNum) external view returns (address);\r\n\r\n  function getDao() external view returns (address);\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IChainlinkGasPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IChainlinkGasPrice {\r\n  function latestAnswer() external returns (uint256);\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/XProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport {XCallArgs, CallParams} from \"./libraries/LibConnextStorage.sol\";\r\n\r\nimport \"./Interfaces/IVault.sol\";\r\nimport \"./Interfaces/IXChainController.sol\";\r\nimport \"./Interfaces/IGame.sol\";\r\nimport \"./Mocks/LayerZero/interfaces/ILayerZeroEndpoint.sol\";\r\nimport \"./Mocks/LayerZero/interfaces/ILayerZeroReceiver.sol\";\r\nimport \"./Interfaces/ExternalInterfaces/IConnextHandler.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract XProvider is ILayerZeroReceiver {\r\n  using SafeERC20 for IERC20;\r\n\r\n  ILayerZeroEndpoint public immutable endpoint;\r\n  IConnextHandler public immutable connext;\r\n\r\n  address private dao;\r\n  address public xController;\r\n  address public xControllerProvider;\r\n  address public game;\r\n\r\n  uint16 public homeChain;\r\n  uint16 public xControllerChain;\r\n  uint16 public gameChain;\r\n\r\n  // (layerZeroChainId => connextChainId): layerZeroChainId is the main ID we use\r\n  mapping(uint16 => uint32) public connextChainId;\r\n  // (layerZeroChainId => trustedChainIds): used for whitelisting chains\r\n  mapping(uint16 => bytes) public trustedRemoteLookup;\r\n  // (vaultAddress => bool): used for whitelisting vaults\r\n  mapping(address => bool) public vaultWhitelist;\r\n\r\n  event SetTrustedRemote(uint16 _srcChainId, bytes _srcAddress);\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"LZProvider: only DAO\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyController() {\r\n    require(msg.sender == xController, \"LZProvider: only Controller\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyVaults() {\r\n    require(vaultWhitelist[msg.sender], \"LZProvider: only vault\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGame() {\r\n    require(msg.sender == game, \"LZProvider: only Game\");\r\n    _;\r\n  }\r\n\r\n  /// @notice Solution for the low-level call in lzReceive that is seen as an external call\r\n  modifier onlySelf() {\r\n    require(msg.sender == address(this), \"LZProvider: only Self\");\r\n    _;\r\n  }\r\n\r\n  modifier onlySelfOrVault() {\r\n    require(\r\n      msg.sender == address(this) || vaultWhitelist[msg.sender],\r\n      \"LZProvider: only Self or Vault\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address _endpoint,\r\n    address _connextHandler,\r\n    address _dao,\r\n    address _game,\r\n    address _xController,\r\n    uint16 _homeChain\r\n  ) {\r\n    endpoint = ILayerZeroEndpoint(_endpoint);\r\n    connext = IConnextHandler(_connextHandler);\r\n    dao = _dao;\r\n    game = _game;\r\n    xController = _xController;\r\n    homeChain = _homeChain;\r\n  }\r\n\r\n  /// @notice Function to send function selectors crossChain\r\n  /// @param _destinationDomain chain Id of destination chain\r\n  /// @param _callData Function selector to call on receiving chain with params\r\n  function xSend(uint16 _destinationDomain, bytes memory _callData) internal {\r\n    bytes memory trustedRemote = trustedRemoteLookup[_destinationDomain]; // same chainID as the provider on the receiverChain\r\n    require(trustedRemote.length != 0, \"LZProvider: destination chain not trusted\");\r\n\r\n    endpoint.send(\r\n      _destinationDomain,\r\n      trustedRemote,\r\n      _callData,\r\n      payable(msg.sender),\r\n      address(0x0),\r\n      bytes(\"\")\r\n    );\r\n  }\r\n\r\n  function xTransfer(\r\n    address _to,\r\n    address _asset,\r\n    uint32 _originDomain,\r\n    uint32 _destinationDomain,\r\n    uint256 _amount\r\n  ) internal {\r\n    require(\r\n      IERC20(_asset).allowance(msg.sender, address(this)) >= _amount,\r\n      \"LZXProvider: Not approved\"\r\n    );\r\n\r\n    IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_asset).approve(address(connext), _amount);\r\n\r\n    CallParams memory callParams = CallParams({\r\n      to: _to,\r\n      callData: \"\",\r\n      originDomain: _originDomain,\r\n      destinationDomain: _destinationDomain,\r\n      agent: _to,\r\n      recovery: _to,\r\n      forceSlow: false,\r\n      receiveLocal: false,\r\n      callback: address(0),\r\n      callbackFee: 0,\r\n      relayerFee: 0,\r\n      slippageTol: 9995\r\n    });\r\n\r\n    XCallArgs memory xcallArgs = XCallArgs({\r\n      params: callParams,\r\n      transactingAssetId: _asset,\r\n      amount: _amount\r\n    });\r\n\r\n    connext.xcall(xcallArgs);\r\n  }\r\n\r\n  function lzReceive(\r\n    uint16 _srcChainId,\r\n    bytes calldata _srcAddress,\r\n    uint64 _nonce,\r\n    bytes calldata _payload\r\n  ) external {\r\n    require(msg.sender == address(endpoint), \"Not an endpoint\");\r\n    require(\r\n      _srcAddress.length == trustedRemoteLookup[_srcChainId].length &&\r\n        keccak256(_srcAddress) == keccak256(trustedRemoteLookup[_srcChainId]),\r\n      \"Not trusted\"\r\n    );\r\n\r\n    (bool success, ) = address(this).call(_payload);\r\n    require(success, \"LZReceive: No success\");\r\n  }\r\n\r\n  /// @notice Step 1 push; Game pushes totalDeltaAllocations to xChainController\r\n  /// @notice Pushes the delta allocations from the game to the xChainController\r\n  /// @param _vaultNumber number of the vault\r\n  /// @param _deltas Array with delta Allocations for all chainIds\r\n  function pushAllocations(uint256 _vaultNumber, int256[] memory _deltas) external onlyGame {\r\n    bytes4 selector = bytes4(keccak256(\"receiveAllocations(uint256,int256[])\"));\r\n    bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber, _deltas);\r\n\r\n    xSend(xControllerChain, callData);\r\n  }\r\n\r\n  /// @notice Step 1 receive; Game pushes totalDeltaAllocations to xChainController\r\n  /// @notice Receives the delta allocations from the game and routes to xChainController\r\n  /// @param _vaultNumber number of the vault\r\n  /// @param _deltas Array with delta Allocations for all chainIds\r\n  function receiveAllocations(uint256 _vaultNumber, int256[] memory _deltas) external onlySelf {\r\n    return IXChainController(xController).receiveAllocationsFromGame(_vaultNumber, _deltas);\r\n  }\r\n\r\n  /// @notice Step 2 push; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\r\n  /// @notice Pushes cross chain requests for the totalUnderlying for a vaultNumber on a chainId\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _underlying TotalUnderling plus vault balance in vaultcurrency e.g USDC\r\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\r\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\r\n  function pushTotalUnderlying(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) external onlyVaults {\r\n    if (_chainId == xControllerChain) {\r\n      return\r\n        IXChainController(xController).setTotalUnderlying(\r\n          _vaultNumber,\r\n          _chainId,\r\n          _underlying,\r\n          _totalSupply,\r\n          _withdrawalRequests\r\n        );\r\n    } else {\r\n      bytes4 selector = bytes4(\r\n        keccak256(\"receiveTotalUnderlying(uint256,uint16,uint256,uint256,uint256)\")\r\n      );\r\n      bytes memory callData = abi.encodeWithSelector(\r\n        selector,\r\n        _vaultNumber,\r\n        _chainId,\r\n        _underlying,\r\n        _totalSupply,\r\n        _withdrawalRequests\r\n      );\r\n\r\n      xSend(xControllerChain, callData);\r\n    }\r\n  }\r\n\r\n  /// @notice Step 2 receive; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\r\n  /// @notice Receive and set totalUnderlyings from the vaults for every chainId\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _underlying TotalUnderling plus vault balance in vaultcurrency e.g USDC\r\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\r\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\r\n  function receiveTotalUnderlying(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) external onlySelf {\r\n    return\r\n      IXChainController(xController).setTotalUnderlying(\r\n        _vaultNumber,\r\n        _chainId,\r\n        _underlying,\r\n        _totalSupply,\r\n        _withdrawalRequests\r\n      );\r\n  }\r\n\r\n  /// @notice Step 3 push; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\r\n  /// @param _vault Address of the Derby Vault on given chainId\r\n  /// @param _chainId Number of chain used\r\n  /// @param _amountToSendBack Amount the vault has to send back\r\n  /// @param _exchangeRate New exchangerate for vaults\r\n  function pushSetXChainAllocation(\r\n    address _vault,\r\n    uint16 _chainId,\r\n    uint256 _amountToSendBack,\r\n    uint256 _exchangeRate\r\n  ) external onlyController {\r\n    if (_chainId == homeChain) {\r\n      return IVault(_vault).setXChainAllocation(_amountToSendBack, _exchangeRate);\r\n    } else {\r\n      bytes4 selector = bytes4(keccak256(\"receiveSetXChainAllocation(address,uint256,uint256)\"));\r\n      bytes memory callData = abi.encodeWithSelector(\r\n        selector,\r\n        _vault,\r\n        _amountToSendBack,\r\n        _exchangeRate\r\n      );\r\n\r\n      xSend(_chainId, callData);\r\n    }\r\n  }\r\n\r\n  /// @notice Step 3 receive; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\r\n  /// @param _vault Address of the Derby Vault on given chainId\r\n  /// @param _amountToSendBack Amount the vault has to send back\r\n  /// @param _exchangeRate New exchangerate for vaults\r\n  function receiveSetXChainAllocation(\r\n    address _vault,\r\n    uint256 _amountToSendBack,\r\n    uint256 _exchangeRate\r\n  ) external onlySelf {\r\n    return IVault(_vault).setXChainAllocation(_amountToSendBack, _exchangeRate);\r\n  }\r\n\r\n  /// @notice Step 4 push; Push funds from vaults to xChainController\r\n  /// @notice Transfers funds from vault to xController for crosschain rebalance\r\n  /// @param _vaultNumber Address of the Derby Vault on given chainId\r\n  /// @param _amount Number of the vault\r\n  /// @param _asset Address of the token to send e.g USDC\r\n  function xTransferToController(\r\n    uint256 _vaultNumber,\r\n    uint256 _amount,\r\n    address _asset\r\n  ) external onlyVaults {\r\n    if (homeChain == xControllerChain) {\r\n      IERC20(_asset).transferFrom(msg.sender, xController, _amount);\r\n      IXChainController(xController).upFundsReceived(_vaultNumber);\r\n    } else {\r\n      xTransfer(\r\n        xController,\r\n        _asset,\r\n        connextChainId[homeChain],\r\n        connextChainId[xControllerChain],\r\n        _amount\r\n      );\r\n      pushFeedbackToXController(_vaultNumber);\r\n    }\r\n  }\r\n\r\n  /// @notice Step 4 push; Push funds from vaults to xChainController\r\n  /// @notice Push crosschain feedback to xController to know when the vaultNumber has sent funds\r\n  /// @param _vaultNumber Number of the vault\r\n  function pushFeedbackToXController(uint256 _vaultNumber) internal {\r\n    bytes4 selector = bytes4(keccak256(\"receiveFeedbackToXController(uint256)\"));\r\n    bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber);\r\n\r\n    xSend(xControllerChain, callData);\r\n  }\r\n\r\n  /// @notice Step 4 receive; Push funds from vaults to xChainController\r\n  /// @notice Receive crosschain feedback to xController to know when the vaultNumber has sent funds\r\n  /// @param _vaultNumber Number of the vault\r\n  function receiveFeedbackToXController(uint256 _vaultNumber) external onlySelf {\r\n    return IXChainController(xController).upFundsReceived(_vaultNumber);\r\n  }\r\n\r\n  /// @notice Step 5 push; Push funds from xChainController to vaults\r\n  /// @notice Transfers funds from xController to vault for crosschain rebalance\r\n  /// @param _chainId Number of chainId\r\n  /// @param _amount Amount to send to vault in vaultcurrency\r\n  /// @param _asset Addres of underlying e.g USDC\r\n  function xTransferToVaults(\r\n    address _vault,\r\n    uint16 _chainId,\r\n    uint256 _amount,\r\n    address _asset\r\n  ) external onlyController {\r\n    xTransfer(_vault, _asset, connextChainId[homeChain], connextChainId[_chainId], _amount);\r\n    pushFeedbackToVault(_chainId, _vault);\r\n  }\r\n\r\n  /// @notice Step 5 push; Push funds from xChainController to vaults\r\n  /// @notice Push feedback message so the vault knows it has received funds and is ready to rebalance\r\n  /// @param _chainId Number of chainId\r\n  /// @param _vault Address of the vault on given chainId\r\n  function pushFeedbackToVault(uint16 _chainId, address _vault) internal {\r\n    bytes4 selector = bytes4(keccak256(\"receiveFeedbackToVault(address)\"));\r\n    bytes memory callData = abi.encodeWithSelector(selector, _vault);\r\n\r\n    xSend(_chainId, callData);\r\n  }\r\n\r\n  /// @notice Step 5 receive; Push funds from xChainController to vaults\r\n  /// @notice Receive feedback message so the vault knows it has received funds and is ready to rebalance\r\n  /// @param _vault Address of the vault on given chainId\r\n  function receiveFeedbackToVault(address _vault) external onlySelfOrVault {\r\n    return IVault(_vault).receiveFunds();\r\n  }\r\n\r\n  /// @notice Step 6 push; Game pushes deltaAllocations to vaults\r\n  /// @notice Push protocol allocation array from the game to all vaults/chains\r\n  /// @param _vault Address of the vault on given chainId\r\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\r\n  function pushProtocolAllocationsToVault(\r\n    uint16 _chainId,\r\n    address _vault,\r\n    int256[] memory _deltas\r\n  ) external onlyGame {\r\n    if (_chainId == homeChain) return IVault(_vault).receiveProtocolAllocations(_deltas);\r\n    else {\r\n      bytes4 selector = bytes4(keccak256(\"receiveProtocolAllocationsToVault(address,int256[])\"));\r\n      bytes memory callData = abi.encodeWithSelector(selector, _vault, _deltas);\r\n\r\n      xSend(_chainId, callData);\r\n    }\r\n  }\r\n\r\n  /// @notice Step 6 receive; Game pushes deltaAllocations to vaults\r\n  /// @notice Receives protocol allocation array from the game to all vaults/chains\r\n  /// @param _vault Address of the vault on given chainId\r\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\r\n  function receiveProtocolAllocationsToVault(address _vault, int256[] memory _deltas)\r\n    external\r\n    onlySelf\r\n  {\r\n    return IVault(_vault).receiveProtocolAllocations(_deltas);\r\n  }\r\n\r\n  /// @notice Step 8 push; Vaults push rewardsPerLockedToken to game\r\n  /// @notice Push price and rewards array from vaults to the game\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\r\n  function pushRewardsToGame(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    int256[] memory _rewards\r\n  ) external onlyVaults {\r\n    if (_chainId == homeChain) {\r\n      return IGame(game).settleRewards(_vaultNumber, _chainId, _rewards);\r\n    } else {\r\n      bytes4 selector = bytes4(keccak256(\"receiveRewardsToGame(uint256,uint16,int256[])\"));\r\n      bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber, _chainId, _rewards);\r\n\r\n      xSend(gameChain, callData);\r\n    }\r\n  }\r\n\r\n  /// @notice Step 8 receive; Vaults push rewardsPerLockedToken to game\r\n  /// @notice Receives price and rewards array from vaults to the game\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\r\n  function receiveRewardsToGame(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    int256[] memory _rewards\r\n  ) external onlySelf {\r\n    return IGame(game).settleRewards(_vaultNumber, _chainId, _rewards);\r\n  }\r\n\r\n  /// @notice Push feedback to the vault if the vault is set to on or off\r\n  /// @param _vault Address of the Derby Vault on given chainId\r\n  /// @param _chainId Number of chain used\r\n  /// @param _state bool for chainId on or off\r\n  function pushStateFeedbackToVault(\r\n    address _vault,\r\n    uint16 _chainId,\r\n    bool _state\r\n  ) external onlyController {\r\n    if (_chainId == homeChain) {\r\n      return IVault(_vault).toggleVaultOnOff(_state);\r\n    } else {\r\n      bytes4 selector = bytes4(keccak256(\"receiveStateFeedbackToVault(address,bool)\"));\r\n      bytes memory callData = abi.encodeWithSelector(selector, _vault, _state);\r\n\r\n      xSend(_chainId, callData);\r\n    }\r\n  }\r\n\r\n  /// @notice Receive feedback for the vault if the vault is set to on or off\r\n  /// @param _vault Address of the Derby Vault on given chainId\r\n  /// @param _state bool for chainId on or off\r\n  function receiveStateFeedbackToVault(address _vault, bool _state) external onlySelf {\r\n    return IVault(_vault).toggleVaultOnOff(_state);\r\n  }\r\n\r\n  /// @notice returns number of decimals for the vault\r\n  function getDecimals(address _vault) external view returns (uint256) {\r\n    return IVault(_vault).decimals();\r\n  }\r\n\r\n  /// @notice Getter for dao address\r\n  function getDao() public view returns (address) {\r\n    return dao;\r\n  }\r\n\r\n  /*\r\n  Only Dao functions\r\n  */\r\n\r\n  /// @notice set trusted provider on remote chains, allow owner to set it multiple times.\r\n  /// @param _srcChainId Chain is for remote xprovider, some as the remote receiving contract chain id (xReceive)\r\n  /// @param _srcAddress Address of remote xprovider\r\n  function setTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external onlyDao {\r\n    trustedRemoteLookup[_srcChainId] = _srcAddress;\r\n    emit SetTrustedRemote(_srcChainId, _srcAddress);\r\n  }\r\n\r\n  /// @notice Setter for xControlleraddress\r\n  /// @param _xController New address of _xController\r\n  function setXController(address _xController) external onlyDao {\r\n    xController = _xController;\r\n  }\r\n\r\n  /// @notice Setter for xControllerProvider address\r\n  /// @param _xControllerProvider New address of xProvider for xController chain\r\n  function setXControllerProvider(address _xControllerProvider) external onlyDao {\r\n    xControllerProvider = _xControllerProvider;\r\n  }\r\n\r\n  /// @notice Setter for xControllerProvider address\r\n  /// @param _xControllerChain New address of xProvider for xController chain\r\n  function setXControllerChainId(uint16 _xControllerChain) external onlyDao {\r\n    xControllerChain = _xControllerChain;\r\n  }\r\n\r\n  /// @notice Setter for homeChain Id\r\n  /// @param _homeChain New home chainId\r\n  function setHomeChain(uint16 _homeChain) external onlyDao {\r\n    homeChain = _homeChain;\r\n  }\r\n\r\n  /// @notice Setter for gameChain Id\r\n  /// @param _gameChain New chainId for game contract\r\n  function setGameChainId(uint16 _gameChain) external onlyDao {\r\n    gameChain = _gameChain;\r\n  }\r\n\r\n  /// @notice links layerZero chain id to a connext chain id for transfers\r\n  function setConnextChainId(uint16 _layerzeroChainId, uint32 _connextChainId) external onlyDao {\r\n    connextChainId[_layerzeroChainId] = _connextChainId;\r\n  }\r\n\r\n  /// @notice Whitelists vault address for onlyVault modifier\r\n  function toggleVaultWhitelist(address _vault) external onlyDao {\r\n    vaultWhitelist[_vault] = !vaultWhitelist[_vault];\r\n  }\r\n\r\n  /// @notice Setter for dao address\r\n  function setDao(address _dao) external onlyDao {\r\n    dao = _dao;\r\n  }\r\n\r\n  /// @notice Setter for new game address\r\n  /// @param _game New address of the game\r\n  function setGame(address _game) external onlyDao {\r\n    game = _game;\r\n  }\r\n}\r\n"
    },
    "contracts/libraries/LibConnextStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\n// ============= Structs =============\r\n\r\n/**\r\n * @notice These are the call parameters that will remain constant between the\r\n * two chains. They are supplied on `xcall` and should be asserted on `execute`\r\n * @property to - The account that receives funds, in the event of a crosschain call,\r\n * will receive funds if the call fails.\r\n * @param to - The address you are sending funds (and potentially data) to\r\n * @param callData - The data to execute on the receiving chain. If no crosschain call is needed, then leave empty.\r\n * @param originDomain - The originating domain (i.e. where `xcall` is called). Must match nomad domain schema\r\n * @param destinationDomain - The final domain (i.e. where `execute` / `reconcile` are called). Must match nomad domain schema\r\n * @param agent - An address who can execute txs on behalf of `to`, in addition to allowing relayers\r\n * @param recovery - The address to send funds to if your `Executor.execute call` fails\r\n * @param callback - The address on the origin domain of the callback contract\r\n * @param callbackFee - The relayer fee to execute the callback\r\n * @param forceSlow - If true, will take slow liquidity path even if it is not a permissioned call\r\n * @param receiveLocal - If true, will use the local nomad asset on the destination instead of adopted.\r\n * @param relayerFee - The amount of relayer fee the tx called xcall with\r\n * @param slippageTol - Max bps of original due to slippage (i.e. would be 9995 to tolerate .05% slippage)\r\n */\r\nstruct CallParams {\r\n  address to;\r\n  bytes callData;\r\n  uint32 originDomain;\r\n  uint32 destinationDomain;\r\n  address agent;\r\n  address recovery;\r\n  bool forceSlow;\r\n  bool receiveLocal;\r\n  address callback;\r\n  uint256 callbackFee;\r\n  uint256 relayerFee;\r\n  uint256 slippageTol;\r\n}\r\n\r\n/**\r\n * @notice The arguments you supply to the `xcall` function called by user on origin domain\r\n * @param params - The CallParams. These are consistent across sending and receiving chains\r\n * @param transactingAssetId - The asset the caller sent with the transfer. Can be the adopted, canonical,\r\n * or the representational asset\r\n * @param amount - The amount of transferring asset the tx called xcall with\r\n */\r\nstruct XCallArgs {\r\n  CallParams params;\r\n  address transactingAssetId; // Could be adopted, local, or wrapped\r\n  uint256 amount;\r\n}\r\n"
    },
    "contracts/Interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\ninterface IVault {\r\n  function swapTokens(uint256 _amountIn, address _tokenIn) external returns (uint256);\r\n\r\n  function rebalancingPeriod() external view returns (uint256);\r\n\r\n  function price(uint256) external view returns (uint256);\r\n\r\n  function setDeltaAllocations(uint256 _protocolNum, int256 _allocation) external;\r\n\r\n  function historicalPrices(uint256 _rebalancingPeriod, uint256 _protocolNum)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function rewardPerLockedToken(uint256 _rebalancingPeriod, uint256 _protocolNum)\r\n    external\r\n    view\r\n    returns (int256);\r\n\r\n  function performanceFee() external view returns (uint256);\r\n\r\n  function getTotalUnderlying() external view returns (uint256);\r\n\r\n  function getTotalUnderlyingIncBalance() external view returns (uint256);\r\n\r\n  function vaultCurrencyAddress() external view returns (address);\r\n\r\n  function setXChainAllocation(uint256 _amountToSend, uint256 _exchangeRate) external;\r\n\r\n  function setVaultState(uint256 _state) external;\r\n\r\n  function receiveFunds() external;\r\n\r\n  function receiveProtocolAllocations(int256[] memory _deltas) external;\r\n\r\n  function toggleVaultOnOff(bool _state) external;\r\n\r\n  function decimals() external view returns (uint256);\r\n\r\n  function redeemRewardsGame(uint256 _amount, address _user) external;\r\n}\r\n"
    },
    "contracts/Interfaces/IXChainController.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\ninterface IXChainController {\r\n  function addTotalChainUnderlying(uint256 _vaultNumber, uint256 _amount) external;\r\n\r\n  function upFundsReceived(uint256 _vaultNumber) external;\r\n\r\n  function receiveAllocationsFromGame(uint256 _vaultNumber, int256[] memory _deltas) external;\r\n\r\n  function setTotalUnderlying(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) external;\r\n}\r\n"
    },
    "contracts/Interfaces/IGame.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\ninterface IGame {\r\n  function Vaults(uint256 _ETFnumber) external view returns (address);\r\n\r\n  function basketUnredeemedRewardsViaVault(uint256 _basketId, address _ownerAddr)\r\n    external\r\n    view\r\n    returns (int256);\r\n\r\n  function basketRedeemedRewards(uint256 _basketId) external view returns (int256);\r\n\r\n  function setUnredeemedToRedeemed(uint256 _basketId, address _ownerAddr) external;\r\n\r\n  function settleRewards(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    int256[] memory rewards\r\n  ) external;\r\n}\r\n"
    },
    "contracts/Mocks/LayerZero/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./ILayerZeroUserApplicationConfig.sol\";\r\n\r\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\r\n  // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\r\n  // @param _dstChainId - the destination chain identifier\r\n  // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\r\n  // @param _payload - a custom bytes payload to send to the destination contract\r\n  // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\r\n  // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\r\n  // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\r\n  function send(\r\n    uint16 _dstChainId,\r\n    bytes calldata _destination,\r\n    bytes calldata _payload,\r\n    address payable _refundAddress,\r\n    address _zroPaymentAddress,\r\n    bytes calldata _adapterParams\r\n  ) external payable;\r\n\r\n  // @notice used by the messaging library to publish verified payload\r\n  // @param _srcChainId - the source chain identifier\r\n  // @param _srcAddress - the source contract (as bytes) at the source chain\r\n  // @param _dstAddress - the address on destination chain\r\n  // @param _nonce - the unbound message ordering nonce\r\n  // @param _gasLimit - the gas limit for external contract execution\r\n  // @param _payload - verified payload to send to the destination contract\r\n  function receivePayload(\r\n    uint16 _srcChainId,\r\n    bytes calldata _srcAddress,\r\n    address _dstAddress,\r\n    uint64 _nonce,\r\n    uint _gasLimit,\r\n    bytes calldata _payload\r\n  ) external;\r\n\r\n  // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\r\n  // @param _srcChainId - the source chain identifier\r\n  // @param _srcAddress - the source chain contract address\r\n  function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress)\r\n    external\r\n    view\r\n    returns (uint64);\r\n\r\n  // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\r\n  // @param _srcAddress - the source chain contract address\r\n  function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\r\n\r\n  // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\r\n  // @param _dstChainId - the destination chain identifier\r\n  // @param _userApplication - the user app address on this EVM chain\r\n  // @param _payload - the custom message to send over LayerZero\r\n  // @param _payInZRO - if false, user app pays the protocol fee in native token\r\n  // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\r\n  function estimateFees(\r\n    uint16 _dstChainId,\r\n    address _userApplication,\r\n    bytes calldata _payload,\r\n    bool _payInZRO,\r\n    bytes calldata _adapterParam\r\n  ) external view returns (uint nativeFee, uint zroFee);\r\n\r\n  // @notice get this Endpoint's immutable source identifier\r\n  function getChainId() external view returns (uint16);\r\n\r\n  // @notice the interface to retry failed message on this Endpoint destination\r\n  // @param _srcChainId - the source chain identifier\r\n  // @param _srcAddress - the source chain contract address\r\n  // @param _payload - the payload to be retried\r\n  function retryPayload(\r\n    uint16 _srcChainId,\r\n    bytes calldata _srcAddress,\r\n    bytes calldata _payload\r\n  ) external;\r\n\r\n  // @notice query if any STORED payload (message blocking) at the endpoint.\r\n  // @param _srcChainId - the source chain identifier\r\n  // @param _srcAddress - the source chain contract address\r\n  function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  // @notice query if the _libraryAddress is valid for sending msgs.\r\n  // @param _userApplication - the user app address on this EVM chain\r\n  function getSendLibraryAddress(address _userApplication) external view returns (address);\r\n\r\n  // @notice query if the _libraryAddress is valid for receiving msgs.\r\n  // @param _userApplication - the user app address on this EVM chain\r\n  function getReceiveLibraryAddress(address _userApplication) external view returns (address);\r\n\r\n  // @notice query if the non-reentrancy guard for send() is on\r\n  // @return true if the guard is on. false otherwise\r\n  function isSendingPayload() external view returns (bool);\r\n\r\n  // @notice query if the non-reentrancy guard for receive() is on\r\n  // @return true if the guard is on. false otherwise\r\n  function isReceivingPayload() external view returns (bool);\r\n\r\n  // @notice get the configuration of the LayerZero messaging library of the specified version\r\n  // @param _version - messaging library version\r\n  // @param _chainId - the chainId for the pending config change\r\n  // @param _userApplication - the contract address of the user application\r\n  // @param _configType - type of configuration. every messaging library has its own convention.\r\n  function getConfig(\r\n    uint16 _version,\r\n    uint16 _chainId,\r\n    address _userApplication,\r\n    uint _configType\r\n  ) external view returns (bytes memory);\r\n\r\n  // @notice get the send() LayerZero messaging library version\r\n  // @param _userApplication - the contract address of the user application\r\n  function getSendVersion(address _userApplication) external view returns (uint16);\r\n\r\n  // @notice get the lzReceive() LayerZero messaging library version\r\n  // @param _userApplication - the contract address of the user application\r\n  function getReceiveVersion(address _userApplication) external view returns (uint16);\r\n}\r\n"
    },
    "contracts/Mocks/LayerZero/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ILayerZeroReceiver {\r\n  // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\r\n  // @param _srcChainId - the source endpoint identifier\r\n  // @param _srcAddress - the source sending contract address from the source chain\r\n  // @param _nonce - the ordered message nonce\r\n  // @param _payload - the signed payload is the UA bytes has encoded to be sent\r\n  function lzReceive(\r\n    uint16 _srcChainId,\r\n    bytes calldata _srcAddress,\r\n    uint64 _nonce,\r\n    bytes calldata _payload\r\n  ) external;\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IConnextHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\nimport {XCallArgs} from \"../../libraries/LibConnextStorage.sol\";\r\n\r\ninterface IConnextHandler {\r\n  function xcall(XCallArgs calldata _args) external payable returns (bytes32);\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/Mocks/LayerZero/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ILayerZeroUserApplicationConfig {\r\n  // @notice set the configuration of the LayerZero messaging library of the specified version\r\n  // @param _version - messaging library version\r\n  // @param _chainId - the chainId for the pending config change\r\n  // @param _configType - type of configuration. every messaging library has its own convention.\r\n  // @param _config - configuration in the bytes. can encode arbitrary content.\r\n  function setConfig(\r\n    uint16 _version,\r\n    uint16 _chainId,\r\n    uint _configType,\r\n    bytes calldata _config\r\n  ) external;\r\n\r\n  // @notice set the send() LayerZero messaging library version to _version\r\n  // @param _version - new messaging library version\r\n  function setSendVersion(uint16 _version) external;\r\n\r\n  // @notice set the lzReceive() LayerZero messaging library version to _version\r\n  // @param _version - new messaging library version\r\n  function setReceiveVersion(uint16 _version) external;\r\n\r\n  // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\r\n  // @param _srcChainId - the chainId of the source chain\r\n  // @param _srcAddress - the contract address of the source contract at the source chain\r\n  function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/XChainController.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"./Interfaces/IXProvider.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract XChainController {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct vaultInfo {\r\n    int256 totalCurrentAllocation;\r\n    uint256 totalUnderlying;\r\n    uint256 totalSupply;\r\n    uint256 totalWithdrawalRequests;\r\n    // (chainId => bool): true == off // false == on\r\n    mapping(uint16 => bool) chainIdOff;\r\n    // (chainId => currentAllocation)\r\n    mapping(uint16 => int256) currentAllocationPerChain;\r\n    // (chainId => totalUnderlying)\r\n    mapping(uint16 => uint256) totalUnderlyingPerChain;\r\n    // (chainId => vaultAddress)\r\n    mapping(uint16 => address) vaultChainAddress;\r\n    // (chainId => underlyingAddress): e.g USDC\r\n    mapping(uint16 => address) vaultUnderlyingAddress;\r\n    // (chainId => totalWithdrawalRequests): total withdrawal requests in LP Token\r\n    mapping(uint16 => uint256) withdrawalRequests;\r\n    // (chainId => amountToDeposit)\r\n    mapping(uint16 => uint256) amountToDepositPerChain;\r\n  }\r\n\r\n  // activeVaults; number of active vaults for vaultNumber, set in XChainRebalance\r\n  // stage 0 Ready; waiting for game to send allocations\r\n  // stage 1 AllocationsReceived; allocations received from game, ready to rebalance XChain and set activeVaults\r\n  // stage 2 UnderlyingReceived; underlyings received from all active vault contracts\r\n  // stage 3 FundsReceived; funds received from all active vault contracts\r\n  struct vaultStages {\r\n    uint256 activeVaults;\r\n    bool ready; // stage 0\r\n    bool allocationsReceived; // stage 1\r\n    uint256 underlyingReceived; // stage 2\r\n    uint256 fundsReceived; // stage 3\r\n  }\r\n\r\n  address private dao;\r\n  address private guardian;\r\n  address public game;\r\n  address public xProviderAddr;\r\n  IXProvider public xProvider;\r\n\r\n  uint16[] public chainIds;\r\n  uint16 public homeChain;\r\n\r\n  // (vaultNumber => vaultInfo struct)\r\n  mapping(uint256 => vaultInfo) internal vaults;\r\n  // (vaultNumber => vaultStages struct)\r\n  mapping(uint256 => vaultStages) public vaultStage;\r\n\r\n  event SendXChainAmount(\r\n    address _vault,\r\n    uint16 _chainId,\r\n    uint256 _amountToSendXChain,\r\n    uint256 _exchangeRate\r\n  );\r\n\r\n  event SentFundsToVault(address _vault, uint16 _chainId, uint256 _amount, address _asset);\r\n\r\n  modifier onlyGame() {\r\n    require(msg.sender == game, \"xController: only Game\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"xController: only DAO\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == guardian, \"xController: only Guardian\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyXProvider() {\r\n    require(msg.sender == address(xProvider), \"xController: only xProviderAddr\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 0\r\n  modifier onlyWhenReady(uint256 _vaultNumber) {\r\n    require(vaultStage[_vaultNumber].ready, \"Not all vaults are ready\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 1\r\n  modifier onlyWhenAllocationsReceived(uint256 _vaultNumber) {\r\n    require(vaultStage[_vaultNumber].allocationsReceived, \"Allocations not received from game\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 2\r\n  modifier onlyWhenUnderlyingsReceived(uint256 _vaultNumber) {\r\n    require(\r\n      vaultStage[_vaultNumber].underlyingReceived == vaultStage[_vaultNumber].activeVaults,\r\n      \"Not all underlyings received\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  // vaultStage 3\r\n  modifier onlyWhenFundsReceived(uint256 _vaultNumber) {\r\n    require(\r\n      vaultStage[_vaultNumber].fundsReceived == vaultStage[_vaultNumber].activeVaults,\r\n      \"Not all funds received\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address _game,\r\n    address _dao,\r\n    address _guardian,\r\n    uint16 _homeChain\r\n  ) {\r\n    game = _game;\r\n    dao = _dao;\r\n    guardian = _guardian;\r\n    homeChain = _homeChain;\r\n  }\r\n\r\n  /// @notice Setter for number of active vaults for vaultNumber, set in xChainRebalance\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _activeVaults Number active vaults, calculated in xChainRebalance\r\n  function setActiveVaults(uint256 _vaultNumber, uint256 _activeVaults) internal {\r\n    vaultStage[_vaultNumber].activeVaults = _activeVaults;\r\n  }\r\n\r\n  /// @notice Setter for stage 0:\r\n  /// @notice Ready; waiting for game to send allocations\r\n  function setReady(uint256 _vaultNumber, bool _state) internal {\r\n    vaultStage[_vaultNumber].ready = _state;\r\n  }\r\n\r\n  /// @notice Setter for stage 1:\r\n  /// @notice AllocationsReceived; allocations received from game, ready to rebalance XChain and set activeVaults\r\n  function setAllocationsReceived(uint256 _vaultNumber, bool _state)\r\n    internal\r\n    onlyWhenReady(_vaultNumber)\r\n  {\r\n    vaultStage[_vaultNumber].allocationsReceived = _state;\r\n  }\r\n\r\n  /// @notice Setter to tick up stage 2:\r\n  /// @notice UnderlyingReceived; underlyings received from all active vault contracts\r\n  function upUnderlyingReceived(uint256 _vaultNumber)\r\n    internal\r\n    onlyWhenAllocationsReceived(_vaultNumber)\r\n  {\r\n    vaultStage[_vaultNumber].underlyingReceived++;\r\n  }\r\n\r\n  /// @notice Step 4 end; Push funds from vaults to xChainController\r\n  /// @notice FundsReceived; funds received from all active vault contracts\r\n  function upFundsReceived(uint256 _vaultNumber)\r\n    external\r\n    onlyXProvider\r\n    onlyWhenUnderlyingsReceived(_vaultNumber)\r\n  {\r\n    vaultStage[_vaultNumber].fundsReceived++;\r\n  }\r\n\r\n  /// @notice Resets all stages in vaultStage struct for a vaultNumber\r\n  function resetVaultStages(uint256 _vaultNumber) internal {\r\n    vaultStage[_vaultNumber].ready = true;\r\n    vaultStage[_vaultNumber].allocationsReceived = false;\r\n    vaultStage[_vaultNumber].underlyingReceived = 0;\r\n    vaultStage[_vaultNumber].fundsReceived = 0;\r\n  }\r\n\r\n  /// @notice Resets underlying for a vaultNumber at the start of a rebalancing period\r\n  function resetVaultUnderlying(uint256 _vaultNumber) internal {\r\n    vaults[_vaultNumber].totalUnderlying = 0;\r\n    vaultStage[_vaultNumber].underlyingReceived = 0;\r\n  }\r\n\r\n  /// @notice Resets underlying for a vaultNumber per chainId at the start of a rebalancing period\r\n  function resetVaultUnderlyingForChain(uint256 _vaultNumber, uint16 _chainId) internal {\r\n    vaults[_vaultNumber].totalUnderlyingPerChain[_chainId] = 0;\r\n  }\r\n\r\n  /// @notice Step 1 end; Game pushes totalDeltaAllocations to xChainController\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function receiveAllocationsFromGame(uint256 _vaultNumber, int256[] memory _deltas)\r\n    external\r\n    onlyXProvider\r\n    onlyWhenReady(_vaultNumber)\r\n  {\r\n    return receiveAllocationsFromGameInt(_vaultNumber, _deltas);\r\n  }\r\n\r\n  /// @notice Step 1 end; Game pushes totalDeltaAllocations to xChainController\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function receiveAllocationsFromGameInt(uint256 _vaultNumber, int256[] memory _deltas) internal {\r\n    uint256 activeVaults;\r\n\r\n    for (uint256 i = 0; i < chainIds.length; i++) {\r\n      uint16 chain = chainIds[i];\r\n      activeVaults += settleCurrentAllocation(_vaultNumber, chain, _deltas[i]);\r\n      resetVaultUnderlyingForChain(_vaultNumber, chain);\r\n    }\r\n\r\n    resetVaultUnderlying(_vaultNumber);\r\n    setActiveVaults(_vaultNumber, activeVaults);\r\n    setAllocationsReceived(_vaultNumber, true);\r\n    setReady(_vaultNumber, false);\r\n  }\r\n\r\n  /// @notice Helper to settle the total current allocation with the delta allocations received from Game\r\n  /// @notice Will set a chainId on/off depending on the currentAllocation and incoming deltaAllocation\r\n  /// @dev if currentAllocation = 0 and deltaAllocation = 0, chainId will be set to Off and feedback will be send to vault\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function settleCurrentAllocation(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    int256 _deltas\r\n  ) internal returns (uint256 activeVault) {\r\n    if (getCurrentAllocation(_vaultNumber, _chainId) == 0 && _deltas == 0) {\r\n      sendFeedbackToVault(_vaultNumber, _chainId, true);\r\n      activeVault = 0;\r\n    } else {\r\n      sendFeedbackToVault(_vaultNumber, _chainId, false);\r\n      activeVault = 1;\r\n    }\r\n\r\n    vaults[_vaultNumber].totalCurrentAllocation += _deltas;\r\n    vaults[_vaultNumber].currentAllocationPerChain[_chainId] += _deltas;\r\n\r\n    require(vaults[_vaultNumber].totalCurrentAllocation >= 0, \"Allocation underflow\");\r\n  }\r\n\r\n  /// @notice Will send feedback to the vault if it is turned on or off by settleCurrentAllocation\r\n  /// @param _state Bool if vault is turned on or off\r\n  function sendFeedbackToVault(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    bool _state\r\n  ) internal {\r\n    if (getVaultChainIdOff(_vaultNumber, _chainId) != _state) {\r\n      xProvider.pushStateFeedbackToVault(getVaultAddress(_vaultNumber, _chainId), _chainId, _state);\r\n\r\n      vaults[_vaultNumber].chainIdOff[_chainId] = _state;\r\n    }\r\n  }\r\n\r\n  /// @notice See setTotalUnderlyingInt below\r\n  function setTotalUnderlying(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) external onlyXProvider onlyWhenAllocationsReceived(_vaultNumber) {\r\n    require(getTotalUnderlyingOnChain(_vaultNumber, _chainId) == 0, \"TotalUnderlying already set\");\r\n    setTotalUnderlyingInt(_vaultNumber, _chainId, _underlying, _totalSupply, _withdrawalRequests);\r\n  }\r\n\r\n  /// @notice Step 2 end; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\r\n  /// @notice Receive and set totalUnderlyings from the vaults for every chainId\r\n  /// @param _vaultNumber number of the vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _underlying totalUnderling plus vault balance in vaultcurrency e.g USDC\r\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\r\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\r\n  function setTotalUnderlyingInt(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) internal {\r\n    vaults[_vaultNumber].totalUnderlyingPerChain[_chainId] = _underlying;\r\n    vaults[_vaultNumber].withdrawalRequests[_chainId] = _withdrawalRequests;\r\n    vaults[_vaultNumber].totalSupply += _totalSupply;\r\n    vaults[_vaultNumber].totalUnderlying += _underlying;\r\n    vaults[_vaultNumber].totalWithdrawalRequests += _withdrawalRequests;\r\n    vaultStage[_vaultNumber].underlyingReceived++;\r\n  }\r\n\r\n  /// @notice Step 3 trigger; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\r\n  /// @notice Calculates the amounts the vaults on each chainId have to send or receive\r\n  /// @param _vaultNumber Number of vault\r\n  function pushVaultAmounts(uint256 _vaultNumber)\r\n    external\r\n    onlyWhenUnderlyingsReceived(_vaultNumber)\r\n  {\r\n    int256 totalAllocation = getCurrentTotalAllocation(_vaultNumber);\r\n    uint256 totalWithdrawalRequests = getTotalWithdrawalRequests(_vaultNumber);\r\n    uint256 totalUnderlying = getTotalUnderlyingVault(_vaultNumber) - totalWithdrawalRequests;\r\n    uint256 totalSupply = getTotalSupply(_vaultNumber);\r\n\r\n    uint256 decimals = xProvider.getDecimals(getVaultAddress(_vaultNumber, homeChain));\r\n    uint256 newExchangeRate = (totalUnderlying * (10**decimals)) / totalSupply;\r\n\r\n    for (uint i = 0; i < chainIds.length; i++) {\r\n      uint16 chain = chainIds[i];\r\n      if (getVaultChainIdOff(_vaultNumber, chain)) continue;\r\n\r\n      int256 amountToChain = calcAmountToChain(\r\n        _vaultNumber,\r\n        chain,\r\n        totalUnderlying,\r\n        totalAllocation\r\n      );\r\n      (int256 amountToDeposit, uint256 amountToWithdraw) = calcDepositWithdraw(\r\n        _vaultNumber,\r\n        chain,\r\n        amountToChain\r\n      );\r\n\r\n      sendXChainAmount(_vaultNumber, chain, amountToDeposit, amountToWithdraw, newExchangeRate);\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates the amounts the vaults on each chainId have to send or receive\r\n  /// @param _vaultNumber number of the vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _amountToChain Amount in vaultcurrency that should be on given chainId\r\n  function calcDepositWithdraw(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    int256 _amountToChain\r\n  ) internal view returns (int256, uint256) {\r\n    uint256 currentUnderlying = getTotalUnderlyingOnChain(_vaultNumber, _chainId);\r\n\r\n    int256 amountToDeposit = _amountToChain - int256(currentUnderlying);\r\n    uint256 amountToWithdraw = amountToDeposit < 0\r\n      ? currentUnderlying - uint256(_amountToChain)\r\n      : 0;\r\n\r\n    return (amountToDeposit, amountToWithdraw);\r\n  }\r\n\r\n  /// @notice Calculates the amounts the vaults has to send back to the xChainController\r\n  /// @param _totalUnderlying Total underlying on all chains for given vaultNumber\r\n  /// @param _totalAllocation Total allocation on all chains for given vaultNumber\r\n  function calcAmountToChain(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _totalUnderlying,\r\n    int256 _totalAllocation\r\n  ) internal view returns (int256) {\r\n    int256 allocation = getCurrentAllocation(_vaultNumber, _chainId);\r\n    uint256 withdrawalRequests = getWithdrawalRequests(_vaultNumber, _chainId);\r\n\r\n    int256 amountToChain = (int(_totalUnderlying) * allocation) / _totalAllocation;\r\n    amountToChain += int(withdrawalRequests);\r\n\r\n    return amountToChain;\r\n  }\r\n\r\n  /// @notice Sends out cross-chain messages to vaults with the amount the vault has to send back\r\n  /// @dev if the xChainController needs to deposit, the amount will be 0 so the vault knows it will receive currency\r\n  /// @param _amountDeposit Amount the vault will receive from the xChainController\r\n  /// @param _amountToWithdraw Amount the vault will have to send back to the xChainController\r\n  /// @param _exchangeRate New exchangerate for vaults\r\n  function sendXChainAmount(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    int256 _amountDeposit,\r\n    uint256 _amountToWithdraw,\r\n    uint256 _exchangeRate\r\n  ) internal {\r\n    address vault = getVaultAddress(_vaultNumber, _chainId);\r\n\r\n    if (_amountDeposit > 0) {\r\n      setAmountToDeposit(_vaultNumber, _chainId, _amountDeposit);\r\n      xProvider.pushSetXChainAllocation(vault, _chainId, 0, _exchangeRate);\r\n      vaultStage[_vaultNumber].fundsReceived++;\r\n      emit SendXChainAmount(vault, _chainId, 0, _exchangeRate);\r\n    }\r\n\r\n    if (_amountToWithdraw > 0) {\r\n      xProvider.pushSetXChainAllocation(vault, _chainId, _amountToWithdraw, _exchangeRate);\r\n      emit SendXChainAmount(vault, _chainId, _amountToWithdraw, _exchangeRate);\r\n    }\r\n  }\r\n\r\n  /// @notice Step 5 trigger; Push funds from xChainController to vaults\r\n  /// @notice Send amount to deposit from xController to vault and reset all stages for the vault\r\n  /// @param _vaultNumber Number of vault\r\n  function sendFundsToVault(uint256 _vaultNumber) external onlyWhenFundsReceived(_vaultNumber) {\r\n    for (uint i = 0; i < chainIds.length; i++) {\r\n      uint16 chain = chainIds[i];\r\n      if (getVaultChainIdOff(_vaultNumber, chain)) continue;\r\n\r\n      uint256 amountToDeposit = getAmountToDeposit(_vaultNumber, chain);\r\n\r\n      if (amountToDeposit > 0) {\r\n        address underlying = getUnderlyingAddress(_vaultNumber, chain);\r\n        address vault = getVaultAddress(_vaultNumber, chain);\r\n\r\n        IERC20(underlying).safeIncreaseAllowance(address(xProvider), amountToDeposit);\r\n        xProvider.xTransferToVaults(vault, chain, amountToDeposit, underlying);\r\n        setAmountToDeposit(_vaultNumber, chain, 0);\r\n\r\n        emit SentFundsToVault(vault, chain, amountToDeposit, underlying);\r\n      }\r\n    }\r\n\r\n    resetVaultStages(_vaultNumber);\r\n  }\r\n\r\n  /// @notice Helper to get total current allocation of vaultNumber\r\n  function getTotalUnderlyingOnChain(uint256 _vaultNumber, uint16 _chainId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return vaults[_vaultNumber].totalUnderlyingPerChain[_chainId];\r\n  }\r\n\r\n  /// @notice Gets saved totalUnderlying for vaultNumber\r\n  function getTotalUnderlyingVault(uint256 _vaultNumber)\r\n    internal\r\n    view\r\n    onlyWhenUnderlyingsReceived(_vaultNumber)\r\n    returns (uint256)\r\n  {\r\n    return vaults[_vaultNumber].totalUnderlying;\r\n  }\r\n\r\n  /// @notice Helper to get vault address of vaultNumber with given chainID\r\n  function getVaultAddress(uint256 _vaultNumber, uint16 _chainId) internal view returns (address) {\r\n    return vaults[_vaultNumber].vaultChainAddress[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get underyling address of vaultNumber with given chainID eg USDC\r\n  function getUnderlyingAddress(uint256 _vaultNumber, uint16 _chainId)\r\n    internal\r\n    view\r\n    returns (address)\r\n  {\r\n    return vaults[_vaultNumber].vaultUnderlyingAddress[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get current allocation per chain of vaultNumber with given chainID\r\n  function getCurrentAllocation(uint256 _vaultNumber, uint16 _chainId)\r\n    internal\r\n    view\r\n    returns (int256)\r\n  {\r\n    return vaults[_vaultNumber].currentAllocationPerChain[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get total current allocation of vaultNumber\r\n  function getCurrentTotalAllocation(uint256 _vaultNumber) internal view returns (int256) {\r\n    return vaults[_vaultNumber].totalCurrentAllocation;\r\n  }\r\n\r\n  /// @notice Helper to get if vault is active or not\r\n  function getVaultChainIdOff(uint256 _vaultNumber, uint16 _chainId) public view returns (bool) {\r\n    return vaults[_vaultNumber].chainIdOff[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to set the amount to deposit in a chain vault\r\n  function setAmountToDeposit(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    int256 _amountToDeposit\r\n  ) internal {\r\n    vaults[_vaultNumber].amountToDepositPerChain[_chainId] = uint256(_amountToDeposit);\r\n  }\r\n\r\n  /// @notice Helper to get the amount to deposit in a chain vault\r\n  function getAmountToDeposit(uint256 _vaultNumber, uint16 _chainId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return vaults[_vaultNumber].amountToDepositPerChain[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get total supply from the vault on given chainId\r\n  function getTotalSupply(uint256 _vaultNumber) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].totalSupply;\r\n  }\r\n\r\n  /// @notice Helper to get withdrawal requests from the vault on given chainId\r\n  function getWithdrawalRequests(uint256 _vaultNumber, uint16 _chainId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return vaults[_vaultNumber].withdrawalRequests[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get total withdrawal requests from the vault on given chainId\r\n  function getTotalWithdrawalRequests(uint256 _vaultNumber) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].totalWithdrawalRequests;\r\n  }\r\n\r\n  /// @notice Getter for dao address\r\n  function getDao() public view returns (address) {\r\n    return dao;\r\n  }\r\n\r\n  /// @notice Getter for guardian address\r\n  function getGuardian() public view returns (address) {\r\n    return guardian;\r\n  }\r\n\r\n  /*\r\n  Only Dao functions\r\n  */\r\n\r\n  /// @notice Set Vault address and underlying for a particulair chainId\r\n  /// @param _vaultNumber number of Vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _address address of the Vault\r\n  /// @param _underlying underlying of the Vault eg USDC\r\n  function setVaultChainAddress(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    address _address,\r\n    address _underlying\r\n  ) external onlyDao {\r\n    vaults[_vaultNumber].vaultChainAddress[_chainId] = _address;\r\n    vaults[_vaultNumber].vaultUnderlyingAddress[_chainId] = _underlying;\r\n  }\r\n\r\n  /// @notice Setter for xProvider address\r\n  /// @param _xProvider new address of xProvider on this chain\r\n  function setHomeXProvider(address _xProvider) external onlyDao {\r\n    xProvider = IXProvider(_xProvider);\r\n  }\r\n\r\n  /// @notice Setter for homeChain Id\r\n  /// @param _homeChainId New home chainId\r\n  function setHomeChainId(uint16 _homeChainId) external onlyDao {\r\n    homeChain = _homeChainId;\r\n  }\r\n\r\n  /// @notice Setter for DAO address\r\n  /// @param _dao DAO address\r\n  function setDao(address _dao) external onlyDao {\r\n    dao = _dao;\r\n  }\r\n\r\n  /// @notice Setter for guardian address\r\n  /// @param _guardian new address of the guardian\r\n  function setGuardian(address _guardian) external onlyDao {\r\n    guardian = _guardian;\r\n  }\r\n\r\n  /// @notice Setter for new game address\r\n  /// @param _game New address of the game\r\n  function setGame(address _game) external onlyDao {\r\n    game = _game;\r\n  }\r\n\r\n  /*\r\n  Only Guardian functions\r\n  */\r\n\r\n  /// @notice Setter for chainId array\r\n  /// @param _chainIds array of all the used chainIds\r\n  function setChainIds(uint16[] memory _chainIds) external onlyGuardian {\r\n    chainIds = _chainIds;\r\n  }\r\n\r\n  /// @notice Resets all stages in vaultStage struct for a vaultNumber\r\n  /// @dev onlyDao modifier so the dao can reset all stages for a vaultNumber incase something goes wrong\r\n  function resetVaultStagesDao(uint256 _vaultNumber) external onlyGuardian {\r\n    return resetVaultStages(_vaultNumber);\r\n  }\r\n\r\n  /// @notice Step 1: Guardian function\r\n  function receiveAllocationsFromGameGuard(uint256 _vaultNumber, int256[] memory _deltas)\r\n    external\r\n    onlyGuardian\r\n  {\r\n    return receiveAllocationsFromGameInt(_vaultNumber, _deltas);\r\n  }\r\n\r\n  /// @notice Step 2: Guardian function\r\n  function setTotalUnderlyingGuard(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) external onlyGuardian {\r\n    return\r\n      setTotalUnderlyingInt(_vaultNumber, _chainId, _underlying, _totalSupply, _withdrawalRequests);\r\n  }\r\n\r\n  /// @notice Step 4: Guardian function\r\n  function setFundsReceivedGuard(uint256 _vaultNumber, uint256 _fundsReceived)\r\n    external\r\n    onlyGuardian\r\n  {\r\n    vaultStage[_vaultNumber].fundsReceived = _fundsReceived;\r\n  }\r\n\r\n  /// @notice Guardian setter for number of active vaults for vaultNumber, set in xChainRebalance\r\n  function setActiveVaultsGuard(uint256 _vaultNumber, uint256 _activeVaults) external onlyGuardian {\r\n    vaultStage[_vaultNumber].activeVaults = _activeVaults;\r\n  }\r\n\r\n  /// @notice Guardian setter for stage 0:\r\n  function setReadyGuard(uint256 _vaultNumber, bool _state) external onlyGuardian {\r\n    vaultStage[_vaultNumber].ready = _state;\r\n  }\r\n\r\n  /// @notice Guardian setter for stage 1:\r\n  function setAllocationsReceivedGuard(uint256 _vaultNumber, bool _state) external onlyGuardian {\r\n    vaultStage[_vaultNumber].allocationsReceived = _state;\r\n  }\r\n\r\n  /// @notice Guardian setter to tick up stage 2:\r\n  function setUnderlyingReceivedGuard(uint256 _vaultNumber, uint256 _underlyingReceived)\r\n    external\r\n    onlyGuardian\r\n  {\r\n    vaultStage[_vaultNumber].underlyingReceived = _underlyingReceived;\r\n  }\r\n}\r\n"
    },
    "contracts/Interfaces/IXProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\ninterface IXProvider {\r\n  function xCall(\r\n    address _xProvider,\r\n    uint16 _chainId,\r\n    bytes memory _callData\r\n  ) external;\r\n\r\n  function xSend(uint256 _value) external; // sending a (permissioned) value crosschain.\r\n\r\n  // function xSendCallback() external; // sending a (permissioned) vaule crosschain and receive a callback to a specified address.\r\n  function xReceive(uint256 _value) external; // receiving a (permissioned) value crosschain.\r\n\r\n  function pushAllocations(uint256 _vaultNumber, int256[] memory _deltas) external;\r\n\r\n  function receiveTotalUnderlying(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _underlying\r\n  ) external;\r\n\r\n  function pushSetXChainAllocation(\r\n    address _vault,\r\n    uint16 _chainId,\r\n    uint256 _amountToWithdraw,\r\n    uint256 _exchangeRate\r\n  ) external;\r\n\r\n  function xTransferToController(\r\n    uint256 _vaultNumber,\r\n    uint256 _amount,\r\n    address _asset\r\n  ) external;\r\n\r\n  function receiveFeedbackToXController(uint256 _vaultNumber) external;\r\n\r\n  function xTransferToVaults(\r\n    address _vault,\r\n    uint16 _chainId,\r\n    uint256 _amount,\r\n    address _asset\r\n  ) external;\r\n\r\n  function pushProtocolAllocationsToVault(\r\n    uint16 _chainId,\r\n    address _vault,\r\n    int256[] memory _deltas\r\n  ) external;\r\n\r\n  function getDecimals(address _vault) external view returns (uint256);\r\n\r\n  function pushTotalUnderlying(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) external;\r\n\r\n  function pushStateFeedbackToVault(\r\n    address _vault,\r\n    uint16 _chainId,\r\n    bool _state\r\n  ) external;\r\n\r\n  function pushRewardsToGame(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    int256[] memory _rewards\r\n  ) external;\r\n\r\n  function homeChain() external returns (uint16);\r\n}\r\n"
    },
    "contracts/MainVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"./Vault.sol\";\r\n\r\nimport \"./Interfaces/IXProvider.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract MainVault is Vault, VaultToken {\r\n  using SafeERC20 for IERC20;\r\n\r\n  address public derbyToken;\r\n  address public game;\r\n  address public xProvider;\r\n\r\n  bool public vaultOff;\r\n  // True when rewards should be swapped to derby tokens\r\n  bool private swapRewards;\r\n\r\n  // total amount of withdrawal requests for the vault to pull extra during a cross-chain rebalance, will be upped when a user makes a withdrawalRequest\r\n  // during a cross-chain rebalance the vault will pull extra funds by the amount of totalWithdrawalRequests and the totalWithdrawalRequests will turn into actual reservedFunds\r\n  uint256 internal totalWithdrawalRequests;\r\n\r\n  uint256 public exchangeRate;\r\n  uint16 public homeChain;\r\n  uint256 public amountToSendXChain;\r\n\r\n  // (userAddress => withdrawalAllowance): amount in vaultCurrency the vault owes to the user\r\n  mapping(address => uint256) internal withdrawalAllowance;\r\n  // (userAddress => requestPeriod): rebalancing period the withdrawal request is made\r\n  mapping(address => uint256) internal withdrawalRequestPeriod;\r\n  // (userAddress => rewardAllowance): amount in vaultCurrency the vault owes to the user\r\n  mapping(address => uint256) internal rewardAllowance;\r\n  // (userAddress => requestPeriod): rebalancing period the reward request is made\r\n  mapping(address => uint256) internal rewardRequestPeriod;\r\n\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint8 _decimals,\r\n    uint256 _vaultNumber,\r\n    address _dao,\r\n    address _game,\r\n    address _controller,\r\n    address _vaultCurrency,\r\n    uint256 _uScale,\r\n    uint256 _gasFeeLiquidity\r\n  )\r\n    VaultToken(_name, _symbol, _decimals)\r\n    Vault(_vaultNumber, _dao, _controller, _vaultCurrency, _uScale, _gasFeeLiquidity)\r\n  {\r\n    exchangeRate = _uScale;\r\n    game = _game;\r\n  }\r\n\r\n  modifier onlyXProvider() {\r\n    require(msg.sender == xProvider, \"only xProvider\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyWhenVaultIsOn() {\r\n    require(state == State.Idle, \"Rebalancing\");\r\n    require(!vaultOff, \"Vault is off\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyWhenIdle() {\r\n    require(state == State.Idle, \"Rebalancing\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGame() {\r\n    require(msg.sender == game, \"only game\");\r\n    _;\r\n  }\r\n\r\n  event PushTotalUnderlying(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  );\r\n  event RebalanceXChain(uint256 _vaultNumber, uint256 _amount, address _asset);\r\n  event PushedRewardsToGame(uint256 _vaultNumber, uint16 _chain, int256[] _rewards);\r\n\r\n  function init() external onlyDao {\r\n    // setHomeXProvider\r\n    // setChainIds\r\n    // setGuardian\r\n  }\r\n\r\n  /// @notice Deposit in Vault\r\n  /// @dev Deposit VaultCurrency to Vault and mint LP tokens\r\n  /// @param _amount Amount to deposit\r\n  /// @return shares Tokens received by buyer\r\n  function deposit(uint256 _amount)\r\n    external\r\n    nonReentrant\r\n    onlyWhenVaultIsOn\r\n    returns (uint256 shares)\r\n  {\r\n    uint256 balanceBefore = getVaultBalance();\r\n    vaultCurrency.safeTransferFrom(msg.sender, address(this), _amount);\r\n    uint256 balanceAfter = getVaultBalance();\r\n\r\n    uint256 amount = balanceAfter - balanceBefore;\r\n    shares = (amount * (10**decimals())) / exchangeRate;\r\n\r\n    _mint(msg.sender, shares);\r\n  }\r\n\r\n  /// @notice Withdraw from Vault\r\n  /// @dev Withdraw VaultCurrency from Vault and burn LP tokens\r\n  /// @param _amount Amount to withdraw in LP tokens\r\n  /// @return value Amount received by seller in vaultCurrency\r\n  function withdraw(uint256 _amount)\r\n    external\r\n    nonReentrant\r\n    onlyWhenVaultIsOn\r\n    returns (uint256 value)\r\n  {\r\n    value = (_amount * exchangeRate) / (10**decimals());\r\n\r\n    require(value > 0, \"No value\");\r\n\r\n    require(getVaultBalance() >= value, \"Not enough funds\");\r\n\r\n    _burn(msg.sender, _amount);\r\n    vaultCurrency.safeTransfer(msg.sender, value);\r\n  }\r\n\r\n  /// @notice Withdrawal request for when the vault doesnt have enough funds available\r\n  /// @dev Will give the user allowance for his funds and pulls the extra funds at the next rebalance\r\n  /// @param _amount Amount to withdraw in LP token\r\n  function withdrawalRequest(uint256 _amount)\r\n    external\r\n    nonReentrant\r\n    onlyWhenVaultIsOn\r\n    returns (uint256 value)\r\n  {\r\n    require(withdrawalRequestPeriod[msg.sender] == 0, \"Already a request\");\r\n\r\n    value = (_amount * exchangeRate) / (10**decimals());\r\n\r\n    _burn(msg.sender, _amount);\r\n\r\n    withdrawalAllowance[msg.sender] = value;\r\n    withdrawalRequestPeriod[msg.sender] = rebalancingPeriod;\r\n    totalWithdrawalRequests += value;\r\n  }\r\n\r\n  /// @notice Withdraw the allowance the user requested on the last rebalancing period\r\n  /// @dev Will send the user funds and reset the allowance\r\n  function withdrawAllowance() external nonReentrant onlyWhenIdle returns (uint256 value) {\r\n    require(withdrawalAllowance[msg.sender] > 0, \"No allowance\");\r\n    require(rebalancingPeriod > withdrawalRequestPeriod[msg.sender], \"Funds not arrived\");\r\n\r\n    value = withdrawalAllowance[msg.sender];\r\n\r\n    require(vaultCurrency.balanceOf(address(this)) >= value, \"No funds\");\r\n\r\n    reservedFunds -= value;\r\n    delete withdrawalAllowance[msg.sender];\r\n    delete withdrawalRequestPeriod[msg.sender];\r\n\r\n    vaultCurrency.safeTransfer(msg.sender, value);\r\n  }\r\n\r\n  /// @notice Function for the game to set a withdrawalRequest for the rewards of the game user\r\n  /// @param _value Amount to set a request in vaultCurrency\r\n  /// @param _user Address of the user\r\n  function redeemRewardsGame(uint256 _value, address _user)\r\n    external\r\n    onlyGame\r\n    nonReentrant\r\n    onlyWhenVaultIsOn\r\n  {\r\n    require(rewardAllowance[_user] == 0, \"No allowance\");\r\n\r\n    rewardAllowance[_user] = _value;\r\n    rewardRequestPeriod[_user] = rebalancingPeriod;\r\n    totalWithdrawalRequests += _value;\r\n  }\r\n\r\n  /// @notice Withdraw the reward allowance set by the game with redeemRewardsGame\r\n  /// @dev Will swap vaultCurrency to Derby tokens, send the user funds and reset the allowance\r\n  function withdrawRewards() external nonReentrant onlyWhenIdle returns (uint256 value) {\r\n    require(rewardAllowance[msg.sender] > 0, \"No allowance\");\r\n    require(rebalancingPeriod > rewardRequestPeriod[msg.sender], \"Funds not arrived\");\r\n\r\n    value = rewardAllowance[msg.sender];\r\n\r\n    require(vaultCurrency.balanceOf(address(this)) >= value, \"No funds\");\r\n\r\n    reservedFunds -= value;\r\n    delete rewardAllowance[msg.sender];\r\n    delete rewardRequestPeriod[msg.sender];\r\n\r\n    if (swapRewards) {\r\n      uint256 tokensReceived = Swap.swapTokensMulti(\r\n        Swap.SwapInOut(value, address(vaultCurrency), derbyToken),\r\n        controller.getUniswapParams()\r\n      );\r\n      IERC20(derbyToken).safeTransfer(msg.sender, tokensReceived);\r\n    } else {\r\n      vaultCurrency.safeTransfer(msg.sender, value);\r\n    }\r\n  }\r\n\r\n  /// @notice Step 2 trigger; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\r\n  /// @notice Pushes totalUnderlying, totalSupply and totalWithdrawalRequests of the vault for this chainId to xController\r\n  function pushTotalUnderlyingToController() external onlyWhenIdle {\r\n    require(rebalanceNeeded(), \"No rebalance needed\");\r\n\r\n    setTotalUnderlying();\r\n    uint256 underlying = savedTotalUnderlying + getVaultBalance();\r\n\r\n    IXProvider(xProvider).pushTotalUnderlying(\r\n      vaultNumber,\r\n      homeChain,\r\n      underlying,\r\n      totalSupply(),\r\n      totalWithdrawalRequests\r\n    );\r\n\r\n    state = State.PushedUnderlying;\r\n    lastTimeStamp = block.timestamp;\r\n\r\n    emit PushTotalUnderlying(\r\n      vaultNumber,\r\n      homeChain,\r\n      underlying,\r\n      totalSupply(),\r\n      totalWithdrawalRequests\r\n    );\r\n  }\r\n\r\n  /// @notice See setXChainAllocationInt below\r\n  function setXChainAllocation(uint256 _amountToSend, uint256 _exchangeRate)\r\n    external\r\n    onlyXProvider\r\n  {\r\n    require(state == State.PushedUnderlying, \"Wrong state\");\r\n    setXChainAllocationInt(_amountToSend, _exchangeRate);\r\n  }\r\n\r\n  /// @notice Step 3 end; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\r\n  /// @notice Will set the amount to send back to the xController by the xController\r\n  /// @dev Sets the amount and state so the dao can trigger the rebalanceXChain function\r\n  /// @dev When amount == 0 the vault doesnt need to send anything and will wait for funds from the xController\r\n  /// @param _amountToSend amount to send in vaultCurrency\r\n  function setXChainAllocationInt(uint256 _amountToSend, uint256 _exchangeRate) internal {\r\n    amountToSendXChain = _amountToSend;\r\n    exchangeRate = _exchangeRate;\r\n\r\n    if (_amountToSend == 0) state = State.WaitingForFunds;\r\n    else state = State.SendingFundsXChain;\r\n  }\r\n\r\n  /// @notice Step 4 trigger; Push funds from vaults to xChainController\r\n  /// @notice Send vaultcurrency to the xController for xChain rebalance\r\n  function rebalanceXChain() external {\r\n    if (state != State.SendingFundsXChain) return;\r\n\r\n    if (amountToSendXChain > getVaultBalance()) pullFunds(amountToSendXChain);\r\n\r\n    vaultCurrency.safeIncreaseAllowance(xProvider, amountToSendXChain);\r\n    IXProvider(xProvider).xTransferToController(\r\n      vaultNumber,\r\n      amountToSendXChain,\r\n      address(vaultCurrency)\r\n    );\r\n\r\n    amountToSendXChain = 0;\r\n    settleReservedFunds();\r\n\r\n    emit RebalanceXChain(vaultNumber, amountToSendXChain, address(vaultCurrency));\r\n  }\r\n\r\n  /// @notice Step 5 end; Push funds from xChainController to vaults\r\n  /// @notice Receiving feedback from xController when funds are received, so the vault can rebalance\r\n  function receiveFunds() external onlyXProvider {\r\n    if (state != State.WaitingForFunds) return;\r\n    settleReservedFunds();\r\n  }\r\n\r\n  /// @notice Helper to settle reserved funds when funds arrived and up to the next State\r\n  function settleReservedFunds() internal {\r\n    reservedFunds += totalWithdrawalRequests;\r\n    totalWithdrawalRequests = 0;\r\n    state = State.RebalanceVault;\r\n  }\r\n\r\n  /// @notice See receiveProtocolAllocations below\r\n  function receiveProtocolAllocations(int256[] memory _deltas) external onlyXProvider {\r\n    receiveProtocolAllocationsInt(_deltas);\r\n  }\r\n\r\n  /// @notice Step 6 end; Game pushes deltaAllocations to vaults\r\n  /// @notice Receives protocol allocation array from the game and settles the allocations\r\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\r\n  function receiveProtocolAllocationsInt(int256[] memory _deltas) internal {\r\n    for (uint i = 0; i < _deltas.length; i++) {\r\n      int256 allocation = _deltas[i];\r\n      if (allocation == 0) continue;\r\n      setDeltaAllocationsInt(i, allocation);\r\n    }\r\n\r\n    deltaAllocationsReceived = true;\r\n  }\r\n\r\n  /// @notice Step 8 trigger; Vaults push rewardsPerLockedToken to game\r\n  function sendRewardsToGame() external {\r\n    require(state == State.SendRewardsPerToken, \"Wrong state\");\r\n\r\n    int256[] memory rewards = rewardsToArray();\r\n    IXProvider(xProvider).pushRewardsToGame(vaultNumber, homeChain, rewards);\r\n\r\n    state = State.Idle;\r\n\r\n    emit PushedRewardsToGame(vaultNumber, homeChain, rewards);\r\n  }\r\n\r\n  /// @notice Receive feedback for the vault if the vault is set to on or off\r\n  /// @param _state bool for chainId on or off\r\n  function toggleVaultOnOff(bool _state) external onlyXProvider {\r\n    vaultOff = _state;\r\n  }\r\n\r\n  /// @notice Returns the amount in vaultCurrency the user is able to withdraw\r\n  function getWithdrawalAllowance() external view returns (uint256) {\r\n    return withdrawalAllowance[msg.sender];\r\n  }\r\n\r\n  /*\r\n  Only Dao functions\r\n  */\r\n\r\n  /// @notice Setter for xProvider address\r\n  /// @param _xProvider new address of xProvider on this chain\r\n  function setHomeXProvider(address _xProvider) external onlyDao {\r\n    xProvider = _xProvider;\r\n  }\r\n\r\n  /// @notice Setter for derby token address\r\n  /// @param _token New address of the derby token\r\n  function setDaoToken(address _token) external onlyDao {\r\n    derbyToken = _token;\r\n  }\r\n\r\n  /// @notice Setter for new game address\r\n  /// @param _game New address of the game\r\n  function setGame(address _game) external onlyDao {\r\n    game = _game;\r\n  }\r\n\r\n  /// @notice Setter for swapping rewards to derby tokens\r\n  /// @param _state True when rewards should be swapped to derby tokens\r\n  function setSwapRewards(bool _state) external onlyDao {\r\n    swapRewards = _state;\r\n  }\r\n\r\n  /*\r\n  Only Guardian functions\r\n  */\r\n\r\n  /// @notice Step 3: Guardian function\r\n  function setXChainAllocationGuard(uint256 _amountToSend, uint256 _exchangeRate)\r\n    external\r\n    onlyGuardian\r\n  {\r\n    setXChainAllocationInt(_amountToSend, _exchangeRate);\r\n  }\r\n\r\n  /// @notice Step 5: Guardian function\r\n  function receiveFundsGuard() external onlyGuardian {\r\n    settleReservedFunds();\r\n  }\r\n\r\n  /// @notice Step 6: Guardian function\r\n  function receiveProtocolAllocationsGuard(int256[] memory _deltas) external onlyGuardian {\r\n    receiveProtocolAllocationsInt(_deltas);\r\n  }\r\n\r\n  /// @notice Guardian function to set state when vault gets stuck for whatever reason\r\n  function setVaultStateGuard(State _state) external onlyGuardian {\r\n    state = _state;\r\n  }\r\n\r\n  /// @notice Setter for new homeChain Id\r\n  function setChainIds(uint16 _homeChain) external onlyGuardian {\r\n    homeChain = _homeChain;\r\n  }\r\n}\r\n"
    },
    "contracts/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\nimport \"./Interfaces/IController.sol\";\r\nimport \"./Interfaces/IProvider.sol\";\r\n\r\nimport \"./VaultToken.sol\";\r\nimport \"./libraries/Swap.sol\";\r\n\r\ncontract Vault is ReentrancyGuard {\r\n  using SafeERC20 for IERC20;\r\n\r\n  // state 0 Rebalance done and ready for xController to rebalance again\r\n  // state 1 Allocation amount received and ready to send funds over to xController\r\n  // state 2 Allocation amount 0 received => will receive funds from xController\r\n  // state 3 Allocation amount sent or received and ready to rebalance the vault itself\r\n  enum State {\r\n    Idle,\r\n    PushedUnderlying,\r\n    SendingFundsXChain,\r\n    WaitingForFunds,\r\n    RebalanceVault,\r\n    SendRewardsPerToken\r\n  }\r\n\r\n  IERC20 public vaultCurrency;\r\n  IController public controller;\r\n  State public state;\r\n\r\n  bool public deltaAllocationsReceived;\r\n\r\n  address private dao;\r\n  address private guardian;\r\n  address public vaultCurrencyAddr;\r\n  address public xController;\r\n\r\n  uint256 public vaultNumber;\r\n  uint256 public liquidityPerc = 10;\r\n  uint256 public performanceFee = 10;\r\n  uint256 public rebalancingPeriod = 1;\r\n  uint256 public uScale;\r\n  int256 public marginScale = 1E10; // 10000 USDC\r\n\r\n  // UNIX timestamp\r\n  uint256 public rebalanceInterval; // SHOULD BE REPLACED FOR REALISTIC NUMBER\r\n  uint256 public lastTimeStamp;\r\n  uint256 public gasFeeLiquidity;\r\n\r\n  // total underlying of all protocols in vault, excluding vault balance\r\n  uint256 public savedTotalUnderlying;\r\n\r\n  // total amount of funds the vault reserved for users that made a withdrawalRequest\r\n  uint256 internal reservedFunds;\r\n\r\n  // total number of allocated Derby tokens currently\r\n  int256 public totalAllocatedTokens;\r\n  // delta of the total number of Derby tokens allocated on next rebalancing\r\n  int256 private deltaAllocatedTokens;\r\n\r\n  // (protocolNumber => currentAllocation): current allocations over the protocols\r\n  mapping(uint256 => int256) internal currentAllocations;\r\n\r\n  // (protocolNumber => deltaAllocation): delta of the portfolio on next rebalancing\r\n  mapping(uint256 => int256) internal deltaAllocations;\r\n\r\n  // historical reward per protocol per token, formula: TVL * yield * perfFee / totalLockedTokens\r\n  // (rebalancingPeriod => protocolId => rewardPerLockedToken)\r\n  mapping(uint256 => mapping(uint256 => int256)) public rewardPerLockedToken;\r\n\r\n  // (protocolNumber => lastPrice): last price of underlying protocol vault\r\n  mapping(uint256 => uint256) public lastPrices;\r\n\r\n  event GasPaidRebalanceETF(uint256 gasInVaultCurrency);\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"Vault: only DAO\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == guardian, \"only Guardian\");\r\n    _;\r\n  }\r\n\r\n  modifier returnGasFee() {\r\n    uint256 gasStart = gasleft();\r\n    _;\r\n    uint256 gasUsed = gasStart - gasleft();\r\n    // console.log(\"gasUsed %s\", gasUsed);\r\n    swapAndPayGasFee(gasUsed);\r\n  }\r\n\r\n  constructor(\r\n    uint256 _vaultNumber,\r\n    address _dao,\r\n    address _controller,\r\n    address _vaultCurrency,\r\n    uint256 _uScale,\r\n    uint256 _gasFeeLiquidity\r\n  ) {\r\n    controller = IController(_controller);\r\n    vaultCurrency = IERC20(_vaultCurrency);\r\n\r\n    vaultNumber = _vaultNumber;\r\n    dao = _dao;\r\n    uScale = _uScale;\r\n    gasFeeLiquidity = _gasFeeLiquidity;\r\n    lastTimeStamp = block.timestamp;\r\n  }\r\n\r\n  /// @notice Withdraw from protocols on shortage in Vault\r\n  /// @dev Keeps on withdrawing until the Vault balance > _value\r\n  /// @param _value The total value of vaultCurrency an user is trying to withdraw.\r\n  /// @param _value The (value - current underlying value of this vault) is withdrawn from the underlying protocols.\r\n  function pullFunds(uint256 _value) internal {\r\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\r\n    for (uint i = 0; i < latestID; i++) {\r\n      if (currentAllocations[i] == 0) continue;\r\n\r\n      uint256 shortage = _value - getVaultBalance();\r\n      uint256 balanceProtocol = balanceUnderlying(i);\r\n\r\n      uint256 amountToWithdraw = shortage > balanceProtocol ? balanceProtocol : shortage;\r\n      savedTotalUnderlying -= amountToWithdraw;\r\n\r\n      withdrawFromProtocol(i, amountToWithdraw);\r\n\r\n      if (_value <= getVaultBalance()) break;\r\n    }\r\n  }\r\n\r\n  /// @notice Step 7 trigger, end; Vaults rebalance\r\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\r\n  /// @dev amountToProtocol = totalAmount * currentAllocation / totalAllocatedTokens\r\n  /// @dev amountToDeposit = amountToProtocol - currentBalanceProtocol\r\n  /// @dev if amountToDeposit < 0 => withdraw\r\n  /// @dev Execute all withdrawals before deposits\r\n  function rebalanceETF() external returnGasFee nonReentrant {\r\n    require(state == State.RebalanceVault, \"Wrong state\");\r\n    require(deltaAllocationsReceived, \"!Delta allocations\");\r\n\r\n    rebalancingPeriod++;\r\n\r\n    claimTokens();\r\n    settleDeltaAllocation();\r\n\r\n    uint256 underlyingIncBalance = calcUnderlyingIncBalance();\r\n    uint256[] memory protocolToDeposit = rebalanceCheckProtocols(underlyingIncBalance);\r\n\r\n    executeDeposits(protocolToDeposit);\r\n    setTotalUnderlying();\r\n\r\n    if (getVaultBalance() < gasFeeLiquidity) pullFunds(gasFeeLiquidity);\r\n\r\n    state = State.SendRewardsPerToken;\r\n    deltaAllocationsReceived = false;\r\n  }\r\n\r\n  /// @notice Helper to return underlying balance plus totalUnderlying - liquidty for the vault\r\n  /// @return underlying totalUnderlying - liquidityVault\r\n  function calcUnderlyingIncBalance() internal view returns (uint256) {\r\n    uint256 totalUnderlyingInclVaultBalance = savedTotalUnderlying + getVaultBalance();\r\n    uint256 liquidityVault = (totalUnderlyingInclVaultBalance * liquidityPerc) / 100;\r\n    return totalUnderlyingInclVaultBalance - liquidityVault;\r\n  }\r\n\r\n  /// @notice Adds deltaAllocatedTokens to totalAllocatedTokens\r\n  function settleDeltaAllocation() internal {\r\n    totalAllocatedTokens += deltaAllocatedTokens;\r\n    deltaAllocatedTokens = 0;\r\n  }\r\n\r\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\r\n  /// @dev Loops over all protocols in ETF, calculate new currentAllocation based on deltaAllocation\r\n  /// @dev Also calculate the performance fee here. This is an amount, based on the current TVL (before the rebalance),\r\n  /// @dev the performanceFee and difference between the current exchangeRate and the exchangeRate of the last rebalance of the vault.\r\n  /// @param _newTotalUnderlying this will be the new total underlying: Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\r\n  /// @return uint256[] with amounts to deposit in protocols, the index being the protocol number.\r\n  function rebalanceCheckProtocols(uint256 _newTotalUnderlying)\r\n    internal\r\n    returns (uint256[] memory)\r\n  {\r\n    uint256[] memory protocolToDeposit = new uint[](controller.latestProtocolId(vaultNumber));\r\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\r\n    for (uint i = 0; i < latestID; i++) {\r\n      bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, i);\r\n\r\n      storePriceAndRewards(_newTotalUnderlying, i);\r\n\r\n      if (isBlacklisted) continue;\r\n      setAllocation(i);\r\n\r\n      int256 amountToProtocol = calcAmountToProtocol(_newTotalUnderlying, i);\r\n      uint256 currentBalance = balanceUnderlying(i);\r\n\r\n      int256 amountToDeposit = amountToProtocol - int(currentBalance);\r\n      uint256 amountToWithdraw = amountToDeposit < 0 ? currentBalance - uint(amountToProtocol) : 0;\r\n\r\n      if (amountToDeposit > marginScale) protocolToDeposit[i] = uint256(amountToDeposit);\r\n      if (amountToWithdraw > uint(marginScale) || currentAllocations[i] == 0)\r\n        withdrawFromProtocol(i, amountToWithdraw);\r\n    }\r\n\r\n    return protocolToDeposit;\r\n  }\r\n\r\n  /// @notice Calculates the amount to deposit or withdraw to protocol during a vault rebalance\r\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\r\n  /// @param _protocol Protocol id number\r\n  /// @return amountToProtocol amount to deposit or withdraw to protocol\r\n  function calcAmountToProtocol(uint256 _totalUnderlying, uint256 _protocol)\r\n    internal\r\n    view\r\n    returns (int256 amountToProtocol)\r\n  {\r\n    if (totalAllocatedTokens == 0) amountToProtocol = 0;\r\n    else\r\n      amountToProtocol =\r\n        (int(_totalUnderlying) * currentAllocations[_protocol]) /\r\n        totalAllocatedTokens;\r\n  }\r\n\r\n  /// @notice Stores the historical price and the reward per rounded locked token, ignoring decimals.\r\n  /// @dev formula yield protocol i at time t: y(it) = (P(it) - P(it-1)) / P(it-1).\r\n  /// @dev formula rewardPerLockedToken for protocol i at time t: r(it) = y(it) * TVL(t) * perfFee(t) / totalLockedTokens(t)\r\n  /// @dev later, when the total rewards are calculated for a game player we multiply this (r(it)) by the locked tokens on protocol i at time t\r\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault.\r\n  /// @param _protocolId Protocol id number.\r\n  function storePriceAndRewards(uint256 _totalUnderlying, uint256 _protocolId) internal {\r\n    uint256 price = price(_protocolId);\r\n    if (lastPrices[_protocolId] == 0) return;\r\n    int256 priceDiff = int256(price - lastPrices[_protocolId]);\r\n    int256 nominator = (int256(_totalUnderlying * performanceFee) * priceDiff);\r\n    int256 totalAllocatedTokensRounded = totalAllocatedTokens / 1E18;\r\n    int256 denominator = totalAllocatedTokensRounded * int256(lastPrices[_protocolId]) * 100; // * 100 cause perfFee is in percentages\r\n    if (totalAllocatedTokensRounded == 0) {\r\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = 0;\r\n    } else {\r\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = nominator / denominator;\r\n    }\r\n    lastPrices[_protocolId] = price;\r\n  }\r\n\r\n  /// @notice Creates array out of the rewardsPerLockedToken mapping to send to the game\r\n  /// @return rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\r\n  function rewardsToArray() internal view returns (int256[] memory rewards) {\r\n    uint256 latestId = controller.latestProtocolId(vaultNumber);\r\n    rewards = new int[](latestId);\r\n\r\n    for (uint256 i = 0; i < latestId; i++) {\r\n      rewards[i] = rewardPerLockedToken[rebalancingPeriod][i];\r\n    }\r\n  }\r\n\r\n  /// @notice Swaps the gas used from RebalanceETF, from vaultcurrency to ETH and send it to the dao\r\n  /// @notice This way the vault will pay the gas for the RebalanceETF function\r\n  /// @param _gasUsed total gas used by RebalanceETF\r\n  function swapAndPayGasFee(uint256 _gasUsed) internal {\r\n    uint256 amountEtherToVaultCurrency = Swap.amountOutSingleSwap(\r\n      Swap.SwapInOut(\r\n        (_gasUsed + Swap.gasUsedForSwap) * controller.getGasPrice(),\r\n        Swap.WETH,\r\n        address(vaultCurrency)\r\n      ),\r\n      controller.getUniswapQuoter(),\r\n      controller.getUniswapPoolFee()\r\n    );\r\n\r\n    uint256 wethReceived = Swap.swapTokensSingle(\r\n      Swap.SwapInOut(amountEtherToVaultCurrency, address(vaultCurrency), Swap.WETH),\r\n      controller.getUniswapParams()\r\n    );\r\n    Swap.unWrapWETHtoGov(payable(dao), wethReceived);\r\n\r\n    emit GasPaidRebalanceETF(amountEtherToVaultCurrency);\r\n  }\r\n\r\n  /// @notice Helper function to set allocations\r\n  /// @param _i Protocol number linked to an underlying protocol e.g compound_usdc_01\r\n  function setAllocation(uint256 _i) internal {\r\n    currentAllocations[_i] += deltaAllocations[_i];\r\n    deltaAllocations[_i] = 0;\r\n    require(currentAllocations[_i] >= 0, \"Allocation underflow\");\r\n  }\r\n\r\n  /// @notice Helper function so the rebalance will execute all withdrawals first\r\n  /// @dev Executes and resets all deposits set in mapping(protocolToDeposit) by rebalanceETF\r\n  /// @param protocolToDeposit array with amounts to deposit in protocols, the index being the protocol number.\r\n  function executeDeposits(uint256[] memory protocolToDeposit) internal {\r\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\r\n    for (uint i = 0; i < latestID; i++) {\r\n      uint256 amount = protocolToDeposit[i];\r\n      if (amount == 0) continue;\r\n      // console.log(\"protocol: %s, deposit: %s\", i, amount);\r\n      depositInProtocol(i, amount);\r\n    }\r\n  }\r\n\r\n  /// @notice Deposit amount to underlying protocol\r\n  /// @dev Deposits VaultCurrency in Protocol e.g USDC\r\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\r\n  /// @param _amount in VaultCurrency to deposit\r\n  function depositInProtocol(uint256 _protocolNum, uint256 _amount) internal {\r\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\r\n      vaultNumber,\r\n      _protocolNum\r\n    );\r\n\r\n    if (getVaultBalance() < _amount) _amount = getVaultBalance();\r\n\r\n    if (protocol.underlying != address(vaultCurrency)) {\r\n      _amount = Swap.swapStableCoins(\r\n        Swap.SwapInOut(_amount, address(vaultCurrency), protocol.underlying),\r\n        uScale,\r\n        controller.underlyingUScale(protocol.underlying),\r\n        controller.getCurveParams(address(vaultCurrency), protocol.underlying)\r\n      );\r\n    }\r\n\r\n    IERC20(protocol.underlying).safeIncreaseAllowance(protocol.provider, _amount);\r\n    IProvider(protocol.provider).deposit(_amount, protocol.LPToken, protocol.underlying);\r\n  }\r\n\r\n  /// @notice Withdraw amount from underlying protocol\r\n  /// @dev shares = amount / PricePerShare\r\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\r\n  /// @param _amount in VaultCurrency to withdraw\r\n  function withdrawFromProtocol(uint256 _protocolNum, uint256 _amount) internal {\r\n    if (_amount <= 0) return;\r\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\r\n      vaultNumber,\r\n      _protocolNum\r\n    );\r\n\r\n    _amount = (_amount * protocol.uScale) / uScale;\r\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\r\n\r\n    IERC20(protocol.LPToken).safeIncreaseAllowance(protocol.provider, shares);\r\n    uint256 amountReceived = IProvider(protocol.provider).withdraw(\r\n      shares,\r\n      protocol.LPToken,\r\n      protocol.underlying\r\n    );\r\n\r\n    if (protocol.underlying != address(vaultCurrency)) {\r\n      _amount = Swap.swapStableCoins(\r\n        Swap.SwapInOut(amountReceived, protocol.underlying, address(vaultCurrency)),\r\n        controller.underlyingUScale(protocol.underlying),\r\n        uScale,\r\n        controller.getCurveParams(protocol.underlying, address(vaultCurrency))\r\n      );\r\n    }\r\n  }\r\n\r\n  /// @notice Set total balance in VaultCurrency in all underlying protocols\r\n  function setTotalUnderlying() public {\r\n    uint totalUnderlying;\r\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\r\n    for (uint i = 0; i < latestID; i++) {\r\n      if (currentAllocations[i] == 0) continue;\r\n      totalUnderlying += balanceUnderlying(i);\r\n    }\r\n    savedTotalUnderlying = totalUnderlying;\r\n  }\r\n\r\n  /// @notice Get balance in VaultCurrency in underlying protocol\r\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\r\n  /// @return Balance in VaultCurrency e.g USDC\r\n  function balanceUnderlying(uint256 _protocolNum) public view returns (uint256) {\r\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\r\n      vaultNumber,\r\n      _protocolNum\r\n    );\r\n    uint256 underlyingBalance = (IProvider(protocol.provider).balanceUnderlying(\r\n      address(this),\r\n      protocol.LPToken\r\n    ) * uScale) / protocol.uScale;\r\n\r\n    return underlyingBalance;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount in vault currency\r\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _protocolNum, uint256 _amount) public view returns (uint256) {\r\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\r\n      vaultNumber,\r\n      _protocolNum\r\n    );\r\n    uint256 shares = IProvider(protocol.provider).calcShares(\r\n      (_amount * protocol.uScale) / uScale,\r\n      protocol.LPToken\r\n    );\r\n\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get price for underlying protocol\r\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\r\n  /// @return protocolPrice Price per lp token\r\n  function price(uint256 _protocolNum) public view returns (uint256) {\r\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\r\n      vaultNumber,\r\n      _protocolNum\r\n    );\r\n    return IProvider(protocol.provider).exchangeRate(protocol.LPToken);\r\n  }\r\n\r\n  /// @notice Set the delta allocated tokens by game contract\r\n  /// @dev Allocation can be negative\r\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\r\n  /// @param _allocation Delta allocation in tokens\r\n  function setDeltaAllocationsInt(uint256 _protocolNum, int256 _allocation) internal {\r\n    require(!controller.getProtocolBlacklist(vaultNumber, _protocolNum), \"Protocol on blacklist\");\r\n    deltaAllocations[_protocolNum] += _allocation;\r\n    deltaAllocatedTokens += _allocation;\r\n  }\r\n\r\n  /// @notice Harvest extra tokens from underlying protocols\r\n  /// @dev Loops over protocols in ETF and check if they are claimable in controller contract\r\n  function claimTokens() public {\r\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\r\n    for (uint i = 0; i < latestID; i++) {\r\n      if (currentAllocations[i] == 0) continue;\r\n      bool claim = controller.claim(vaultNumber, i);\r\n      if (claim) {\r\n        address govToken = controller.getGovToken(vaultNumber, i);\r\n        uint256 tokenBalance = IERC20(govToken).balanceOf(address(this));\r\n        Swap.swapTokensMulti(\r\n          Swap.SwapInOut(tokenBalance, govToken, address(vaultCurrency)),\r\n          controller.getUniswapParams()\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  function getVaultBalance() public view returns (uint256) {\r\n    return vaultCurrency.balanceOf(address(this)) - reservedFunds;\r\n  }\r\n\r\n  /// @notice Checks if a rebalance is needed based on the set interval\r\n  /// @return bool True of rebalance is needed, false if not\r\n  function rebalanceNeeded() public view returns (bool) {\r\n    return (block.timestamp - lastTimeStamp) > rebalanceInterval;\r\n  }\r\n\r\n  /// @notice Getter for dao address\r\n  function getDao() public view returns (address) {\r\n    return dao;\r\n  }\r\n\r\n  /// @notice Getter for guardian address\r\n  function getGuardian() public view returns (address) {\r\n    return guardian;\r\n  }\r\n\r\n  /*\r\n  Only Dao functions\r\n  */\r\n\r\n  /// @notice Set the performanceFee, the percentage of the yield that goes to the game players.\r\n  /// @dev The actual performanceFee could be a bit more or a bit less than the performanceFee set here due to approximations in the game.\r\n  /// @param _performanceFee Value at which to set the performanceFee.\r\n  function setPerformanceFee(uint256 _performanceFee) external onlyDao {\r\n    require(_performanceFee <= 100, \"Cannot exceed 100%\");\r\n    performanceFee = _performanceFee;\r\n  }\r\n\r\n  /// @notice Set the governance address\r\n  /// @param _dao New address of the governance / DAO\r\n  function setDao(address _dao) external onlyDao {\r\n    dao = _dao;\r\n  }\r\n\r\n  /// @notice Setter for guardian address\r\n  /// @param _guardian new address of the guardian\r\n  function setGuardian(address _guardian) external onlyDao {\r\n    guardian = _guardian;\r\n  }\r\n\r\n  /*\r\n  Only Guardian functions\r\n  */\r\n\r\n  /// @notice Set the gasFeeLiquidity, liquidity in vaultcurrency which always should be kept in vault to pay for rebalance gas fee\r\n  /// @param _gasFeeLiquidity Value at which to set the gasFeeLiquidity in vaultCurrency\r\n  function setGasFeeLiquidity(uint256 _gasFeeLiquidity) external onlyGuardian {\r\n    gasFeeLiquidity = _gasFeeLiquidity;\r\n  }\r\n\r\n  /// @notice Set minimum interval for the rebalance function\r\n  /// @param _timestampInternal UNIX timestamp\r\n  function setRebalanceInterval(uint256 _timestampInternal) external onlyGuardian {\r\n    rebalanceInterval = _timestampInternal;\r\n  }\r\n\r\n  /// @notice The DAO should be able to blacklist protocols, the funds should be sent to the vault.\r\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\r\n  function blacklistProtocol(uint256 _protocolNum) external onlyGuardian {\r\n    uint256 balanceProtocol = balanceUnderlying(_protocolNum);\r\n    currentAllocations[_protocolNum] = 0;\r\n    controller.setProtocolBlacklist(vaultNumber, _protocolNum);\r\n    savedTotalUnderlying -= balanceProtocol;\r\n    withdrawFromProtocol(_protocolNum, balanceProtocol);\r\n  }\r\n\r\n  /// @notice Set the marginScale, the threshold used for deposits and withdrawals.\r\n  /// @notice If the threshold is not met the deposit/ withdrawal is not executed.\r\n  /// @dev Take into account the uScale (scale of the underlying).\r\n  /// @param _marginScale Value at which to set the marginScale.\r\n  function setMarginScale(int256 _marginScale) external onlyGuardian {\r\n    marginScale = _marginScale;\r\n  }\r\n\r\n  /// @notice Set the liquidityPerc, the amount of liquidity which should be held in the vault after rebalancing.\r\n  /// @dev The actual liquidityPerc could be a bit more or a bit less than the liquidityPerc set here.\r\n  /// @dev This is because some deposits or withdrawals might not execute because they don't meet the marginScale.\r\n  /// @param _liquidityPerc Value at which to set the liquidityPerc.\r\n  function setLiquidityPerc(uint256 _liquidityPerc) external onlyGuardian {\r\n    require(_liquidityPerc <= 100, \"Cannot exceed 100%\");\r\n    liquidityPerc = _liquidityPerc;\r\n  }\r\n\r\n  /// @notice callback to receive Ether from unwrapping WETH\r\n  receive() external payable {\r\n    require(msg.sender == Swap.WETH, \"Not WETH\");\r\n  }\r\n}\r\n"
    },
    "contracts/VaultToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract VaultToken is ERC20 {\r\n  uint8 private decimals_;\r\n\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint8 _decimals\r\n  ) ERC20(_name, _symbol) {\r\n    decimals_ = _decimals;\r\n  }\r\n\r\n  function decimals() public view virtual override returns (uint8) {\r\n    return decimals_;\r\n  }\r\n}\r\n"
    },
    "contracts/libraries/Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../Interfaces/IController.sol\";\r\n\r\nimport \"../Interfaces/ExternalInterfaces/ISwapRouter.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IUniswapV3Factory.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IUniswapV3Pool.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IStableSwap3Pool.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IWETH.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IQuoter.sol\";\r\n\r\nlibrary Swap {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct SwapInOut {\r\n    uint256 amount;\r\n    address tokenIn;\r\n    address tokenOut;\r\n  }\r\n\r\n  address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n  uint256 internal constant gasUsedForSwap = 210000;\r\n\r\n  /// @notice Swap stable coins on Curve\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _tokenInUScale Scale of tokenIn e.g 1E6\r\n  /// @param _tokenOutUScale Scale of tokenOut e.g 1E6\r\n  /// @param _curve Curve pool index number of TokenIn address, tokenOut address, pool address and pool fee\r\n  function swapStableCoins(\r\n    SwapInOut memory _swap,\r\n    uint256 _tokenInUScale,\r\n    uint256 _tokenOutUScale,\r\n    IController.CurveParams memory _curve\r\n  ) public returns (uint256) {\r\n    uint256 amountOutMin = (((_swap.amount * (10000 - _curve.poolFee)) / 10000) * _tokenOutUScale) /\r\n      _tokenInUScale;\r\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_curve.pool, _swap.amount);\r\n\r\n    uint256 balanceBefore = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    IStableSwap3Pool(_curve.pool).exchange(\r\n      _curve.indexTokenIn,\r\n      _curve.indexTokenOut,\r\n      _swap.amount,\r\n      amountOutMin\r\n    );\r\n\r\n    uint256 balanceAfter = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    return balanceAfter - balanceBefore;\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswap Address of uniswapRouter, uniswapQuoter and poolfee\r\n  /// @return Amountout Number of tokens received\r\n  function swapTokensMulti(SwapInOut memory _swap, IController.UniswapParams memory _uniswap)\r\n    public\r\n    returns (uint256)\r\n  {\r\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_uniswap.router, _swap.amount);\r\n\r\n    uint256 amountOutMinimum = IQuoter(_uniswap.quoter).quoteExactInput(\r\n      abi.encodePacked(_swap.tokenIn, _uniswap.poolFee, WETH, _uniswap.poolFee, _swap.tokenOut),\r\n      _swap.amount\r\n    );\r\n\r\n    ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\r\n      path: abi.encodePacked(\r\n        _swap.tokenIn,\r\n        _uniswap.poolFee,\r\n        WETH,\r\n        _uniswap.poolFee,\r\n        _swap.tokenOut\r\n      ),\r\n      recipient: address(this),\r\n      deadline: block.timestamp,\r\n      amountIn: _swap.amount,\r\n      amountOutMinimum: amountOutMinimum\r\n    });\r\n\r\n    uint256 balanceBefore = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n    ISwapRouter(_uniswap.router).exactInput(params);\r\n    uint256 balanceAfter = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n\r\n    return balanceAfter - balanceBefore;\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswap Address of uniswapRouter, uniswapQuoter and poolfee\r\n  /// @return Amountout Number of tokens received\r\n  function swapTokensSingle(SwapInOut memory _swap, IController.UniswapParams memory _uniswap)\r\n    public\r\n    returns (uint256)\r\n  {\r\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_uniswap.router, _swap.amount);\r\n\r\n    uint256 amountOutMinimum = amountOutSingleSwap(\r\n      SwapInOut(_swap.amount, _swap.tokenIn, _swap.tokenOut),\r\n      _uniswap.quoter,\r\n      _uniswap.poolFee\r\n    );\r\n\r\n    ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\r\n      tokenIn: _swap.tokenIn,\r\n      tokenOut: _swap.tokenOut,\r\n      fee: _uniswap.poolFee,\r\n      recipient: address(this),\r\n      deadline: block.timestamp,\r\n      amountIn: _swap.amount,\r\n      amountOutMinimum: amountOutMinimum,\r\n      sqrtPriceLimitX96: 0\r\n    });\r\n\r\n    // The call to `exactInputSingle` executes the swap.\r\n    return ISwapRouter(_uniswap.router).exactInputSingle(params);\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswapQuoter Address of uniswapQuoter\r\n  /// @param _poolFee Current uniswap pool fee set in router e.g 3000\r\n  /// @return amountOutMin minimum amount out of tokens to receive when executing swap\r\n  function amountOutSingleSwap(\r\n    SwapInOut memory _swap,\r\n    address _uniswapQuoter,\r\n    uint24 _poolFee\r\n  ) public returns (uint256) {\r\n    return\r\n      IQuoter(_uniswapQuoter).quoteExactInputSingle(\r\n        _swap.tokenIn,\r\n        _swap.tokenOut,\r\n        _poolFee,\r\n        _swap.amount,\r\n        0\r\n      );\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap Multi route\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswapQuoter Address of uniswapQuoter\r\n  /// @param _poolFee Current uniswap pool fee set in router e.g 3000\r\n  /// @return amountOutMin minimum amount out of tokens to receive when executing swap\r\n  function amountOutMultiSwap(\r\n    SwapInOut memory _swap,\r\n    address _uniswapQuoter,\r\n    uint24 _poolFee\r\n  ) public returns (uint256) {\r\n    return\r\n      IQuoter(_uniswapQuoter).quoteExactInput(\r\n        abi.encodePacked(_swap.tokenIn, _poolFee, WETH, _poolFee, _swap.tokenOut),\r\n        _swap.amount\r\n      );\r\n  }\r\n\r\n  /// @notice Will unwrap WETH and send to DAO / governed address\r\n  /// @param _governed DAO / governed address\r\n  /// @param _amount amount to unwrap and transfer\r\n  function unWrapWETHtoGov(address payable _governed, uint256 _amount) internal {\r\n    IWETH9(WETH).withdraw(_amount);\r\n    (bool sent, ) = _governed.call{value: _amount}(\"\");\r\n    require(sent, \"Ether not sent\");\r\n  }\r\n}\r\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/Interfaces/ExternalInterfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface ISwapRouter {\r\n  struct ExactInputSingleParams {\r\n    address tokenIn;\r\n    address tokenOut;\r\n    uint24 fee;\r\n    address recipient;\r\n    uint256 deadline;\r\n    uint256 amountIn;\r\n    uint256 amountOutMinimum;\r\n    uint160 sqrtPriceLimitX96;\r\n  }\r\n\r\n  /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n  /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n  /// @return amountOut The amount of the received token\r\n  function exactInputSingle(ISwapRouter.ExactInputSingleParams memory params)\r\n    external\r\n    returns (uint256 amountOut);\r\n\r\n  struct ExactInputParams {\r\n    bytes path;\r\n    address recipient;\r\n    uint256 deadline;\r\n    uint256 amountIn;\r\n    uint256 amountOutMinimum;\r\n  }\r\n\r\n  /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n  /// @return amountOut The amount of the received token\r\n  function exactInput(ExactInputParams calldata params)\r\n    external\r\n    payable\r\n    returns (uint256 amountOut);\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IUniswapV3Factory {\r\n  function getPool(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint24 fee\r\n  ) external view returns (address pool);\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IUniswapV3Pool {\r\n  /// @notice The first of the two tokens of the pool, sorted by address\r\n  /// @return The token contract address\r\n  function token0() external view returns (address);\r\n\r\n  /// @notice The second of the two tokens of the pool, sorted by address\r\n  /// @return The token contract address\r\n  function token1() external view returns (address);\r\n\r\n  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\r\n  /// when accessed externally.\r\n  /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\r\n  /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\r\n  /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\r\n  /// boundary.\r\n  /// observationIndex The index of the last oracle observation that was written,\r\n  /// observationCardinality The current maximum number of observations stored in the pool,\r\n  /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\r\n  /// feeProtocol The protocol fee for both tokens of the pool.\r\n  /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\r\n  /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\r\n  /// unlocked Whether the pool is currently locked to reentrancy\r\n  function slot0()\r\n    external\r\n    view\r\n    returns (\r\n      uint160 sqrtPriceX96,\r\n      int24 tick,\r\n      uint16 observationIndex,\r\n      uint16 observationCardinality,\r\n      uint16 observationCardinalityNext,\r\n      uint8 feeProtocol,\r\n      bool unlocked\r\n    );\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IStableSwap3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IStableSwap3Pool {\r\n  function exchange(\r\n    int128 i,\r\n    int128 j,\r\n    uint256 dx,\r\n    uint256 min_dy\r\n  ) external;\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/// @title Interface for WETH9\r\ninterface IWETH9 is IERC20 {\r\n  /// @notice Deposit ether to get wrapped ether\r\n  function deposit() external payable;\r\n\r\n  /// @notice Withdraw wrapped ether to get ether\r\n  function withdraw(uint256) external;\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IQuoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\n/// @title Quoter Interface\r\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\r\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\r\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\r\ninterface IQuoter {\r\n  /// @notice Returns the amount out received for a given exact input swap without executing the swap\r\n  /// @param path The path of the swap, i.e. each token pair and the pool fee\r\n  /// @param amountIn The amount of the first token to swap\r\n  /// @return amountOut The amount of the last token that would be received\r\n  function quoteExactInput(bytes memory path, uint256 amountIn)\r\n    external\r\n    returns (uint256 amountOut);\r\n\r\n  /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\r\n  /// @param tokenIn The token being swapped in\r\n  /// @param tokenOut The token being swapped out\r\n  /// @param fee The fee of the token pool to consider for the pair\r\n  /// @param amountIn The desired input amount\r\n  /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\r\n  /// @return amountOut The amount of `tokenOut` that would be received\r\n  function quoteExactInputSingle(\r\n    address tokenIn,\r\n    address tokenOut,\r\n    uint24 fee,\r\n    uint256 amountIn,\r\n    uint160 sqrtPriceLimitX96\r\n  ) external returns (uint256 amountOut);\r\n}\r\n"
    },
    "contracts/Tests/FeeTestContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"../MainVault.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract FeeTestContract is MainVault {\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint8 _decimals,\r\n    string memory _vaultName,\r\n    uint256 _vaultNumber,\r\n    address _governed,\r\n    address _Game,\r\n    address _router,\r\n    address _vaultCurrency,\r\n    uint256 _uScale,\r\n    uint256 _gasFeeLiquidity\r\n  )\r\n    MainVault(\r\n      _name,\r\n      _symbol,\r\n      _decimals,\r\n      _vaultNumber,\r\n      _governed,\r\n      _Game,\r\n      _router,\r\n      _vaultCurrency,\r\n      _uScale,\r\n      _gasFeeLiquidity\r\n    )\r\n  {}\r\n\r\n  uint256 public latestProtocol;\r\n\r\n  uint256 private testmooi = 12;\r\n\r\n  uint256[] public protocolsInETF;\r\n\r\n  mapping(uint256 => int256) private test;\r\n\r\n  function loopArray() public {\r\n    for (uint i = 0; i < protocolsInETF.length; i++) {\r\n      int256 amount = currentAllocations[protocolsInETF[i]];\r\n      test[i] = amount;\r\n    }\r\n  }\r\n\r\n  function loopMapping() public {\r\n    for (uint i = 0; i <= latestProtocol; i++) {\r\n      int256 amount = currentAllocations[i];\r\n      if (amount == 0) continue;\r\n      test[i] = amount;\r\n    }\r\n  }\r\n\r\n  function setArray(uint256 _protocol) public {\r\n    protocolsInETF.push(_protocol);\r\n  }\r\n\r\n  function setMapping(uint256 _protocol, int256 _amount) public {\r\n    currentAllocations[_protocol] = _amount;\r\n  }\r\n\r\n  function setLatestProtol(uint256 _amount) public {\r\n    latestProtocol = _amount;\r\n  }\r\n\r\n  function deleteArray() public {\r\n    delete protocolsInETF;\r\n  }\r\n}\r\n"
    },
    "contracts/Mocks/MainVaultMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"../MainVault.sol\";\r\n\r\ncontract MainVaultMock is MainVault {\r\n  mapping(uint256 => uint256) private players;\r\n\r\n  event MinAmountOut(uint256 minAmountOut);\r\n\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint8 _decimals,\r\n    uint256 _vaultNumber,\r\n    address _dao,\r\n    address _Game,\r\n    address _controller,\r\n    address _vaultCurrency,\r\n    uint256 _uScale,\r\n    uint256 _gasFeeLiquidity\r\n  )\r\n    MainVault(\r\n      _name,\r\n      _symbol,\r\n      _decimals,\r\n      _vaultNumber,\r\n      _dao,\r\n      _Game,\r\n      _controller,\r\n      _vaultCurrency,\r\n      _uScale,\r\n      _gasFeeLiquidity\r\n    )\r\n  {}\r\n\r\n  function getAllocationTEST(uint256 _protocolNum) external view returns (int256) {\r\n    return currentAllocations[_protocolNum];\r\n  }\r\n\r\n  function getDeltaAllocationTEST(uint256 _protocolNum) external view returns (int256) {\r\n    return deltaAllocations[_protocolNum];\r\n  }\r\n\r\n  function setDeltaAllocations(uint256 _protocolNum, int256 _allocation) external {\r\n    return setDeltaAllocationsInt(_protocolNum, _allocation);\r\n  }\r\n\r\n  function setDeltaAllocationsReceivedTEST(bool _state) external {\r\n    deltaAllocationsReceived = _state;\r\n  }\r\n\r\n  function setTotalAllocatedTokensTest(int256 _tokens) external {\r\n    totalAllocatedTokens = _tokens;\r\n  }\r\n\r\n  function setAmountToSendXChainTEST(uint256 _amount) external {\r\n    amountToSendXChain = _amount;\r\n  }\r\n\r\n  function getLastPriceTEST(uint256 _protocolId) external view returns (uint256) {\r\n    return lastPrices[_protocolId];\r\n  }\r\n\r\n  function balanceSharesTEST(uint256 _protocolNum, address _address)\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    IController.ProtocolInfoS memory p = controller.getProtocolInfo(vaultNumber, _protocolNum);\r\n    uint256 balance = IProvider(p.provider).balance(_address, p.LPToken);\r\n\r\n    return balance;\r\n  }\r\n\r\n  function getWithdrawalAllowanceTEST(address _address) external view returns (uint256) {\r\n    return withdrawalAllowance[_address];\r\n  }\r\n\r\n  function getRewardAllowanceTEST(address _address) external view returns (uint256) {\r\n    return rewardAllowance[_address];\r\n  }\r\n\r\n  function getTotalWithdrawalRequestsTEST() external view returns (uint256) {\r\n    return totalWithdrawalRequests;\r\n  }\r\n\r\n  function getReservedFundsTEST() external view returns (uint256) {\r\n    return reservedFunds;\r\n  }\r\n\r\n  function setExchangeRateTEST(uint256 _exchangeRate) external {\r\n    exchangeRate = _exchangeRate;\r\n  }\r\n\r\n  function setReservedFundsTEST(uint256 _amount) external {\r\n    reservedFunds = _amount;\r\n  }\r\n\r\n  function upRebalancingPeriodTEST() external {\r\n    rebalancingPeriod++;\r\n  }\r\n\r\n  function setCurrentAllocation(uint256 _protocolNum, int256 _allocation) external {\r\n    currentAllocations[_protocolNum] = _allocation;\r\n  }\r\n\r\n  function resetDeltaAllocations(uint256 _protocolNum) external {\r\n    deltaAllocations[_protocolNum] = 0;\r\n  }\r\n\r\n  function clearCurrencyBalance(uint256 _balance) external {\r\n    vaultCurrency.transfer(getDao(), _balance);\r\n  }\r\n\r\n  function toggleVaultOnOffTEST(bool _state) external {\r\n    vaultOff = _state;\r\n  }\r\n\r\n  function swapTokensMultiTest(\r\n    uint256 _amount,\r\n    address _tokenIn,\r\n    address _tokenOut\r\n  ) external returns (uint256) {\r\n    return\r\n      Swap.swapTokensMulti(\r\n        Swap.SwapInOut(_amount, _tokenIn, _tokenOut),\r\n        controller.getUniswapParams()\r\n      );\r\n  }\r\n\r\n  function swapMinAmountOutMultiTest(\r\n    uint256 _amount,\r\n    address _tokenIn,\r\n    address _tokenOut\r\n  ) external {\r\n    uint256 minAmountOut = Swap.amountOutMultiSwap(\r\n      Swap.SwapInOut(_amount, _tokenIn, _tokenOut),\r\n      controller.getUniswapQuoter(),\r\n      controller.getUniswapPoolFee()\r\n    );\r\n\r\n    emit MinAmountOut(minAmountOut);\r\n  }\r\n\r\n  function curveSwapTest(\r\n    uint256 _amount,\r\n    address _tokenIn,\r\n    address _tokenOut\r\n  ) external {\r\n    Swap.swapStableCoins(\r\n      Swap.SwapInOut(_amount, _tokenIn, _tokenOut),\r\n      uScale,\r\n      1000000000000000000,\r\n      controller.getCurveParams(_tokenIn, _tokenOut)\r\n    );\r\n  }\r\n\r\n  function testLargeGameplayerSet(uint256 _amountOfPlayers) public {\r\n    for (uint256 i = 0; i < _amountOfPlayers; i++) {\r\n      players[i] = exchangeRate;\r\n    }\r\n  }\r\n\r\n  function setVaultState(uint256 _state) external {\r\n    if (_state == 0) state = State.Idle;\r\n    if (_state == 1) state = State.SendingFundsXChain;\r\n    if (_state == 2) state = State.WaitingForFunds;\r\n    if (_state == 3) state = State.RebalanceVault;\r\n  }\r\n\r\n  // function testFormulaWithNRoot(uint256 _g, uint256 _n) public view returns(int128) {\r\n  //   int128 g_casted = ABDKMath64x64.fromUInt(_g);\r\n  //   int128 n_casted = ABDKMath64x64.fromUInt(_n);\r\n  //   int128 log2 = ABDKMath64x64.log_2(g_casted);\r\n  //   int128 endResult = ABDKMath64x64.exp_2(log2 / n_casted);\r\n  //   return endResult;\r\n  // }\r\n}\r\n"
    },
    "contracts/Game.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\nimport \"./DerbyToken.sol\";\r\n\r\nimport \"./Interfaces/IVault.sol\";\r\nimport \"./Interfaces/IController.sol\";\r\nimport \"./Interfaces/IXProvider.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract Game is ERC721, ReentrancyGuard {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct Basket {\r\n    // the vault number for which this Basket was created\r\n    uint256 vaultNumber;\r\n    // last period when this Basket got rebalanced\r\n    uint256 lastRebalancingPeriod;\r\n    // nr of total allocated tokens\r\n    int256 nrOfAllocatedTokens;\r\n    // total build up rewards\r\n    int256 totalUnRedeemedRewards;\r\n    // total redeemed rewards\r\n    int256 totalRedeemedRewards;\r\n    // (basket => vaultNumber => chainId => allocation)\r\n    mapping(uint256 => mapping(uint256 => int256)) allocations;\r\n  }\r\n\r\n  struct vaultInfo {\r\n    // rebalance period of ETF, upped at vault rebalance\r\n    uint256 rebalancingPeriod;\r\n    // (chainId => vaultAddress)\r\n    mapping(uint16 => address) vaultAddress;\r\n    // (chainId => deltaAllocation)\r\n    mapping(uint256 => int256) deltaAllocationChain;\r\n    // (chainId => protocolNumber => deltaAllocation)\r\n    mapping(uint256 => mapping(uint256 => int256)) deltaAllocationProtocol;\r\n    // (chainId => rebalancing period => protocol id => rewardPerLockedToken).\r\n    mapping(uint16 => mapping(uint256 => mapping(uint256 => int256))) rewardPerLockedToken;\r\n  }\r\n\r\n  address private dao;\r\n  address private guardian;\r\n  address public xProvider;\r\n  address public homeVault;\r\n\r\n  IController public controller;\r\n  IERC20 public derbyToken;\r\n\r\n  // latest basket id\r\n  uint256 private latestBasketId;\r\n\r\n  // array of chainIds e.g [10, 100, 1000];\r\n  uint16[] public chainIds;\r\n\r\n  // interval in Unix timeStamp\r\n  uint256 public rebalanceInterval; // SHOULD BE REPLACED FOR REALISTIC NUMBER\r\n\r\n  // last rebalance timeStamp\r\n  uint256 public lastTimeStamp;\r\n\r\n  // threshold in vaultCurrency e.g USDC for when user tokens will be sold / burned. Must be negative\r\n  int256 private negativeRewardThreshold;\r\n  // percentage of tokens that will be sold at negative rewards\r\n  uint256 private negativeRewardFactor;\r\n\r\n  // baskets, maps tokenID from BasketToken NFT contract to the Basket struct in this contract.\r\n  // (basketTokenId => basket struct):\r\n  mapping(uint256 => Basket) private baskets;\r\n\r\n  // (chainId => latestProtocolId): latestProtocolId set by dao\r\n  mapping(uint256 => uint256) public latestProtocolId;\r\n\r\n  // (vaultNumber => vaultInfo struct)\r\n  mapping(uint256 => vaultInfo) internal vaults;\r\n\r\n  // (vaultNumber => bool): true when vault is cross-chain rebalancing\r\n  mapping(uint256 => bool) public isXChainRebalancing;\r\n\r\n  event PushProtocolAllocations(uint16 _chain, address _vault, int256[] _deltas);\r\n\r\n  event PushedAllocationsToController(uint256 _vaultNumber, int256[] _deltas);\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"Game: only DAO\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyBasketOwner(uint256 _basketId) {\r\n    require(msg.sender == ownerOf(_basketId), \"Game: Not the owner of the basket\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyXProvider() {\r\n    require(msg.sender == xProvider, \"Game: only xProvider\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == guardian, \"Game: only Guardian\");\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    string memory name_,\r\n    string memory symbol_,\r\n    address _derbyToken,\r\n    address _dao,\r\n    address _guardian,\r\n    address _controller\r\n  ) ERC721(name_, symbol_) {\r\n    derbyToken = IERC20(_derbyToken);\r\n    controller = IController(_controller);\r\n    dao = _dao;\r\n    guardian = _guardian;\r\n    lastTimeStamp = block.timestamp;\r\n\r\n    negativeRewardFactor = 50;\r\n  }\r\n\r\n  /// @notice Setter for delta allocation in a particulair chainId\r\n  /// @param _vaultNumber number of vault\r\n  /// @param _chainId number of chainId\r\n  /// @param _deltaAllocation delta allocation\r\n  function setDeltaAllocationChain(\r\n    uint256 _vaultNumber,\r\n    uint256 _chainId,\r\n    int256 _deltaAllocation\r\n  ) internal {\r\n    vaults[_vaultNumber].deltaAllocationChain[_chainId] += _deltaAllocation;\r\n  }\r\n\r\n  /// @notice Getter for delta allocation in a particulair chainId\r\n  /// @param _vaultNumber number of vault\r\n  /// @param _chainId number of chainId\r\n  /// @return allocation delta allocation\r\n  function getDeltaAllocationChain(uint256 _vaultNumber, uint256 _chainId)\r\n    internal\r\n    view\r\n    returns (int256)\r\n  {\r\n    return vaults[_vaultNumber].deltaAllocationChain[_chainId];\r\n  }\r\n\r\n  /// @notice Setter for the delta allocation in Protocol vault e.g compound_usdc_01\r\n  /// @dev Allocation can be negative\r\n  /// @param _vaultNumber number of vault\r\n  /// @param _chainId number of chainId\r\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\r\n  /// @param _deltaAllocation Delta allocation in tokens\r\n  function setDeltaAllocationProtocol(\r\n    uint256 _vaultNumber,\r\n    uint256 _chainId,\r\n    uint256 _protocolNum,\r\n    int256 _deltaAllocation\r\n  ) internal {\r\n    vaults[_vaultNumber].deltaAllocationProtocol[_chainId][_protocolNum] += _deltaAllocation;\r\n  }\r\n\r\n  /// @notice Getter for the delta allocation in Protocol vault e.g compound_usdc_01\r\n  /// @param _vaultNumber number of vault\r\n  /// @param _chainId number of chainId\r\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\r\n  /// @return allocation Delta allocation in tokens\r\n  function getDeltaAllocationProtocol(\r\n    uint256 _vaultNumber,\r\n    uint256 _chainId,\r\n    uint256 _protocolNum\r\n  ) internal view returns (int256) {\r\n    return vaults[_vaultNumber].deltaAllocationProtocol[_chainId][_protocolNum];\r\n  }\r\n\r\n  /// @notice Setter to set the total number of allocated tokens. Only the owner of the basket can set this.\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\r\n  /// @param _allocation Number of derby tokens that are allocated towards protocols.\r\n  function setBasketTotalAllocatedTokens(uint256 _basketId, int256 _allocation)\r\n    internal\r\n    onlyBasketOwner(_basketId)\r\n  {\r\n    baskets[_basketId].nrOfAllocatedTokens += _allocation;\r\n    require(basketTotalAllocatedTokens(_basketId) >= 0, \"Basket: underflow\");\r\n  }\r\n\r\n  /// @notice function to see the total number of allocated tokens. Only the owner of the basket can view this.\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\r\n  /// @return int256 Number of derby tokens that are allocated towards protocols.\r\n  function basketTotalAllocatedTokens(uint256 _basketId)\r\n    public\r\n    view\r\n    onlyBasketOwner(_basketId)\r\n    returns (int256)\r\n  {\r\n    return baskets[_basketId].nrOfAllocatedTokens;\r\n  }\r\n\r\n  /// @notice Setter to set the allocation of a specific protocol by a basketId. Only the owner of the basket can set this.\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\r\n  /// @param _chainId number of chainId.\r\n  /// @param _protocolId Id of the protocol of which the allocation is queried.\r\n  /// @param _allocation Number of derby tokens that are allocated towards this specific protocol.\r\n  function setBasketAllocationInProtocol(\r\n    uint256 _basketId,\r\n    uint256 _chainId,\r\n    uint256 _protocolId,\r\n    int256 _allocation\r\n  ) internal onlyBasketOwner(_basketId) {\r\n    baskets[_basketId].allocations[_chainId][_protocolId] += _allocation;\r\n    require(basketAllocationInProtocol(_basketId, _chainId, _protocolId) >= 0, \"Basket: underflow\");\r\n  }\r\n\r\n  /// @notice function to see the allocation of a specific protocol by a basketId. Only the owner of the basket can view this\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\r\n  /// @param _chainId number of chainId\r\n  /// @param _protocolId Id of the protocol of which the allocation is queried\r\n  /// @return int256 Number of derby tokens that are allocated towards this specific protocol\r\n  function basketAllocationInProtocol(\r\n    uint256 _basketId,\r\n    uint256 _chainId,\r\n    uint256 _protocolId\r\n  ) public view onlyBasketOwner(_basketId) returns (int256) {\r\n    return baskets[_basketId].allocations[_chainId][_protocolId];\r\n  }\r\n\r\n  /// @notice Setter for rebalancing period of the basket, used to calculate the rewards\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\r\n  /// @param _vaultNumber number of vault\r\n  function setBasketRebalancingPeriod(uint256 _basketId, uint256 _vaultNumber)\r\n    internal\r\n    onlyBasketOwner(_basketId)\r\n  {\r\n    baskets[_basketId].lastRebalancingPeriod = vaults[_vaultNumber].rebalancingPeriod + 1;\r\n  }\r\n\r\n  /// @notice function to see the total unredeemed rewards the basket has built up. Only the owner of the basket can view this.\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\r\n  /// @return int256 Total unredeemed rewards.\r\n  function basketUnredeemedRewards(uint256 _basketId)\r\n    external\r\n    view\r\n    onlyBasketOwner(_basketId)\r\n    returns (int256)\r\n  {\r\n    return baskets[_basketId].totalUnRedeemedRewards;\r\n  }\r\n\r\n  /// @notice function to see the total reeemed rewards from the basket. Only the owner of the basket can view this.\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\r\n  /// @return int256 Total redeemed rewards.\r\n  function basketRedeemedRewards(uint256 _basketId)\r\n    external\r\n    view\r\n    onlyBasketOwner(_basketId)\r\n    returns (int)\r\n  {\r\n    return baskets[_basketId].totalRedeemedRewards;\r\n  }\r\n\r\n  /// @notice Mints a new NFT with a Basket of allocations.\r\n  /// @dev The basket NFT is minted for a specific vault, starts with a zero allocation and the tokens are not locked here.\r\n  /// @param _vaultNumber Number of the vault. Same as in Router.\r\n  /// @return basketId The basket Id the user has minted.\r\n  function mintNewBasket(uint256 _vaultNumber) external returns (uint256) {\r\n    // mint Basket with nrOfUnAllocatedTokens equal to _lockedTokenAmount\r\n    baskets[latestBasketId].vaultNumber = _vaultNumber;\r\n    baskets[latestBasketId].lastRebalancingPeriod = vaults[_vaultNumber].rebalancingPeriod + 1;\r\n    _safeMint(msg.sender, latestBasketId);\r\n    latestBasketId++;\r\n    return latestBasketId - 1;\r\n  }\r\n\r\n  /// @notice Function to lock xaver tokens to a basket. They start out to be unallocated.\r\n  /// @param _lockedTokenAmount Amount of xaver tokens to lock inside this contract.\r\n  function lockTokensToBasket(uint256 _lockedTokenAmount) internal {\r\n    uint256 balanceBefore = derbyToken.balanceOf(address(this));\r\n    derbyToken.safeTransferFrom(msg.sender, address(this), _lockedTokenAmount);\r\n    uint256 balanceAfter = derbyToken.balanceOf(address(this));\r\n\r\n    require((balanceAfter - balanceBefore - _lockedTokenAmount) == 0, \"Error lock: under/overflow\");\r\n  }\r\n\r\n  /// @notice Function to unlock xaver tokens. If tokens are still allocated to protocols they first hevae to be unallocated.\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\r\n  /// @param _unlockedTokenAmount Amount of derby tokens to unlock and send to the user.\r\n  function unlockTokensFromBasket(uint256 _basketId, uint256 _unlockedTokenAmount) internal {\r\n    uint256 tokensBurned = redeemNegativeRewards(_basketId, _unlockedTokenAmount);\r\n    uint256 tokensToUnlock = _unlockedTokenAmount -= tokensBurned;\r\n\r\n    uint256 balanceBefore = derbyToken.balanceOf(address(this));\r\n    derbyToken.safeTransfer(msg.sender, tokensToUnlock);\r\n    uint256 balanceAfter = derbyToken.balanceOf(address(this));\r\n\r\n    require((balanceBefore - balanceAfter - tokensToUnlock) == 0, \"Error unlock: under/overflow\");\r\n  }\r\n\r\n  /// @notice IMPORTANT: The negativeRewardFactor takes in account an approximation of the price of derby tokens by the dao\r\n  /// @notice IMPORTANT: This will change to an exact price when there is a derby token liquidity pool\r\n  /// @notice Calculates if there are any negative rewards and how many tokens to burn\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\r\n  /// @param _unlockedTokens Amount of derby tokens to unlock and send to user\r\n  /// @return tokensToBurn Amount of derby tokens that are burned\r\n  function redeemNegativeRewards(uint256 _basketId, uint256 _unlockedTokens)\r\n    internal\r\n    returns (uint256)\r\n  {\r\n    int256 unredeemedRewards = baskets[_basketId].totalUnRedeemedRewards;\r\n    if (unredeemedRewards > negativeRewardThreshold) return 0;\r\n\r\n    uint256 tokensToBurn = (uint(-unredeemedRewards) * negativeRewardFactor) / 100;\r\n    tokensToBurn = tokensToBurn < _unlockedTokens ? tokensToBurn : _unlockedTokens;\r\n\r\n    baskets[_basketId].totalUnRedeemedRewards += int((tokensToBurn * 100) / negativeRewardFactor);\r\n\r\n    IERC20(derbyToken).safeTransfer(homeVault, tokensToBurn);\r\n\r\n    return tokensToBurn;\r\n  }\r\n\r\n  /// @notice rebalances an existing Basket\r\n  /// @dev First calculates the rewards the basket has built up, then sets the new allocations and communicates the deltas to the vault\r\n  /// @dev Finally it locks or unlocks tokens\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\r\n  /// @param _deltaAllocations delta allocations set by the user of the basket. Allocations are scaled (so * 1E18).\r\n  function rebalanceBasket(uint256 _basketId, int256[][] memory _deltaAllocations)\r\n    external\r\n    onlyBasketOwner(_basketId)\r\n    nonReentrant\r\n  {\r\n    uint256 vaultNumber = baskets[_basketId].vaultNumber;\r\n    require(!isXChainRebalancing[vaultNumber], \"Game: vault is xChainRebalancing\");\r\n\r\n    addToTotalRewards(_basketId);\r\n    int256 totalDelta = settleDeltaAllocations(_basketId, vaultNumber, _deltaAllocations);\r\n\r\n    lockOrUnlockTokens(_basketId, totalDelta);\r\n    setBasketTotalAllocatedTokens(_basketId, totalDelta);\r\n    setBasketRebalancingPeriod(_basketId, vaultNumber);\r\n  }\r\n\r\n  /// @notice Internal helper to calculate and settle the delta allocations from baskets\r\n  /// @dev Sets the total allocations per ChainId, used in XChainController\r\n  /// @dev Sets the total allocations per protocol number, used in Vaults\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\r\n  /// @param _vaultNumber number of vault\r\n  /// @param _deltaAllocations delta allocations set by the user of the basket. Allocations are scaled (so * 1E18)\r\n  /// @return totalDelta total delta allocated tokens of the basket, used in lockOrUnlockTokens\r\n  function settleDeltaAllocations(\r\n    uint256 _basketId,\r\n    uint256 _vaultNumber,\r\n    int256[][] memory _deltaAllocations\r\n  ) internal returns (int256 totalDelta) {\r\n    for (uint256 i = 0; i < _deltaAllocations.length; i++) {\r\n      int256 chainTotal;\r\n      uint16 chain = chainIds[i];\r\n      uint256 latestProtocol = latestProtocolId[chain];\r\n\r\n      require(_deltaAllocations[i].length == latestProtocol, \"Invalid allocation length\");\r\n\r\n      for (uint256 j = 0; j < latestProtocol; j++) {\r\n        int256 allocation = _deltaAllocations[i][j];\r\n        if (allocation == 0) continue;\r\n        chainTotal += allocation;\r\n        setDeltaAllocationProtocol(_vaultNumber, chain, j, allocation);\r\n        setBasketAllocationInProtocol(_basketId, chain, j, allocation);\r\n      }\r\n\r\n      totalDelta += chainTotal;\r\n      setDeltaAllocationChain(_vaultNumber, chain, chainTotal);\r\n    }\r\n  }\r\n\r\n  /// @notice rewards are calculated here.\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\r\n  function addToTotalRewards(uint256 _basketId) internal onlyBasketOwner(_basketId) {\r\n    if (baskets[_basketId].nrOfAllocatedTokens == 0) return;\r\n\r\n    uint256 vaultNum = baskets[_basketId].vaultNumber;\r\n    uint256 currentRebalancingPeriod = vaults[vaultNum].rebalancingPeriod;\r\n    uint256 lastRebalancingPeriod = baskets[_basketId].lastRebalancingPeriod;\r\n\r\n    if (currentRebalancingPeriod <= lastRebalancingPeriod) return;\r\n\r\n    for (uint k = 0; k < chainIds.length; k++) {\r\n      uint16 chain = chainIds[k];\r\n      uint256 latestProtocol = latestProtocolId[chain];\r\n      for (uint i = 0; i < latestProtocol; i++) {\r\n        int256 allocation = basketAllocationInProtocol(_basketId, chain, i) / 1E18;\r\n        if (allocation == 0) continue;\r\n\r\n        int256 lastRebalanceReward = getRewardsPerLockedToken(\r\n          vaultNum,\r\n          chain,\r\n          lastRebalancingPeriod,\r\n          i\r\n        );\r\n        int256 currentReward = getRewardsPerLockedToken(\r\n          vaultNum,\r\n          chain,\r\n          currentRebalancingPeriod,\r\n          i\r\n        );\r\n        baskets[_basketId].totalUnRedeemedRewards +=\r\n          (currentReward - lastRebalanceReward) *\r\n          allocation;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice Internal helper to lock or unlock tokens from the game contract\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\r\n  /// @param _totalDelta total delta allocated tokens of the basket, calculated in settleDeltaAllocations\r\n  function lockOrUnlockTokens(uint256 _basketId, int256 _totalDelta) internal {\r\n    if (_totalDelta > 0) {\r\n      lockTokensToBasket(uint256(_totalDelta));\r\n    }\r\n    if (_totalDelta < 0) {\r\n      int256 oldTotal = basketTotalAllocatedTokens(_basketId);\r\n      int256 newTotal = oldTotal + _totalDelta;\r\n      int256 tokensToUnlock = oldTotal - newTotal;\r\n      require(oldTotal >= tokensToUnlock, \"Not enough tokens locked\");\r\n\r\n      unlockTokensFromBasket(_basketId, uint256(tokensToUnlock));\r\n    }\r\n  }\r\n\r\n  /// @notice Step 1 trigger; Game pushes totalDeltaAllocations to xChainController\r\n  /// @notice Trigger for Dao to push delta allocations to the xChainController\r\n  /// @dev Sends over an array that should match the IDs in chainIds array\r\n  function pushAllocationsToController(uint256 _vaultNumber) external {\r\n    require(rebalanceNeeded(), \"No rebalance needed\");\r\n    require(!isXChainRebalancing[_vaultNumber], \"Vault is already rebalancing\");\r\n    isXChainRebalancing[_vaultNumber] = true;\r\n\r\n    int256[] memory deltas = allocationsToArray(_vaultNumber);\r\n    IXProvider(xProvider).pushAllocations(_vaultNumber, deltas);\r\n\r\n    lastTimeStamp = block.timestamp;\r\n\r\n    emit PushedAllocationsToController(_vaultNumber, deltas);\r\n  }\r\n\r\n  /// @notice Creates delta allocation array for chains matching IDs in chainIds array\r\n  /// @notice Resets deltaAllocation for chainIds\r\n  /// @return deltas Array with delta Allocations for all chainIds\r\n  function allocationsToArray(uint256 _vaultNumber) internal returns (int256[] memory deltas) {\r\n    deltas = new int[](chainIds.length);\r\n\r\n    for (uint256 i = 0; i < chainIds.length; i++) {\r\n      uint16 chain = chainIds[i];\r\n      deltas[i] = getDeltaAllocationChain(_vaultNumber, chain);\r\n      vaults[_vaultNumber].deltaAllocationChain[chain] = 0;\r\n    }\r\n  }\r\n\r\n  /// @notice Step 6 trigger; Game pushes deltaAllocations to vaults\r\n  /// @notice Trigger to push delta allocations in protocols to cross chain vaults\r\n  /// @dev Sends over an array where the index is the protocolId\r\n  function pushAllocationsToVaults(uint256 _vaultNumber) external {\r\n    require(isXChainRebalancing[_vaultNumber], \"Vault is not rebalancing\");\r\n\r\n    for (uint256 i = 0; i < chainIds.length; i++) {\r\n      uint16 chain = chainIds[i];\r\n      int256[] memory deltas = protocolAllocationsToArray(_vaultNumber, chain);\r\n\r\n      IXProvider(xProvider).pushProtocolAllocationsToVault(\r\n        chain,\r\n        getVaultAddress(_vaultNumber, chain),\r\n        deltas\r\n      );\r\n\r\n      emit PushProtocolAllocations(chain, getVaultAddress(_vaultNumber, chain), deltas);\r\n    }\r\n\r\n    vaults[_vaultNumber].rebalancingPeriod++;\r\n    isXChainRebalancing[_vaultNumber] = false;\r\n  }\r\n\r\n  /// @notice Creates array with delta allocations in protocols for given chainId\r\n  /// @return deltas Array with allocations where the index matches the protocolId\r\n  function protocolAllocationsToArray(uint256 _vaultNumber, uint16 _chainId)\r\n    internal\r\n    returns (int256[] memory deltas)\r\n  {\r\n    uint256 latestId = latestProtocolId[_chainId];\r\n    deltas = new int[](latestId);\r\n\r\n    for (uint256 i = 0; i < latestId; i++) {\r\n      deltas[i] = getDeltaAllocationProtocol(_vaultNumber, _chainId, i);\r\n      // allocation to zero\r\n      setDeltaAllocationProtocol(_vaultNumber, _chainId, i, 0);\r\n    }\r\n  }\r\n\r\n  /// @notice See settleRewardsInt below\r\n  function settleRewards(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    int256[] memory _rewards\r\n  ) external onlyXProvider {\r\n    settleRewardsInt(_vaultNumber, _chainId, _rewards);\r\n  }\r\n\r\n  // basket should not be able to rebalance before this step\r\n  /// @notice Step 8 end; Vaults push rewardsPerLockedToken to game\r\n  /// @notice Loops through the array and fills the rewardsPerLockedToken mapping with the values\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\r\n  function settleRewardsInt(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    int256[] memory _rewards\r\n  ) internal {\r\n    uint256 rebalancingPeriod = vaults[_vaultNumber].rebalancingPeriod;\r\n\r\n    for (uint256 i = 0; i < _rewards.length; i++) {\r\n      int256 lastReward = getRewardsPerLockedToken(\r\n        _vaultNumber,\r\n        _chainId,\r\n        rebalancingPeriod - 1,\r\n        i\r\n      );\r\n      vaults[_vaultNumber].rewardPerLockedToken[_chainId][rebalancingPeriod][i] =\r\n        lastReward +\r\n        _rewards[i];\r\n    }\r\n  }\r\n\r\n  /// @notice Getter for rewardsPerLockedToken for given vaultNumber => chainId => rebalancingPeriod => protocolId\r\n  function getRewardsPerLockedToken(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _rebalancingPeriod,\r\n    uint256 _protocolId\r\n  ) internal view returns (int256) {\r\n    return vaults[_vaultNumber].rewardPerLockedToken[_chainId][_rebalancingPeriod][_protocolId];\r\n  }\r\n\r\n  /// @notice redeem funds from basket in the game.\r\n  /// @dev makes a call to the vault to make the actual transfer because the vault holds the funds.\r\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\r\n  function redeemRewards(uint256 _basketId) external onlyBasketOwner(_basketId) {\r\n    int256 amount = baskets[_basketId].totalUnRedeemedRewards;\r\n    require(amount > 0, \"Nothing to claim\");\r\n\r\n    baskets[_basketId].totalRedeemedRewards += amount;\r\n    baskets[_basketId].totalUnRedeemedRewards = 0;\r\n\r\n    IVault(homeVault).redeemRewardsGame(uint256(amount), msg.sender);\r\n  }\r\n\r\n  /// @notice Checks if a rebalance is needed based on the set interval\r\n  /// @return bool True of rebalance is needed, false if not\r\n  function rebalanceNeeded() public view returns (bool) {\r\n    return (block.timestamp - lastTimeStamp) > rebalanceInterval;\r\n  }\r\n\r\n  /// @notice getter for vault address linked to a chainId\r\n  function getVaultAddress(uint256 _vaultNumber, uint16 _chainId) internal view returns (address) {\r\n    return vaults[_vaultNumber].vaultAddress[_chainId];\r\n  }\r\n\r\n  /// @notice Getter for dao address\r\n  function getDao() public view returns (address) {\r\n    return dao;\r\n  }\r\n\r\n  /// @notice Getter for guardian address\r\n  function getGuardian() public view returns (address) {\r\n    return guardian;\r\n  }\r\n\r\n  /*\r\n  Only Dao functions\r\n  */\r\n\r\n  /// @notice Setter for xProvider address\r\n  /// @param _xProvider new address of xProvider on this chain\r\n  function setXProvider(address _xProvider) external onlyDao {\r\n    xProvider = _xProvider;\r\n  }\r\n\r\n  /// @notice Setter for homeVault address\r\n  /// @param _homeVault new address of homeVault on this chain\r\n  function setHomeVault(address _homeVault) external onlyDao {\r\n    homeVault = _homeVault;\r\n  }\r\n\r\n  /// @notice Set minimum interval for the rebalance function\r\n  /// @param _timestampInternal UNIX timestamp\r\n  function setRebalanceInterval(uint256 _timestampInternal) external onlyDao {\r\n    rebalanceInterval = _timestampInternal;\r\n  }\r\n\r\n  /// @notice Setter for DAO address\r\n  /// @param _dao DAO address\r\n  function setDao(address _dao) external onlyDao {\r\n    dao = _dao;\r\n  }\r\n\r\n  /// @notice Setter for guardian address\r\n  /// @param _guardian new address of the guardian\r\n  function setGuardian(address _guardian) external onlyDao {\r\n    guardian = _guardian;\r\n  }\r\n\r\n  /// @notice Setter Derby token address\r\n  /// @param _derbyToken new address of Derby token\r\n  function setDerbyToken(address _derbyToken) external onlyDao {\r\n    derbyToken = IERC20(_derbyToken);\r\n  }\r\n\r\n  /// @notice Setter for threshold at which user tokens will be sold / burned\r\n  /// @param _threshold treshold in vaultCurrency e.g USDC, must be negative\r\n  function setNegativeRewardThreshold(int256 _threshold) external onlyDao {\r\n    negativeRewardThreshold = _threshold;\r\n  }\r\n\r\n  /// @notice Setter for negativeRewardFactor\r\n  /// @param _factor percentage of tokens that will be sold / burned\r\n  function setNegativeRewardFactor(uint256 _factor) external onlyDao {\r\n    negativeRewardFactor = _factor;\r\n  }\r\n\r\n  /*\r\n  Only Guardian functions\r\n  */\r\n\r\n  /// @notice setter to link a chainId to a vault address for cross chain functions\r\n  function setVaultAddress(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    address _address\r\n  ) external onlyGuardian {\r\n    vaults[_vaultNumber].vaultAddress[_chainId] = _address;\r\n  }\r\n\r\n  /// @notice Setter for latest protocol Id for given chainId.\r\n  /// @param _chainId number of chain id set in chainIds array\r\n  /// @param _latestProtocolId latest protocol Id aka number of supported protocol vaults, starts at 0\r\n  function setLatestProtocolId(uint16 _chainId, uint256 _latestProtocolId) external onlyGuardian {\r\n    latestProtocolId[_chainId] = _latestProtocolId;\r\n  }\r\n\r\n  /// @notice Setter for chainId array\r\n  /// @param _chainIds array of all the used chainIds\r\n  function setChainIds(uint16[] memory _chainIds) external onlyGuardian {\r\n    chainIds = _chainIds;\r\n  }\r\n\r\n  /// @notice Guardian function to set state when vault gets stuck for whatever reason\r\n  function setRebalancingState(uint256 _vaultNumber, bool _state) external onlyGuardian {\r\n    isXChainRebalancing[_vaultNumber] = _state;\r\n  }\r\n\r\n  /// @notice Step 8: Guardian function\r\n  function settleRewardsGuard(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    int256[] memory _rewards\r\n  ) external onlyGuardian {\r\n    settleRewardsInt(_vaultNumber, _chainId, _rewards);\r\n  }\r\n}\r\n"
    },
    "contracts/DerbyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract DerbyToken is ERC20 {\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint256 _totalSupply\r\n  ) ERC20(_name, _symbol) {\r\n    _mint(msg.sender, _totalSupply);\r\n  }\r\n}\r\n"
    },
    "contracts/Mocks/GameMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"../Game.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract GameMock is Game {\r\n  constructor(\r\n    string memory name_,\r\n    string memory symbol_,\r\n    address _derbyTokenAddress,\r\n    address _dao,\r\n    address _guardian,\r\n    address _controller\r\n  ) Game(name_, symbol_, _derbyTokenAddress, _dao, _guardian, _controller) {}\r\n\r\n  function lockTokensToBasketTEST(uint256 _lockedTokenAmount) public {\r\n    lockTokensToBasket(_lockedTokenAmount);\r\n  }\r\n\r\n  function addToTotalRewardsTEST(uint256 _basketId) public {\r\n    addToTotalRewards(_basketId);\r\n  }\r\n\r\n  function setDeltaAllocations(\r\n    address _vault,\r\n    uint256 _protocolNum,\r\n    int256 _allocation\r\n  ) external {\r\n    IVault(_vault).setDeltaAllocations(_protocolNum, _allocation);\r\n  }\r\n\r\n  function setXChainRebalanceState(uint256 _vaultNumber, bool _state) external {\r\n    isXChainRebalancing[_vaultNumber] = _state;\r\n  }\r\n\r\n  function triggerRedeemedRewardsVault(\r\n    address _vault,\r\n    address user,\r\n    uint256 amount\r\n  ) external {\r\n    IVault(_vault).redeemRewardsGame(amount, user);\r\n  }\r\n\r\n  function upRebalancingPeriod(uint256 _vaultNumber) external {\r\n    vaults[_vaultNumber].rebalancingPeriod++;\r\n  }\r\n\r\n  function getDeltaAllocationChainTEST(uint256 _ETFNumber, uint256 _chainId)\r\n    external\r\n    view\r\n    returns (int256)\r\n  {\r\n    return getDeltaAllocationChain(_ETFNumber, _chainId);\r\n  }\r\n\r\n  function getDeltaAllocationProtocolTEST(\r\n    uint256 _ETFNumber,\r\n    uint256 _chainId,\r\n    uint256 _protocolNum\r\n  ) external view returns (int256) {\r\n    return getDeltaAllocationProtocol(_ETFNumber, _chainId, _protocolNum);\r\n  }\r\n\r\n  function mockRewards(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    int256[] memory _rewards\r\n  ) external {\r\n    uint256 rebalancingPeriod = vaults[_vaultNumber].rebalancingPeriod;\r\n\r\n    for (uint256 i = 0; i < _rewards.length; i++) {\r\n      int256 lastReward = getRewardsPerLockedToken(\r\n        _vaultNumber,\r\n        _chainId,\r\n        rebalancingPeriod - 1,\r\n        i\r\n      );\r\n      vaults[_vaultNumber].rewardPerLockedToken[_chainId][rebalancingPeriod][i] =\r\n        lastReward +\r\n        _rewards[i];\r\n    }\r\n  }\r\n\r\n  function getRewardsPerLockedTokenTEST(\r\n    uint256 _vaultNumber,\r\n    uint16 _chainId,\r\n    uint256 _rebalancingPeriod,\r\n    uint256 _protocolId\r\n  ) external view returns (int256) {\r\n    return getRewardsPerLockedToken(_vaultNumber, _chainId, _rebalancingPeriod, _protocolId);\r\n  }\r\n}\r\n"
    },
    "contracts/Mocks/FrontendVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"../VaultToken.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract Vault is VaultToken {\r\n  using SafeERC20 for IERC20;\r\n\r\n  uint256 public savedTotalUnderlying;\r\n  uint256 public exchangeRate;\r\n  address public vaultCurrencyAddr;\r\n  uint256 public rebalancingPeriod = 1;\r\n\r\n  uint256 internal totalWithdrawalRequests;\r\n  mapping(address => uint256) internal withdrawalAllowance;\r\n  mapping(address => uint256) internal withdrawalRequestPeriod;\r\n\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint8 _decimals,\r\n    uint256 _savedTotalUnderlying,\r\n    uint256 _exchangeRate,\r\n    address _vaultCurrencyAddr\r\n  ) VaultToken(_name, _symbol, _decimals) {\r\n    savedTotalUnderlying = _savedTotalUnderlying;\r\n    exchangeRate = _exchangeRate;\r\n    vaultCurrencyAddr = _vaultCurrencyAddr;\r\n  }\r\n\r\n  function getVaultBalance() public view virtual returns (uint256) {\r\n    return IERC20(vaultCurrencyAddr).balanceOf(address(this));\r\n  }\r\n\r\n  function setExchangeRate(uint256 _exchangeRate) external {\r\n    exchangeRate = _exchangeRate;\r\n  }\r\n\r\n  function setTotalUnderlying(uint256 _totalUnderlying) external {\r\n    savedTotalUnderlying = _totalUnderlying;\r\n  }\r\n\r\n  function upRebalancingPeriod() external {\r\n    rebalancingPeriod++;\r\n  }\r\n\r\n  function deposit(uint256 _amount) external returns (uint256 shares) {\r\n    uint256 balanceBefore = getVaultBalance();\r\n    IERC20(vaultCurrencyAddr).safeTransferFrom(msg.sender, address(this), _amount);\r\n    uint256 balanceAfter = getVaultBalance();\r\n\r\n    uint256 amount = balanceAfter - balanceBefore;\r\n    shares = (amount * (10**decimals())) / exchangeRate;\r\n\r\n    _mint(msg.sender, shares);\r\n  }\r\n\r\n  function withdraw(uint256 _amount) external returns (uint256 value) {\r\n    value = (_amount * exchangeRate) / (10**decimals());\r\n\r\n    require(value > 0, \"No value\");\r\n\r\n    require(getVaultBalance() >= value, \"Not enough funds\");\r\n\r\n    _burn(msg.sender, _amount);\r\n    IERC20(vaultCurrencyAddr).safeTransfer(msg.sender, value);\r\n  }\r\n\r\n  function withdrawalRequest(uint256 _amount) external returns (uint256 value) {\r\n    require(withdrawalRequestPeriod[msg.sender] == 0, \"Already a withdrawal request open\");\r\n\r\n    value = (_amount * exchangeRate) / (10**decimals());\r\n\r\n    _burn(msg.sender, _amount);\r\n\r\n    withdrawalAllowance[msg.sender] = value;\r\n    withdrawalRequestPeriod[msg.sender] = rebalancingPeriod;\r\n    totalWithdrawalRequests += value;\r\n  }\r\n\r\n  function withdrawAllowance() external returns (uint256 value) {\r\n    require(withdrawalAllowance[msg.sender] > 0, \"No allowance\");\r\n    require(rebalancingPeriod > withdrawalRequestPeriod[msg.sender], \"Funds not reserved yet\");\r\n\r\n    value = withdrawalAllowance[msg.sender];\r\n\r\n    require(getVaultBalance() >= value, \"Not enough funds\");\r\n\r\n    delete withdrawalAllowance[msg.sender];\r\n    delete withdrawalRequestPeriod[msg.sender];\r\n\r\n    IERC20(vaultCurrencyAddr).safeTransfer(msg.sender, value);\r\n  }\r\n}\r\n"
    },
    "contracts/Providers/YearnProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IYearn.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract YearnProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Yearn\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Yearn, send yTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _yToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_yToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 yTokenReceived = IYearn(_yToken).deposit(_amount);\r\n    IYearn(_yToken).transfer(msg.sender, yTokenReceived);\r\n\r\n    return yTokenReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Yearn\r\n  /// @dev Pulls cTokens from Vault, redeem them from Yearn, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _yToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    require(\r\n      IYearn(_yToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error transferFrom\"\r\n    );\r\n\r\n    uint256 uAmountReceived = IYearn(_yToken).withdraw(_amount);\r\n    IERC20(_uToken).safeTransfer(msg.sender, uAmountReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uAmountReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uAmountReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in shares i.e LP tokens\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @return Balance in VaultCurrency e.g USDC\r\n  function balanceUnderlying(address _address, address _yToken)\r\n    public\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    uint256 balanceShares = balance(_address, _yToken);\r\n    uint256 price = exchangeRate(_yToken);\r\n    return (balanceShares * price) / 10**IYearn(_yToken).decimals();\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev Yearn scales price by 1E6\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _yToken) external view override returns (uint256) {\r\n    uint256 shares = (_amount * (10**IYearn(_yToken).decimals())) / exchangeRate(_yToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of yToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _yToken) public view override returns (uint256) {\r\n    uint256 balanceShares = IYearn(_yToken).balanceOf(_address);\r\n    return balanceShares;\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _yToken) public view override returns (uint256) {\r\n    uint256 price = IYearn(_yToken).pricePerShare();\r\n    return price;\r\n  }\r\n\r\n  function claim(address _yToken, address _claimer) public override returns (bool) {}\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IYearn.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IYearn {\r\n  function deposit(uint _amount) external returns (uint);\r\n\r\n  function withdraw(uint _amount) external returns (uint);\r\n\r\n  function balanceOf(address _address) external view returns (uint);\r\n\r\n  function pricePerShare() external view returns (uint);\r\n\r\n  function decimals() external view returns (uint);\r\n\r\n  function transfer(address _receiver, uint _amount) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n}\r\n"
    },
    "contracts/Providers/TruefiProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/ITruefi.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract TruefiProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in TrueFi\r\n  /// @dev Pulls underlying asset from Vault, deposit them in TrueFi, send tTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _tToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _tToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_tToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 tTokenBefore = ITruefi(_tToken).balanceOf(address(this));\r\n    ITruefi(_tToken).join(_amount);\r\n    uint256 tTokenAfter = ITruefi(_tToken).balanceOf(address(this));\r\n\r\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\r\n\r\n    ITruefi(_tToken).transfer(msg.sender, tTokensReceived);\r\n\r\n    return tTokensReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from TrueFi\r\n  /// @dev Pulls tTokens from Vault, redeem them from TrueFi, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _tToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _tToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    require(\r\n      ITruefi(_tToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    ITruefi(_tToken).liquidExit(_amount);\r\n\r\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\r\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\r\n\r\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in underlying token\r\n  /// @dev balance = poolvalue * shares / totalsupply\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _tToken Address of protocol LP Token eg cUSDC\r\n  /// @return balance in underlying token\r\n  function balanceUnderlying(address _address, address _tToken)\r\n    public\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    uint256 balanceShares = balance(_address, _tToken);\r\n    uint256 balance = (ITruefi(_tToken).poolValue() * balanceShares) /\r\n      ITruefi(_tToken).totalSupply();\r\n    return balance;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev shares = totalsupply * balance / poolvalue\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _tToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _tToken) external view override returns (uint256) {\r\n    uint256 shares = (ITruefi(_tToken).totalSupply() * _amount) / ITruefi(_tToken).poolValue();\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of cToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _tToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _tToken) public view override returns (uint256) {\r\n    return ITruefi(_tToken).balanceOf(_address);\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @dev returned price from compound is scaled by 1e18\r\n  /// @param _tToken Address of protocol LP Token eg cUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _tToken) public view override returns (uint256) {\r\n    uint256 poolValue = ITruefi(_tToken).poolValue();\r\n    uint256 totalSupply = ITruefi(_tToken).totalSupply();\r\n    return (poolValue * 1E6) / totalSupply;\r\n  }\r\n\r\n  function claim(address _tToken, address _claimer) external override returns (bool) {}\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/ITruefi.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface ITruefi {\r\n  function join(uint _amount) external;\r\n\r\n  function liquidExit(uint _amount) external;\r\n\r\n  function balanceOf(address _address) external view returns (uint);\r\n\r\n  function poolValue() external view returns (uint);\r\n\r\n  function totalSupply() external view returns (uint);\r\n\r\n  function transfer(address _receiver, uint _amount) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n}\r\n"
    },
    "contracts/Providers/IdleProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IIdle.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract IdleProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Idle\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Idle, send tTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _iToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_iToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 tTokenBefore = IIdle(_iToken).balanceOf(address(this));\r\n    // expensive mint\r\n    IIdle(_iToken).mintIdleToken(_amount, true, address(0));\r\n    uint256 tTokenAfter = IIdle(_iToken).balanceOf(address(this));\r\n\r\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\r\n    IIdle(_iToken).transfer(msg.sender, tTokensReceived);\r\n\r\n    return tTokensReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Idle\r\n  /// @dev Pulls tTokens from Vault, redeem them from Idle, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _iToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    require(\r\n      IIdle(_iToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    IIdle(_iToken).redeemIdleToken(_amount);\r\n\r\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\r\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\r\n\r\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in underlying token\r\n  /// @dev balance = poolvalue * shares / totalsupply\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return balance in underlying token\r\n  function balanceUnderlying(address _address, address _iToken)\r\n    public\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    uint256 balanceShares = balance(_address, _iToken);\r\n    uint256 price = exchangeRate(_iToken);\r\n    uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\r\n    return (balanceShares * price) / 10**decimals;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev shares = totalsupply * balance / poolvalue\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _iToken) external view override returns (uint256) {\r\n    uint256 decimals = IERC20Metadata(IIdle(_iToken).token()).decimals();\r\n    uint256 shares = (_amount * (10**decimals)) / exchangeRate(_iToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of cToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _iToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _iToken) public view override returns (uint256) {\r\n    return IIdle(_iToken).balanceOf(_address);\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @param _iToken Address of protocol LP Token eg yUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _iToken) public view override returns (uint256) {\r\n    return IIdle(_iToken).tokenPrice();\r\n  }\r\n\r\n  function claim(address _iToken, address _claimer) external override returns (bool) {}\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IIdle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IIdle {\r\n  function mintIdleToken(\r\n    uint _amount,\r\n    bool _skipRebalance,\r\n    address _referral\r\n  ) external returns (uint);\r\n\r\n  function redeemIdleToken(uint _amount) external returns (uint);\r\n\r\n  function tokenPrice() external view returns (uint);\r\n\r\n  function decimals() external view returns (uint);\r\n\r\n  function token() external view returns (address);\r\n\r\n  function balanceOf(address _address) external view returns (uint);\r\n\r\n  function transfer(address _receiver, uint _amount) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n}\r\n"
    },
    "contracts/Providers/HomoraProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IHomora.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract HomoraProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Homora\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Homora, send tTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _hToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _hToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_hToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 hTokenBefore = IHomora(_hToken).balanceOf(address(this));\r\n    IHomora(_hToken).deposit(_amount);\r\n    uint256 hTokenAfter = IHomora(_hToken).balanceOf(address(this));\r\n\r\n    uint hTokensReceived = hTokenAfter - hTokenBefore;\r\n    IHomora(_hToken).transfer(msg.sender, hTokensReceived);\r\n\r\n    return hTokensReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Homora\r\n  /// @dev Pulls tTokens from Vault, redeem them from Homora, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _hToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _hToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    require(\r\n      IHomora(_hToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    IHomora(_hToken).withdraw(_amount);\r\n\r\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\r\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\r\n\r\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in underlying token\r\n  /// @dev balance = poolvalue * shares / totalsupply\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _hToken Address of protocol LP Token eg cUSDC\r\n  /// @return balance in underlying token\r\n  function balanceUnderlying(address _address, address _hToken)\r\n    public\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    // uint256 shares = balance(_address, _hToken);\r\n    // uint256 balance = IHomora(_hToken).poolValue() * shares / IHomora(_hToken).totalSupply();\r\n    // return balance;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev shares = totalsupply * balance / poolvalue\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _hToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _hToken) external view override returns (uint256) {\r\n    // uint256 shares = IHomora(_hToken).totalSupply() * _amount / IHomora(_hToken).poolValue();\r\n    // return shares;\r\n  }\r\n\r\n  /// @notice Get balance of cToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _hToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _hToken) public view override returns (uint256) {\r\n    return IHomora(_hToken).balanceOf(_address);\r\n  }\r\n\r\n  // not used by Homora, can maybe deleted everywhere?\r\n  function exchangeRate(address _tToken) public view override returns (uint256) {}\r\n\r\n  function claim(address _tToken, address _claimer) external override returns (bool) {}\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IHomora.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IHomora {\r\n  function deposit(uint _amount) external;\r\n\r\n  function withdraw(uint _amount) external;\r\n\r\n  // function pricePerShare() external view returns(uint);\r\n\r\n  function balanceOf(address _address) external view returns (uint);\r\n\r\n  function transfer(address _receiver, uint _amount) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n}\r\n"
    },
    "contracts/Providers/CompoundProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/ICToken.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IComptroller.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract CompoundProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  IComptroller public comptroller;\r\n\r\n  constructor(address _comptroller) {\r\n    comptroller = IComptroller(_comptroller);\r\n  }\r\n\r\n  /// @notice Deposit the underlying asset in Compound\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Compound, send cTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _cToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _cToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_cToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 cTokenBefore = ICToken(_cToken).balanceOf(address(this));\r\n    require(ICToken(_cToken).mint(_amount) == 0, \"Error minting Compound\");\r\n    uint256 cTokenAfter = ICToken(_cToken).balanceOf(address(this));\r\n\r\n    uint cTokensReceived = cTokenAfter - cTokenBefore;\r\n    ICToken(_cToken).transfer(msg.sender, cTokensReceived);\r\n\r\n    return cTokensReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Compound\r\n  /// @dev Pulls cTokens from Vault, redeem them from Compound, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _cToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _cToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    require(\r\n      ICToken(_cToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    // Compound redeem: 0 on success, otherwise an Error code\r\n    require(ICToken(_cToken).redeem(_amount) == 0, \"Error: compound redeem\");\r\n\r\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\r\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\r\n\r\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in underlying token\r\n  /// @param _address Address to request balance from, most likely a Vault\r\n  /// @param _cToken Address of protocol LP Token eg cUSDC\r\n  /// @return balance in underlying token\r\n  function balanceUnderlying(address _address, address _cToken)\r\n    public\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    uint256 balanceShares = balance(_address, _cToken);\r\n    // The returned exchange rate from comp is scaled by 1 * 10^(18 - 8 + Underlying Token Decimals).\r\n    uint256 price = exchangeRate(_cToken);\r\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\r\n    return (balanceShares * price) / 10**(10 + decimals);\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _cToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _cToken) external view override returns (uint256) {\r\n    uint256 decimals = IERC20Metadata(ICToken(_cToken).underlying()).decimals();\r\n    uint256 shares = (_amount * (10**(10 + decimals))) / exchangeRate(_cToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of cToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _cToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _cToken) public view override returns (uint256) {\r\n    uint256 _balanceShares = ICToken(_cToken).balanceOf(_address);\r\n    return _balanceShares;\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @dev returned price from compound is scaled https://compound.finance/docs/ctokens#exchange-rate\r\n  /// @param _cToken Address of protocol LP Token eg cUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _cToken) public view override returns (uint256) {\r\n    uint256 _price = ICToken(_cToken).exchangeRateStored();\r\n    return _price;\r\n  }\r\n\r\n  /// @notice Claims/harvest COMP tokens from the Comptroller\r\n  /// @param _cToken Address of protocol LP Token eg cUSDC\r\n  function claim(address _cToken, address _claimer) external override returns (bool) {\r\n    address[] memory cTokens = new address[](1);\r\n    cTokens[0] = _cToken;\r\n    comptroller.claimComp(_claimer, cTokens);\r\n\r\n    return true;\r\n  }\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface ICToken {\r\n  function balanceOf(address owner) external view returns (uint);\r\n\r\n  function mint(uint) external returns (uint);\r\n\r\n  function exchangeRateStored() external view returns (uint);\r\n\r\n  function underlying() external view returns (address);\r\n\r\n  function redeem(uint _amount) external returns (uint);\r\n\r\n  function transfer(address _address, uint _amount) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IComptroller {\r\n  function claimComp(address holder, address[] memory cTokens) external;\r\n}\r\n"
    },
    "contracts/Mocks/CompoundProviderMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"../Providers/CompoundProvider.sol\";\r\n\r\ncontract CompoundProviderMock is CompoundProvider {\r\n  constructor(address _comptroller) CompoundProvider(_comptroller) {}\r\n\r\n  function claimTest(address _address, address _cToken) public {\r\n    address[] memory cTokens = new address[](1);\r\n    cTokens[0] = _cToken;\r\n    comptroller.claimComp(_address, cTokens);\r\n  }\r\n}\r\n"
    },
    "contracts/Providers/BetaProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IBeta.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract BetaProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Idle\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Idle, send tTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _bToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_bToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 tTokenBefore = IBeta(_bToken).balanceOf(address(this));\r\n    IBeta(_bToken).mint(address(this), _amount);\r\n    uint256 tTokenAfter = IBeta(_bToken).balanceOf(address(this));\r\n\r\n    uint tTokensReceived = tTokenAfter - tTokenBefore;\r\n    IBeta(_bToken).transfer(msg.sender, tTokensReceived);\r\n\r\n    return tTokensReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Idle\r\n  /// @dev Pulls tTokens from Vault, redeem them from Idle, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _bToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    uint256 balanceBeforeRedeem = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    require(\r\n      IBeta(_bToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    IBeta(_bToken).burn(address(this), _amount);\r\n\r\n    uint256 balanceAfterRedeem = IERC20(_uToken).balanceOf(address(this));\r\n    uint256 uTokensReceived = balanceAfterRedeem - balanceBeforeRedeem;\r\n\r\n    IERC20(_uToken).safeTransfer(msg.sender, uTokensReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in underlying token\r\n  /// @dev balance = poolvalue * shares / totalsupply\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @return balance in underlying token\r\n  function balanceUnderlying(address _address, address _bToken)\r\n    public\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    uint256 balanceShares = balance(_address, _bToken);\r\n    uint256 supply = IBeta(_bToken).totalSupply();\r\n    uint256 totalLoanable = IBeta(_bToken).totalLoanable();\r\n    uint256 totalLoan = IBeta(_bToken).totalLoan();\r\n\r\n    return (balanceShares * (totalLoanable + totalLoan)) / supply;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev shares = totalsupply * balance / poolvalue\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _bToken) external view override returns (uint256) {\r\n    uint256 supply = IBeta(_bToken).totalSupply();\r\n    uint256 totalLoanable = IBeta(_bToken).totalLoanable();\r\n    uint256 totalLoan = IBeta(_bToken).totalLoan();\r\n\r\n    return (_amount * supply) / (totalLoanable + totalLoan);\r\n  }\r\n\r\n  /// @notice Get balance of cToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _bToken Address of protocol LP Token eg cUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _bToken) public view override returns (uint256) {\r\n    return IBeta(_bToken).balanceOf(_address);\r\n  }\r\n\r\n  /// @notice Not used for Beta\r\n  /// @param _bToken Address of protocol LP Token eg yUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _bToken) public view override returns (uint256) {\r\n    // return IBeta(_bToken).tokenPrice();\r\n  }\r\n\r\n  function claim(address _bToken, address _claimer) external override returns (bool) {}\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IBeta.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IBeta {\r\n  function mint(address _to, uint _amount) external returns (uint);\r\n\r\n  function burn(address _to, uint _amount) external returns (uint);\r\n\r\n  function totalSupply() external view returns (uint);\r\n\r\n  function totalLoanable() external view returns (uint);\r\n\r\n  function totalLoan() external view returns (uint);\r\n\r\n  function balanceOf(address _address) external view returns (uint);\r\n\r\n  function transfer(address _receiver, uint _amount) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n}\r\n"
    },
    "contracts/Providers/AaveProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IAToken.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IALendingPool.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract AaveProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  uint16 private aaveReferral;\r\n\r\n  constructor() {\r\n    aaveReferral = 0;\r\n  }\r\n\r\n  // OnlyDao modifier? referral code for aave. Will not be used in the near future but nice to have.\r\n  function setAaveReferral(uint16 _code) external {\r\n    aaveReferral = _code;\r\n  }\r\n\r\n  /// @notice Deposit the underlying asset in Aave\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Aave, send aTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _aToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(address(IAToken(_aToken).POOL()), _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    IALendingPool(IAToken(_aToken).POOL()).deposit(\r\n      IAToken(_aToken).UNDERLYING_ASSET_ADDRESS(),\r\n      _amount,\r\n      msg.sender,\r\n      aaveReferral\r\n    );\r\n\r\n    return _amount;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Aave\r\n  /// @dev Pulls cTokens from Vault, redeem them from Aave, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _aToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    require(\r\n      IAToken(_aToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error: transferFrom\"\r\n    );\r\n    uint256 uTokensReceived = IALendingPool(IAToken(_aToken).POOL()).withdraw(\r\n      IAToken(_aToken).UNDERLYING_ASSET_ADDRESS(),\r\n      _amount,\r\n      msg.sender\r\n    );\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    require(\r\n      (balanceAfter - balanceBefore - uTokensReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uTokensReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in shares i.e LP tokens\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balanceUnderlying(address _address, address _aToken)\r\n    public\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    uint256 balanceShares = balance(_address, _aToken);\r\n    return balanceShares;\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev Aave exchangeRate is 1\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _aToken) external view override returns (uint256) {\r\n    uint256 shares = _amount / exchangeRate(_aToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of aToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _aToken) public view override returns (uint256) {\r\n    uint256 _balanceShares = IAToken(_aToken).balanceOf(_address);\r\n    return _balanceShares;\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @dev Aave exchangeRate is always 1\r\n  /// @param _aToken Address of protocol LP Token eg aUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _aToken) public pure override returns (uint256) {\r\n    return 1;\r\n  }\r\n\r\n  function claim(address _aToken, address _claimer) public override returns (bool) {}\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IAToken {\r\n  function scaledBalanceOf(address user) external view returns (uint256);\r\n\r\n  function POOL() external view returns (address);\r\n\r\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\r\n\r\n  function balanceOf(address user) external view returns (uint256);\r\n\r\n  function pricePerShare() external view returns (uint);\r\n\r\n  function transfer(address _receiver, uint _amount) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IALendingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IALendingPool {\r\n  function deposit(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external;\r\n\r\n  function withdraw(\r\n    address asset,\r\n    uint256 amount,\r\n    address to\r\n  ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/Mocks/XChainControllerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"../XChainController.sol\";\r\n\r\ncontract XChainControllerMock is XChainController {\r\n  constructor(\r\n    address _game,\r\n    address _dao,\r\n    address _guardian,\r\n    uint16 _homeChain\r\n  ) XChainController(_game, _dao, _guardian, _homeChain) {}\r\n\r\n  function setActiveVaultsTEST(uint256 _vaultNumber, uint256 _activeVaults) external {\r\n    return setActiveVaults(_vaultNumber, _activeVaults);\r\n  }\r\n\r\n  function setReadyTEST(uint256 _vaultNumber, bool _state) external {\r\n    return setReady(_vaultNumber, _state);\r\n  }\r\n\r\n  function setAllocationsReceivedTEST(uint256 _vaultNumber, bool _state) external {\r\n    return setAllocationsReceived(_vaultNumber, _state);\r\n  }\r\n\r\n  function upUnderlyingReceivedTEST(uint256 _vaultNumber) external {\r\n    return upUnderlyingReceived(_vaultNumber);\r\n  }\r\n\r\n  function resetVaultStagesTEST(uint256 _vaultNumber) external {\r\n    return resetVaultStages(_vaultNumber);\r\n  }\r\n\r\n  // function upFundsReceivedTEST(uint256 _vaultNumber) external {\r\n  //   return upFundsReceived(_vaultNumber);\r\n  // }\r\n\r\n  function getVaultReadyState(uint256 _vaultNumber) external view returns (bool) {\r\n    return vaultStage[_vaultNumber].ready;\r\n  }\r\n\r\n  function getAllocationState(uint256 _vaultNumber) external view returns (bool) {\r\n    return vaultStage[_vaultNumber].allocationsReceived;\r\n  }\r\n\r\n  function getUnderlyingState(uint256 _vaultNumber) external view returns (uint256) {\r\n    return vaultStage[_vaultNumber].underlyingReceived;\r\n  }\r\n\r\n  function getFundsReceivedState(uint256 _vaultNumber) external view returns (uint256) {\r\n    return vaultStage[_vaultNumber].fundsReceived;\r\n  }\r\n\r\n  function getCurrentTotalAllocationTEST(uint256 _vaultNumber) external view returns (int256) {\r\n    return getCurrentTotalAllocation(_vaultNumber);\r\n  }\r\n\r\n  function getCurrentAllocationTEST(uint256 _vaultNumber, uint16 _chainId)\r\n    external\r\n    view\r\n    returns (int256)\r\n  {\r\n    return getCurrentAllocation(_vaultNumber, _chainId);\r\n  }\r\n\r\n  function getTotalUnderlyingOnChainTEST(uint256 _vaultNumber, uint16 _chainId)\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return getTotalUnderlyingOnChain(_vaultNumber, _chainId);\r\n  }\r\n\r\n  function getTotalSupplyTEST(uint256 _vaultNumber) external view returns (uint256) {\r\n    return getTotalSupply(_vaultNumber);\r\n  }\r\n\r\n  function getWithdrawalRequestsTEST(uint256 _vaultNumber, uint16 _chainId)\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return getWithdrawalRequests(_vaultNumber, _chainId);\r\n  }\r\n\r\n  function getTotalWithdrawalRequestsTEST(uint256 _vaultNumber) external view returns (uint256) {\r\n    return getTotalWithdrawalRequests(_vaultNumber);\r\n  }\r\n\r\n  function getTotalUnderlyingVaultTEST(uint256 _vaultNumber) external view returns (uint256) {\r\n    return getTotalUnderlyingVault(_vaultNumber);\r\n  }\r\n}\r\n"
    },
    "contracts/Mocks/XSendMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022*\r\npragma solidity ^0.8.11;\r\n\r\nimport \"./Connext/interfaces/IXProviderMock.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract XSendMock {\r\n  using SafeERC20 for IERC20;\r\n\r\n  address dao;\r\n  address public xprovider; // ConnextXProviderMock\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"ConnextProvider: only DAO\");\r\n    _;\r\n  }\r\n\r\n  constructor(address _dao) {\r\n    dao = _dao;\r\n  }\r\n\r\n  function xSendSomeValue(uint256 _value) external {\r\n    // should later on be changed to onlyDao/ onlyKeeper\r\n    IXProviderMock(xprovider).xSend(_value);\r\n  }\r\n\r\n  function xTransferFunds(\r\n    address to,\r\n    address asset,\r\n    uint32 originDomain,\r\n    uint32 destinationDomain,\r\n    uint256 amount\r\n  ) external {\r\n    // should later on be changed to onlyDao/ onlyKeeper\r\n    IERC20 token = IERC20(asset);\r\n    token.approve(xprovider, amount);\r\n    IXProviderMock(xprovider).xTransfer(to, asset, originDomain, destinationDomain, amount);\r\n  }\r\n\r\n  function setXProvider(address _xprovider) external onlyDao {\r\n    xprovider = _xprovider;\r\n  }\r\n}\r\n"
    },
    "contracts/Mocks/Connext/interfaces/IXProviderMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IXProviderMock {\r\n  // interface should be standard, we'll get a diffrent implementation per cross chain technology provider\r\n  // the function signatures below should be changed in the different core functionalities we would like to implement cross chain\r\n  // E.g. getTotalunderlying\r\n  function xSend(uint256 _value) external; // sending a (permissioned) value crosschain.\r\n\r\n  // function xSendCallback() external; // sending a (permissioned) vaule crosschain and receive a callback to a specified address.\r\n  function xReceive(uint256 _value) external; // receiving a (permissioned) value crosschain.\r\n\r\n  // function xReceiveCallback() external; // receiving a (permissioned) value crosschain where a callback was expected.\r\n  function xTransfer(\r\n    address to,\r\n    address asset,\r\n    uint32 originDomain,\r\n    uint32 destinationDomain,\r\n    uint256 amount\r\n  ) external; // transfer funds crosschain.\r\n  // function xReceiveFunds() external; // receive funds crosschain, maybe unnecessary.\r\n  // function setXController() external;\r\n  // function setGame() external;\r\n}\r\n"
    },
    "contracts/Mocks/LayerZero/LZXProviderMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\nimport \"../Connext/interfaces/IXProviderMock.sol\";\r\nimport \"../Connext/interfaces/IXReceiveMock.sol\";\r\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\r\nimport \"./interfaces/ILayerZeroReceiver.sol\";\r\nimport \"../../Interfaces/ExternalInterfaces/IConnextHandler.sol\"; // https://github.com/connext/nxtp/blob/main/packages/deployments/contracts/contracts/core/connext/interfaces/IConnextHandler.sol\r\nimport {XCallArgs, CallParams} from \"../../libraries/LibConnextStorage.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract LZXProviderMock is IXProviderMock, ILayerZeroReceiver {\r\n  using SafeERC20 for IERC20;\r\n\r\n  ILayerZeroEndpoint public endpoint;\r\n  IConnextHandler public immutable connext;\r\n  address public dao;\r\n  address xReceiveMock;\r\n  uint16 xReceiveMockChainID;\r\n  mapping(uint16 => bytes) public trustedRemoteLookup;\r\n\r\n  event SetTrustedRemote(uint16 _srcChainId, bytes _srcAddress);\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"ConnextProvider: only DAO\");\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address _endpoint,\r\n    address _dao,\r\n    address _connextHandler\r\n  ) {\r\n    endpoint = ILayerZeroEndpoint(_endpoint);\r\n    dao = _dao;\r\n    connext = IConnextHandler(_connextHandler);\r\n  }\r\n\r\n  /// @notice setter for the receiver contract parameters, always needs to be set, could be a list when multiple contracts on the sending chain have to send values.\r\n  /// @param _xReceiveMock address of receiving contract, e.g. xChainController contract to send game totalAllocations to xChainController\r\n  /// @param _xReceiveMockChainID chain id of receiving contract, e.g. ethereum, where the xChainController lives\r\n  function setxReceiveMock(address _xReceiveMock, uint16 _xReceiveMockChainID) external onlyDao {\r\n    xReceiveMock = _xReceiveMock;\r\n    xReceiveMockChainID = _xReceiveMockChainID;\r\n  }\r\n\r\n  /// @notice set trusted provider on remote chains, allow owner to set it multiple times.\r\n  /// @param _srcChainId chain is for remote xprovider, some as the remote receiving contract chain id (xReceive)\r\n  /// @param _srcAddress address of remote xprovider\r\n  function setTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external onlyDao {\r\n    trustedRemoteLookup[_srcChainId] = _srcAddress;\r\n    emit SetTrustedRemote(_srcChainId, _srcAddress);\r\n  }\r\n\r\n  /// @notice Function to send an integer value crosschain\r\n  /// @param _value Value to send crosschain.\r\n  function xSend(uint256 _value) external {\r\n    bytes memory trustedRemote = trustedRemoteLookup[xReceiveMockChainID]; // same chainID as the provider on the receiverChain\r\n    require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\r\n\r\n    bytes4 selector = bytes4(keccak256(\"xReceive(uint256)\"));\r\n    bytes memory callData = abi.encodeWithSelector(selector, _value);\r\n    endpoint.send(\r\n      xReceiveMockChainID,\r\n      trustedRemote,\r\n      callData,\r\n      payable(msg.sender),\r\n      address(0x0),\r\n      bytes(\"\")\r\n    );\r\n  }\r\n\r\n  function lzReceive(\r\n    uint16 _srcChainId,\r\n    bytes calldata _srcAddress,\r\n    uint64 _nonce,\r\n    bytes calldata _payload\r\n  ) external {\r\n    require(msg.sender == address(endpoint));\r\n    require(\r\n      _srcAddress.length == trustedRemoteLookup[_srcChainId].length &&\r\n        keccak256(_srcAddress) == keccak256(trustedRemoteLookup[_srcChainId])\r\n    );\r\n\r\n    (bool success, ) = address(this).call(_payload);\r\n    require(success, \"LZXProviderMock: lzReceive: No success\");\r\n  }\r\n\r\n  /// @notice Function to receive value crosschain, onlyExecutor modifier makes sure only xSend can actually send the value\r\n  /// @param _value Value to send crosschain.\r\n  function xReceive(uint256 _value) external {\r\n    IXReceiveMock(xReceiveMock).xReceiveAndSetSomeValue(_value);\r\n  }\r\n\r\n  function xTransfer(\r\n    address to,\r\n    address asset,\r\n    uint32 originDomain,\r\n    uint32 destinationDomain,\r\n    uint256 amount\r\n  ) external {\r\n    IERC20 token = IERC20(asset);\r\n    require(\r\n      token.allowance(msg.sender, address(this)) >= amount,\r\n      \"LZXProvider: User must approve amount\"\r\n    );\r\n    token.transferFrom(msg.sender, address(this), amount);\r\n    token.approve(address(connext), amount);\r\n\r\n    CallParams memory callParams = CallParams({\r\n      to: to,\r\n      callData: \"\",\r\n      originDomain: originDomain,\r\n      destinationDomain: destinationDomain,\r\n      agent: to,\r\n      recovery: to,\r\n      forceSlow: false,\r\n      receiveLocal: false,\r\n      callback: address(0),\r\n      callbackFee: 0,\r\n      relayerFee: 0,\r\n      slippageTol: 9995\r\n    });\r\n\r\n    XCallArgs memory xcallArgs = XCallArgs({\r\n      params: callParams,\r\n      transactingAssetId: asset,\r\n      amount: amount\r\n    });\r\n    connext.xcall(xcallArgs);\r\n  }\r\n}\r\n"
    },
    "contracts/Mocks/Connext/interfaces/IXReceiveMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IXReceiveMock {\r\n  function xReceiveAndSetSomeValue(uint256 _value) external;\r\n}\r\n"
    },
    "contracts/Mocks/Connext/ConnextXProviderMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\nimport \"./interfaces/IXProviderMock.sol\";\r\nimport \"./interfaces/IXReceiveMock.sol\";\r\nimport \"../../Interfaces/ExternalInterfaces/IConnextHandler.sol\"; // https://github.com/connext/nxtp/blob/main/packages/deployments/contracts/contracts/core/connext/interfaces/IConnextHandler.sol\r\nimport \"./interfaces/IExecutorMock.sol\";\r\nimport {XCallArgs, CallParams} from \"../../libraries/LibConnextStorage.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract ConnextXProviderMock is IXProviderMock {\r\n  /// Specific implementation of a XProvider for the Connext network\r\n  /// Mocking solution for local testing\r\n  /// This specific implementation can be changed to the real one and be tested still in this setup\r\n  /// The ONLY thing that needs to be changed in local testing is the recovery parameter which should in local testing be set to msg.sender\r\n  address xSendMock;\r\n  uint32 xSendMockChainID;\r\n  address xReceiveMock;\r\n  uint32 xReceiveMockChainID;\r\n  address receiveProvider;\r\n  address dao;\r\n  address executor;\r\n  IConnextHandler public immutable connext;\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"ConnextProvider: only DAO\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyExecutor() {\r\n    require(\r\n      IExecutorMock(msg.sender).originSender() == xSendMock &&\r\n        IExecutorMock(msg.sender).origin() == xSendMockChainID &&\r\n        msg.sender == executor,\r\n      \"Expected origin contract on origin domain called by Executor\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address _executor, // disabled on testnet\r\n    address _dao,\r\n    address _connextHandler\r\n  ) {\r\n    executor = _executor; // disabled on testnet\r\n    dao = _dao;\r\n    connext = IConnextHandler(_connextHandler);\r\n    // executor = connext.executor(); // on testnet\r\n  }\r\n\r\n  /// @notice setter for the sender contract parameters, always needs to be set, could be a list when multiple contracts on the sending chain have to send values.\r\n  /// @param _xSendMock address of sending contract, e.g. game contract to send totalAllocations to xChainController\r\n  /// @param _xSendMockChainID chain id of sending contract, e.g. optimism, where the game lives\r\n  function setXSendMock(address _xSendMock, uint32 _xSendMockChainID) external onlyDao {\r\n    xSendMock = _xSendMock;\r\n    xSendMockChainID = _xSendMockChainID;\r\n  }\r\n\r\n  /// @notice setter for the receiver contract parameters, always needs to be set, could be a list when multiple contracts on the sending chain have to send values.\r\n  /// @param _xReceiveMock address of receiving contract, e.g. xChainController contract to send game totalAllocations to xChainController\r\n  /// @param _xReceiveMockChainID chain id of receiving contract, e.g. ethereum, where the xChainController lives\r\n  function setxReceiveMock(address _xReceiveMock, uint32 _xReceiveMockChainID) external onlyDao {\r\n    xReceiveMock = _xReceiveMock;\r\n    xReceiveMockChainID = _xReceiveMockChainID;\r\n  }\r\n\r\n  /// @notice setter for the address of the xprovider on the receiving chain, only needs to be set on sender xprovider\r\n  /// @param _receiveProviderAddress address of the xprovider on the receiving chain\r\n  function setReceiveProvider(address _receiveProviderAddress) external onlyDao {\r\n    receiveProvider = _receiveProviderAddress;\r\n  }\r\n\r\n  function setDao(address _dao) external onlyDao {\r\n    dao = _dao;\r\n  }\r\n\r\n  /// @notice Function to send an integer value crosschain\r\n  /// @param _value Value to send crosschain.\r\n  function xSend(uint256 _value) external {\r\n    bytes4 selector = bytes4(keccak256(\"xReceive(uint256)\"));\r\n    bytes memory callData = abi.encodeWithSelector(selector, _value);\r\n    CallParams memory callParams = CallParams({\r\n      to: receiveProvider,\r\n      callData: callData,\r\n      originDomain: xSendMockChainID,\r\n      destinationDomain: xReceiveMockChainID,\r\n      agent: receiveProvider,\r\n      recovery: msg.sender, // misused here for mocking purposes --> in this context it is the originSender contract used for the onlyExecutor modifier\r\n      // recovery: receiveProvider, // on testnet\r\n      forceSlow: true,\r\n      receiveLocal: false,\r\n      callback: address(0),\r\n      callbackFee: 0,\r\n      relayerFee: 0,\r\n      slippageTol: 9995\r\n    });\r\n\r\n    XCallArgs memory xcallArgs = XCallArgs({\r\n      params: callParams,\r\n      transactingAssetId: address(0), // The asset the caller sent with the transfer.\r\n      amount: 0\r\n    });\r\n    connext.xcall(xcallArgs);\r\n  }\r\n\r\n  /// @notice Function to receive value crosschain, onlyExecutor modifier makes sure only xSend can actually send the value\r\n  /// @param _value Value to send crosschain.\r\n  function xReceive(uint256 _value) external onlyExecutor {\r\n    IXReceiveMock(xReceiveMock).xReceiveAndSetSomeValue(_value);\r\n  }\r\n\r\n  function xTransfer(\r\n    address to,\r\n    address asset,\r\n    uint32 originDomain,\r\n    uint32 destinationDomain,\r\n    uint256 amount\r\n  ) external {}\r\n}\r\n"
    },
    "contracts/Mocks/Connext/interfaces/IExecutorMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IExecutorMock {\r\n  /// Mock because the ExecutorArgs differ slightly\r\n  struct ExecutorArgs {\r\n    address to;\r\n    bytes callData;\r\n    address originSender; // not in original interface, for mocking only\r\n    uint32 origin; // not in original interface, for mocking only\r\n  }\r\n\r\n  function originSender() external returns (address);\r\n\r\n  function origin() external returns (uint32);\r\n\r\n  function execute(ExecutorArgs calldata _args) external payable;\r\n}\r\n"
    },
    "contracts/Mocks/Connext/ConnextHandlerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\nimport {XCallArgs, CallParams} from \"../../libraries/LibConnextStorage.sol\";\r\nimport \"./interfaces/IExecutorMock.sol\";\r\nimport \"../../Interfaces/ExternalInterfaces/IConnextHandler.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract ConnextHandlerMock is IConnextHandler {\r\n  using SafeERC20 for IERC20;\r\n\r\n  address public executor;\r\n  address public dao;\r\n\r\n  constructor(address _dao) {\r\n    dao = _dao;\r\n  }\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"ConnextHandler: only DAO\");\r\n    _;\r\n  }\r\n\r\n  function setExecutor(address _executor) external onlyDao {\r\n    executor = _executor;\r\n  }\r\n\r\n  function getExecutor() external view returns (address) {\r\n    return executor;\r\n  }\r\n\r\n  function xcall(XCallArgs calldata _args) external payable returns (bytes32) {\r\n    // split logic for messaging and transfer of value\r\n    if (_args.transactingAssetId == address(0)) {\r\n      // message\r\n      IExecutorMock.ExecutorArgs memory exArgs;\r\n      exArgs.to = _args.params.to;\r\n      exArgs.callData = _args.params.callData;\r\n      exArgs.originSender = _args.params.recovery;\r\n      exArgs.origin = _args.params.originDomain;\r\n      IExecutorMock(executor).execute(exArgs);\r\n    } else {\r\n      // transfer of value\r\n      IERC20(_args.transactingAssetId).transferFrom(msg.sender, _args.params.to, _args.amount);\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/Mocks/Connext/ConnextExecutorMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\nimport \"./interfaces/IExecutorMock.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract ConnextExecutorMock is IExecutorMock {\r\n  address private immutable connext;\r\n  address private originSender_;\r\n  uint32 private origin_;\r\n\r\n  constructor(address _connext) {\r\n    connext = _connext;\r\n  }\r\n\r\n  modifier onlyConnext() {\r\n    require(msg.sender == connext, \"ConnextExecutorMock: !connext\");\r\n    _;\r\n  }\r\n\r\n  function originSender() external view override returns (address) {\r\n    return originSender_;\r\n  }\r\n\r\n  function origin() external view override returns (uint32) {\r\n    return origin_;\r\n  }\r\n\r\n  function execute(ExecutorArgs memory _args) external payable override onlyConnext {\r\n    originSender_ = _args.originSender;\r\n    origin_ = _args.origin;\r\n    (bool success, ) = _args.to.call(_args.callData);\r\n    require(success, \"ConnextExecutorMock: No success\");\r\n  }\r\n}\r\n"
    },
    "contracts/Mocks/LayerZero/LZEndpointMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\npragma abicoder v2;\r\n\r\nimport \"./interfaces/ILayerZeroReceiver.sol\";\r\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n/*\r\nmocking multi endpoint connection.\r\n- send() will short circuit to lzReceive() directly\r\n- no reentrancy guard. the real LayerZero endpoint on main net has a send and receive guard, respectively.\r\nif we run a ping-pong-like application, the recursive call might use all gas limit in the block.\r\n- not using any messaging library, hence all messaging library func, e.g. estimateFees, version, will not work\r\n*/\r\ncontract LZEndpointMock is ILayerZeroEndpoint {\r\n  mapping(address => address) public lzEndpointLookup;\r\n\r\n  uint16 public mockChainId;\r\n  address payable public mockOracle;\r\n  address payable public mockRelayer;\r\n  uint public mockBlockConfirmations;\r\n  uint16 public mockLibraryVersion;\r\n  uint public mockStaticNativeFee;\r\n  uint16 public mockLayerZeroVersion;\r\n  uint public nativeFee;\r\n  uint public zroFee;\r\n  bool nextMsgBLocked;\r\n\r\n  struct StoredPayload {\r\n    uint64 payloadLength;\r\n    address dstAddress;\r\n    bytes32 payloadHash;\r\n  }\r\n\r\n  struct QueuedPayload {\r\n    address dstAddress;\r\n    uint64 nonce;\r\n    bytes payload;\r\n  }\r\n\r\n  // inboundNonce = [srcChainId][srcAddress].\r\n  mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\r\n  // outboundNonce = [dstChainId][srcAddress].\r\n  mapping(uint16 => mapping(address => uint64)) public outboundNonce;\r\n  // storedPayload = [srcChainId][srcAddress]\r\n  mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\r\n  // msgToDeliver = [srcChainId][srcAddress]\r\n  mapping(uint16 => mapping(bytes => QueuedPayload[])) public msgsToDeliver;\r\n\r\n  event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\r\n  event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\r\n  event PayloadStored(\r\n    uint16 srcChainId,\r\n    bytes srcAddress,\r\n    address dstAddress,\r\n    uint64 nonce,\r\n    bytes payload,\r\n    bytes reason\r\n  );\r\n\r\n  constructor(uint16 _chainId) {\r\n    mockStaticNativeFee = 42;\r\n    mockLayerZeroVersion = 1;\r\n    mockChainId = _chainId;\r\n  }\r\n\r\n  // mock helper to set the value returned by `estimateNativeFees`\r\n  function setEstimatedFees(uint _nativeFee, uint _zroFee) public {\r\n    nativeFee = _nativeFee;\r\n    zroFee = _zroFee;\r\n  }\r\n\r\n  function getChainId() external view override returns (uint16) {\r\n    return mockChainId;\r\n  }\r\n\r\n  function setDestLzEndpoint(address destAddr, address lzEndpointAddr) external {\r\n    lzEndpointLookup[destAddr] = lzEndpointAddr;\r\n  }\r\n\r\n  function send(\r\n    uint16 _chainId,\r\n    bytes calldata _destination,\r\n    bytes calldata _payload,\r\n    address payable, // _refundAddress\r\n    address, // _zroPaymentAddress\r\n    bytes memory _adapterParams\r\n  ) external payable override {\r\n    address destAddr = packedBytesToAddr(_destination);\r\n    address lzEndpoint = lzEndpointLookup[destAddr];\r\n\r\n    require(lzEndpoint != address(0), \"LayerZeroMock: destination LayerZero Endpoint not found\");\r\n\r\n    require(msg.value >= nativeFee * _payload.length, \"LayerZeroMock: not enough native for fees\");\r\n\r\n    uint64 nonce;\r\n    {\r\n      nonce = ++outboundNonce[_chainId][msg.sender];\r\n    }\r\n\r\n    // Mock the relayer paying the dstNativeAddr the amount of extra native token\r\n    {\r\n      uint extraGas;\r\n      uint dstNative;\r\n      address dstNativeAddr;\r\n      assembly {\r\n        extraGas := mload(add(_adapterParams, 34))\r\n        dstNative := mload(add(_adapterParams, 66))\r\n        dstNativeAddr := mload(add(_adapterParams, 86))\r\n      }\r\n\r\n      // to simulate actually sending the ether, add a transfer call and ensure the LZEndpointMock contract has an ether balance\r\n    }\r\n\r\n    bytes memory bytesSourceUserApplicationAddr = addrToPackedBytes(address(msg.sender)); // cast this address to bytes\r\n\r\n    // not using the extra gas parameter because this is a single tx call, not split between different chains\r\n    // LZEndpointMock(lzEndpoint).receivePayload(mockChainId, bytesSourceUserApplicationAddr, destAddr, nonce, extraGas, _payload);\r\n    LZEndpointMock(lzEndpoint).receivePayload(\r\n      mockChainId,\r\n      bytesSourceUserApplicationAddr,\r\n      destAddr,\r\n      nonce,\r\n      0,\r\n      _payload\r\n    );\r\n  }\r\n\r\n  function receivePayload(\r\n    uint16 _srcChainId,\r\n    bytes calldata _srcAddress,\r\n    address _dstAddress,\r\n    uint64 _nonce,\r\n    uint, /*_gasLimit*/\r\n    bytes calldata _payload\r\n  ) external override {\r\n    StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\r\n\r\n    // assert and increment the nonce. no message shuffling\r\n    require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\r\n\r\n    // queue the following msgs inside of a stack to simulate a successful send on src, but not fully delivered on dst\r\n    if (sp.payloadHash != bytes32(0)) {\r\n      QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\r\n      QueuedPayload memory newMsg = QueuedPayload(_dstAddress, _nonce, _payload);\r\n\r\n      // warning, might run into gas issues trying to forward through a bunch of queued msgs\r\n      // shift all the msgs over so we can treat this like a fifo via array.pop()\r\n      if (msgs.length > 0) {\r\n        // extend the array\r\n        msgs.push(newMsg);\r\n\r\n        // shift all the indexes up for pop()\r\n        for (uint i = 0; i < msgs.length - 1; i++) {\r\n          msgs[i + 1] = msgs[i];\r\n        }\r\n\r\n        // put the newMsg at the bottom of the stack\r\n        msgs[0] = newMsg;\r\n      } else {\r\n        msgs.push(newMsg);\r\n      }\r\n    } else if (nextMsgBLocked) {\r\n      storedPayload[_srcChainId][_srcAddress] = StoredPayload(\r\n        uint64(_payload.length),\r\n        _dstAddress,\r\n        keccak256(_payload)\r\n      );\r\n      emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, bytes(\"\"));\r\n      // ensure the next msgs that go through are no longer blocked\r\n      nextMsgBLocked = false;\r\n    } else {\r\n      // we ignore the gas limit because this call is made in one tx due to being \"same chain\"\r\n      // ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\r\n      ILayerZeroReceiver(_dstAddress).lzReceive(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\r\n    }\r\n  }\r\n\r\n  // used to simulate messages received get stored as a payload\r\n  function blockNextMsg() external {\r\n    nextMsgBLocked = true;\r\n  }\r\n\r\n  function getLengthOfQueue(uint16 _srcChainId, bytes calldata _srcAddress)\r\n    external\r\n    view\r\n    returns (uint)\r\n  {\r\n    return msgsToDeliver[_srcChainId][_srcAddress].length;\r\n  }\r\n\r\n  // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\r\n  // @param _dstChainId - the destination chain identifier\r\n  // @param _userApplication - the user app address on this EVM chain\r\n  // @param _payload - the custom message to send over LayerZero\r\n  // @param _payInZRO - if false, user app pays the protocol fee in native token\r\n  // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\r\n  function estimateFees(\r\n    uint16,\r\n    address,\r\n    bytes memory _payload,\r\n    bool,\r\n    bytes memory\r\n  ) external view override returns (uint _nativeFee, uint _zroFee) {\r\n    _nativeFee = nativeFee * _payload.length;\r\n    _zroFee = zroFee;\r\n  }\r\n\r\n  // give 20 bytes, return the decoded address\r\n  function packedBytesToAddr(bytes calldata _b) public pure returns (address) {\r\n    address addr;\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      calldatacopy(ptr, sub(_b.offset, 2), add(_b.length, 2))\r\n      addr := mload(sub(ptr, 10))\r\n    }\r\n    return addr;\r\n  }\r\n\r\n  // given an address, return the 20 bytes\r\n  function addrToPackedBytes(address _a) public pure returns (bytes memory) {\r\n    bytes memory data = abi.encodePacked(_a);\r\n    return data;\r\n  }\r\n\r\n  function setConfig(\r\n    uint16, /*_version*/\r\n    uint16, /*_chainId*/\r\n    uint, /*_configType*/\r\n    bytes memory /*_config*/\r\n  ) external override {}\r\n\r\n  function getConfig(\r\n    uint16, /*_version*/\r\n    uint16, /*_chainId*/\r\n    address, /*_ua*/\r\n    uint /*_configType*/\r\n  ) external pure override returns (bytes memory) {\r\n    return \"\";\r\n  }\r\n\r\n  function setSendVersion(\r\n    uint16 /*version*/\r\n  ) external override {}\r\n\r\n  function setReceiveVersion(\r\n    uint16 /*version*/\r\n  ) external override {}\r\n\r\n  function getSendVersion(\r\n    address /*_userApplication*/\r\n  ) external pure override returns (uint16) {\r\n    return 1;\r\n  }\r\n\r\n  function getReceiveVersion(\r\n    address /*_userApplication*/\r\n  ) external pure override returns (uint16) {\r\n    return 1;\r\n  }\r\n\r\n  function getInboundNonce(uint16 _chainID, bytes calldata _srcAddress)\r\n    external\r\n    view\r\n    override\r\n    returns (uint64)\r\n  {\r\n    return inboundNonce[_chainID][_srcAddress];\r\n  }\r\n\r\n  function getOutboundNonce(uint16 _chainID, address _srcAddress)\r\n    external\r\n    view\r\n    override\r\n    returns (uint64)\r\n  {\r\n    return outboundNonce[_chainID][_srcAddress];\r\n  }\r\n\r\n  // simulates the relayer pushing through the rest of the msgs that got delayed due to the stored payload\r\n  function _clearMsgQue(uint16 _srcChainId, bytes calldata _srcAddress) internal {\r\n    QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\r\n\r\n    // warning, might run into gas issues trying to forward through a bunch of queued msgs\r\n    while (msgs.length > 0) {\r\n      QueuedPayload memory payload = msgs[msgs.length - 1];\r\n      ILayerZeroReceiver(payload.dstAddress).lzReceive(\r\n        _srcChainId,\r\n        _srcAddress,\r\n        payload.nonce,\r\n        payload.payload\r\n      );\r\n      msgs.pop();\r\n    }\r\n  }\r\n\r\n  function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\r\n    StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\r\n    // revert if no messages are cached. safeguard malicious UA behaviour\r\n    require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\r\n    require(sp.dstAddress == msg.sender, \"LayerZero: invalid caller\");\r\n\r\n    // empty the storedPayload\r\n    sp.payloadLength = 0;\r\n    sp.dstAddress = address(0);\r\n    sp.payloadHash = bytes32(0);\r\n\r\n    emit UaForceResumeReceive(_srcChainId, _srcAddress);\r\n\r\n    // resume the receiving of msgs after we force clear the \"stuck\" msg\r\n    _clearMsgQue(_srcChainId, _srcAddress);\r\n  }\r\n\r\n  function retryPayload(\r\n    uint16 _srcChainId,\r\n    bytes calldata _srcAddress,\r\n    bytes calldata _payload\r\n  ) external override {\r\n    StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\r\n    require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\r\n    require(\r\n      _payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash,\r\n      \"LayerZero: invalid payload\"\r\n    );\r\n\r\n    address dstAddress = sp.dstAddress;\r\n    // empty the storedPayload\r\n    sp.payloadLength = 0;\r\n    sp.dstAddress = address(0);\r\n    sp.payloadHash = bytes32(0);\r\n\r\n    uint64 nonce = inboundNonce[_srcChainId][_srcAddress];\r\n\r\n    ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\r\n    emit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\r\n  }\r\n\r\n  function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress)\r\n    external\r\n    view\r\n    override\r\n    returns (bool)\r\n  {\r\n    StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\r\n    return sp.payloadHash != bytes32(0);\r\n  }\r\n\r\n  function isSendingPayload() external pure override returns (bool) {\r\n    return false;\r\n  }\r\n\r\n  function isReceivingPayload() external pure override returns (bool) {\r\n    return false;\r\n  }\r\n\r\n  function getSendLibraryAddress(address) external view override returns (address) {\r\n    return address(this);\r\n  }\r\n\r\n  function getReceiveLibraryAddress(address) external view override returns (address) {\r\n    return address(this);\r\n  }\r\n}\r\n"
    },
    "contracts/TokenTimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/utils/TokenTimelock.sol)\r\n\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract TokenTimelock {\r\n  using SafeERC20 for IERC20;\r\n\r\n  IERC20 private immutable token;\r\n\r\n  address private beneficiary;\r\n  address private immutable admin;\r\n\r\n  uint256 public startTimestamp;\r\n  uint256 public monthDuration;\r\n  uint256 public tokensPerMonth;\r\n  uint256 public claimed;\r\n\r\n  bool public initialized;\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin, \"!admin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyBeneficiary() {\r\n    require(msg.sender == beneficiary, \"!beneficiary\");\r\n    _;\r\n  }\r\n\r\n  constructor(address _token) {\r\n    admin = msg.sender;\r\n    token = IERC20(_token);\r\n  }\r\n\r\n  function init(\r\n    address _beneficiary,\r\n    uint256 _amount,\r\n    uint256 _startTimestamp, // timestamp after the cliff\r\n    uint256 _numberOfMonths,\r\n    uint256 _monthDurationUnix\r\n  ) external onlyAdmin {\r\n    require(!initialized, \"already initialized\");\r\n\r\n    token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n    startTimestamp = _startTimestamp;\r\n    monthDuration = _monthDurationUnix; // unix // 1 month == 2629743\r\n    beneficiary = _beneficiary;\r\n    tokensPerMonth = _amount / _numberOfMonths;\r\n    initialized = true;\r\n  }\r\n\r\n  function claimableTokens() public view returns (uint256) {\r\n    require(initialized, \"!initialized\");\r\n    if (startTimestamp > block.timestamp) return 0;\r\n\r\n    uint256 timePassed = block.timestamp - startTimestamp;\r\n    uint256 monthsPassed = timePassed / monthDuration;\r\n    uint256 tokenBalance = token.balanceOf(address(this));\r\n    uint256 amount = (monthsPassed * tokensPerMonth) - claimed;\r\n    uint256 tokens = amount > tokenBalance ? tokenBalance : amount;\r\n\r\n    return tokens;\r\n  }\r\n\r\n  function release() external onlyBeneficiary {\r\n    require(initialized, \"!initialized\");\r\n    uint256 amount = claimableTokens();\r\n    require(amount > 0, \"Nothing to claim\");\r\n\r\n    claimed += amount;\r\n\r\n    token.safeTransfer(beneficiary, amount);\r\n  }\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface IExecutor {\r\n  /**\r\n   * @param _transferId Unique identifier of transaction id that necessitated\r\n   * calldata execution\r\n   * @param _amount The amount to approve or send with the call\r\n   * @param _to The address to execute the calldata on\r\n   * @param _assetId The assetId of the funds to approve to the contract or\r\n   * send along with the call\r\n   * @param _properties The origin properties\r\n   * @param _callData The data to execute\r\n   */\r\n  struct ExecutorArgs {\r\n    bytes32 transferId;\r\n    uint256 amount;\r\n    address to;\r\n    address recovery;\r\n    address assetId;\r\n    bytes properties;\r\n    bytes callData;\r\n  }\r\n\r\n  function originSender() external returns (address);\r\n\r\n  function origin() external returns (uint32);\r\n\r\n  function execute(ExecutorArgs calldata _args)\r\n    external\r\n    payable\r\n    returns (bool success, bytes memory returnData);\r\n}\r\n"
    },
    "contracts/Interfaces/IGoverned.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nabstract contract IGoverned {\r\n  address public dao;\r\n  address public guardian;\r\n\r\n  modifier onlyDao() {\r\n    require(dao == msg.sender, \"GOV: not dao\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyDaoOrGuardian() {\r\n    require(msg.sender == dao || msg.sender == guardian, \"GOV: not dao/guardian\");\r\n    _;\r\n  }\r\n\r\n  constructor() {\r\n    dao = msg.sender;\r\n    guardian = msg.sender;\r\n  }\r\n\r\n  function setDao(address dao_) external onlyDao {\r\n    dao = dao_;\r\n  }\r\n\r\n  function setGuardian(address guardian_) external onlyDao {\r\n    guardian = guardian_;\r\n  }\r\n}\r\n"
    },
    "contracts/libraries/ABDKMath64x64.sol": {
      "content": "// SPDX-License-Identifier: BSD-4-Clause\r\n/*\r\n * ABDK Math 64.64 Smart Contract Library.  Copyright  2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n  /*\r\n   * Minimum value signed 64.64-bit fixed point number may have.\r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /*\r\n   * Maximum value signed 64.64-bit fixed point number may have.\r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromInt(int256 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require(x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n      return int128(x << 64);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt(int128 x) internal pure returns (int64) {\r\n    unchecked {\r\n      return int64(x >> 64);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromUInt(uint256 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require(x <= 0x7FFFFFFFFFFFFFFF);\r\n      return int128(int256(x << 64));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n  function toUInt(int128 x) internal pure returns (uint64) {\r\n    unchecked {\r\n      require(x >= 0);\r\n      return uint64(uint128(x >> 64));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n   * number rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function from128x128(int256 x) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = x >> 64;\r\n      require(result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128(result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128(int128 x) internal pure returns (int256) {\r\n    unchecked {\r\n      return int256(x) << 64;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add(int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = int256(x) + y;\r\n      require(result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128(result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub(int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = int256(x) - y;\r\n      require(result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128(result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul(int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 result = (int256(x) * y) >> 64;\r\n      require(result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128(result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli(int128 x, int256 y) internal pure returns (int256) {\r\n    unchecked {\r\n      if (x == MIN_64x64) {\r\n        require(\r\n          y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n            y <= 0x1000000000000000000000000000000000000000000000000\r\n        );\r\n        return -y << 63;\r\n      } else {\r\n        bool negativeResult = false;\r\n        if (x < 0) {\r\n          x = -x;\r\n          negativeResult = true;\r\n        }\r\n        if (y < 0) {\r\n          y = -y; // We rely on overflow behavior here\r\n          negativeResult = !negativeResult;\r\n        }\r\n        uint256 absoluteResult = mulu(x, uint256(y));\r\n        if (negativeResult) {\r\n          require(\r\n            absoluteResult <= 0x8000000000000000000000000000000000000000000000000000000000000000\r\n          );\r\n          return -int256(absoluteResult); // We rely on overflow behavior here\r\n        } else {\r\n          require(\r\n            absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n          );\r\n          return int256(absoluteResult);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu(int128 x, uint256 y) internal pure returns (uint256) {\r\n    unchecked {\r\n      if (y == 0) return 0;\r\n\r\n      require(x >= 0);\r\n\r\n      uint256 lo = (uint256(int256(x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n      uint256 hi = uint256(int256(x)) * (y >> 128);\r\n\r\n      require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      hi <<= 64;\r\n\r\n      require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n      return hi + lo;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div(int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      require(y != 0);\r\n      int256 result = (int256(x) << 64) / y;\r\n      require(result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128(result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi(int256 x, int256 y) internal pure returns (int128) {\r\n    unchecked {\r\n      require(y != 0);\r\n\r\n      bool negativeResult = false;\r\n      if (x < 0) {\r\n        x = -x; // We rely on overflow behavior here\r\n        negativeResult = true;\r\n      }\r\n      if (y < 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint128 absoluteResult = divuu(uint256(x), uint256(y));\r\n      if (negativeResult) {\r\n        require(absoluteResult <= 0x80000000000000000000000000000000);\r\n        return -int128(absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int128(absoluteResult); // We rely on overflow behavior here\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu(uint256 x, uint256 y) internal pure returns (int128) {\r\n    unchecked {\r\n      require(y != 0);\r\n      uint128 result = divuu(x, y);\r\n      require(result <= uint128(MAX_64x64));\r\n      return int128(result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg(int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require(x != MIN_64x64);\r\n      return -x;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs(int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require(x != MIN_64x64);\r\n      return x < 0 ? -x : x;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function inv(int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require(x != 0);\r\n      int256 result = int256(0x100000000000000000000000000000000) / x;\r\n      require(result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128(result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function avg(int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      return int128((int256(x) + int256(y)) >> 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n   * Revert on overflow or in case x * y is negative.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function gavg(int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n      int256 m = int256(x) * int256(y);\r\n      require(m >= 0);\r\n      require(m < 0x4000000000000000000000000000000000000000000000000000000000000000);\r\n      return int128(sqrtu(uint256(m)));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function pow(int128 x, uint256 y) internal pure returns (int128) {\r\n    unchecked {\r\n      bool negative = x < 0 && y & 1 == 1;\r\n\r\n      uint256 absX = uint128(x < 0 ? -x : x);\r\n      uint256 absResult;\r\n      absResult = 0x100000000000000000000000000000000;\r\n\r\n      if (absX <= 0x10000000000000000) {\r\n        absX <<= 63;\r\n        while (y != 0) {\r\n          if (y & 0x1 != 0) {\r\n            absResult = (absResult * absX) >> 127;\r\n          }\r\n          absX = (absX * absX) >> 127;\r\n\r\n          if (y & 0x2 != 0) {\r\n            absResult = (absResult * absX) >> 127;\r\n          }\r\n          absX = (absX * absX) >> 127;\r\n\r\n          if (y & 0x4 != 0) {\r\n            absResult = (absResult * absX) >> 127;\r\n          }\r\n          absX = (absX * absX) >> 127;\r\n\r\n          if (y & 0x8 != 0) {\r\n            absResult = (absResult * absX) >> 127;\r\n          }\r\n          absX = (absX * absX) >> 127;\r\n\r\n          y >>= 4;\r\n        }\r\n\r\n        absResult >>= 64;\r\n      } else {\r\n        uint256 absXShift = 63;\r\n        if (absX < 0x1000000000000000000000000) {\r\n          absX <<= 32;\r\n          absXShift -= 32;\r\n        }\r\n        if (absX < 0x10000000000000000000000000000) {\r\n          absX <<= 16;\r\n          absXShift -= 16;\r\n        }\r\n        if (absX < 0x1000000000000000000000000000000) {\r\n          absX <<= 8;\r\n          absXShift -= 8;\r\n        }\r\n        if (absX < 0x10000000000000000000000000000000) {\r\n          absX <<= 4;\r\n          absXShift -= 4;\r\n        }\r\n        if (absX < 0x40000000000000000000000000000000) {\r\n          absX <<= 2;\r\n          absXShift -= 2;\r\n        }\r\n        if (absX < 0x80000000000000000000000000000000) {\r\n          absX <<= 1;\r\n          absXShift -= 1;\r\n        }\r\n\r\n        uint256 resultShift = 0;\r\n        while (y != 0) {\r\n          require(absXShift < 64);\r\n\r\n          if (y & 0x1 != 0) {\r\n            absResult = (absResult * absX) >> 127;\r\n            resultShift += absXShift;\r\n            if (absResult > 0x100000000000000000000000000000000) {\r\n              absResult >>= 1;\r\n              resultShift += 1;\r\n            }\r\n          }\r\n          absX = (absX * absX) >> 127;\r\n          absXShift <<= 1;\r\n          if (absX >= 0x100000000000000000000000000000000) {\r\n            absX >>= 1;\r\n            absXShift += 1;\r\n          }\r\n\r\n          y >>= 1;\r\n        }\r\n\r\n        require(resultShift < 64);\r\n        absResult >>= 64 - resultShift;\r\n      }\r\n      int256 result = negative ? -int256(absResult) : int256(absResult);\r\n      require(result >= MIN_64x64 && result <= MAX_64x64);\r\n      return int128(result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sqrt(int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require(x >= 0);\r\n      return int128(sqrtu(uint256(int256(x)) << 64));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate binary logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function log_2(int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require(x > 0);\r\n\r\n      int256 msb = 0;\r\n      int256 xc = x;\r\n      if (xc >= 0x10000000000000000) {\r\n        xc >>= 64;\r\n        msb += 64;\r\n      }\r\n      if (xc >= 0x100000000) {\r\n        xc >>= 32;\r\n        msb += 32;\r\n      }\r\n      if (xc >= 0x10000) {\r\n        xc >>= 16;\r\n        msb += 16;\r\n      }\r\n      if (xc >= 0x100) {\r\n        xc >>= 8;\r\n        msb += 8;\r\n      }\r\n      if (xc >= 0x10) {\r\n        xc >>= 4;\r\n        msb += 4;\r\n      }\r\n      if (xc >= 0x4) {\r\n        xc >>= 2;\r\n        msb += 2;\r\n      }\r\n      if (xc >= 0x2) msb += 1; // No need to shift xc anymore\r\n\r\n      int256 result = (msb - 64) << 64;\r\n      uint256 ux = uint256(int256(x)) << uint256(127 - msb);\r\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n        ux *= ux;\r\n        uint256 b = ux >> 255;\r\n        ux >>= 127 + b;\r\n        result += bit * int256(b);\r\n      }\r\n\r\n      return int128(result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate natural logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function ln(int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require(x > 0);\r\n\r\n      return\r\n        int128(int256((uint256(int256(log_2(x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2(int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require(x < 0x400000000000000000); // Overflow\r\n\r\n      if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n\r\n      if (x & 0x8000000000000000 > 0)\r\n        result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\r\n      if (x & 0x4000000000000000 > 0)\r\n        result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;\r\n      if (x & 0x2000000000000000 > 0)\r\n        result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;\r\n      if (x & 0x1000000000000000 > 0)\r\n        result = (result * 0x10B5586CF9890F6298B92B71842A98363) >> 128;\r\n      if (x & 0x800000000000000 > 0) result = (result * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;\r\n      if (x & 0x400000000000000 > 0) result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;\r\n      if (x & 0x200000000000000 > 0) result = (result * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;\r\n      if (x & 0x100000000000000 > 0) result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;\r\n      if (x & 0x80000000000000 > 0) result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;\r\n      if (x & 0x40000000000000 > 0) result = (result * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;\r\n      if (x & 0x20000000000000 > 0) result = (result * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;\r\n      if (x & 0x10000000000000 > 0) result = (result * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;\r\n      if (x & 0x8000000000000 > 0) result = (result * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;\r\n      if (x & 0x4000000000000 > 0) result = (result * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;\r\n      if (x & 0x2000000000000 > 0) result = (result * 0x1000162E525EE054754457D5995292026) >> 128;\r\n      if (x & 0x1000000000000 > 0) result = (result * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;\r\n      if (x & 0x800000000000 > 0) result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;\r\n      if (x & 0x400000000000 > 0) result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;\r\n      if (x & 0x200000000000 > 0) result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\r\n      if (x & 0x100000000000 > 0) result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\r\n      if (x & 0x80000000000 > 0) result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;\r\n      if (x & 0x40000000000 > 0) result = (result * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;\r\n      if (x & 0x20000000000 > 0) result = (result * 0x100000162E430E5A18F6119E3C02282A5) >> 128;\r\n      if (x & 0x10000000000 > 0) result = (result * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;\r\n      if (x & 0x8000000000 > 0) result = (result * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;\r\n      if (x & 0x4000000000 > 0) result = (result * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;\r\n      if (x & 0x2000000000 > 0) result = (result * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;\r\n      if (x & 0x1000000000 > 0) result = (result * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;\r\n      if (x & 0x800000000 > 0) result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;\r\n      if (x & 0x400000000 > 0) result = (result * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;\r\n      if (x & 0x200000000 > 0) result = (result * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;\r\n      if (x & 0x100000000 > 0) result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\r\n      if (x & 0x80000000 > 0) result = (result * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;\r\n      if (x & 0x40000000 > 0) result = (result * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;\r\n      if (x & 0x20000000 > 0) result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\r\n      if (x & 0x10000000 > 0) result = (result * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;\r\n      if (x & 0x8000000 > 0) result = (result * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;\r\n      if (x & 0x4000000 > 0) result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;\r\n      if (x & 0x2000000 > 0) result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\r\n      if (x & 0x1000000 > 0) result = (result * 0x10000000000B17217F7D20CF927C8E94C) >> 128;\r\n      if (x & 0x800000 > 0) result = (result * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;\r\n      if (x & 0x400000 > 0) result = (result * 0x100000000002C5C85FDF477B662B26945) >> 128;\r\n      if (x & 0x200000 > 0) result = (result * 0x10000000000162E42FEFA3AE53369388C) >> 128;\r\n      if (x & 0x100000 > 0) result = (result * 0x100000000000B17217F7D1D351A389D40) >> 128;\r\n      if (x & 0x80000 > 0) result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;\r\n      if (x & 0x40000 > 0) result = (result * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;\r\n      if (x & 0x20000 > 0) result = (result * 0x100000000000162E42FEFA39FE95583C2) >> 128;\r\n      if (x & 0x10000 > 0) result = (result * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;\r\n      if (x & 0x8000 > 0) result = (result * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;\r\n      if (x & 0x4000 > 0) result = (result * 0x10000000000002C5C85FDF473E242EA38) >> 128;\r\n      if (x & 0x2000 > 0) result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\r\n      if (x & 0x1000 > 0) result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\r\n      if (x & 0x800 > 0) result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\r\n      if (x & 0x400 > 0) result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\r\n      if (x & 0x200 > 0) result = (result * 0x10000000000000162E42FEFA39EF44D91) >> 128;\r\n      if (x & 0x100 > 0) result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\r\n      if (x & 0x80 > 0) result = (result * 0x10000000000000058B90BFBE8E7BCE544) >> 128;\r\n      if (x & 0x40 > 0) result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\r\n      if (x & 0x20 > 0) result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\r\n      if (x & 0x10 > 0) result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\r\n      if (x & 0x8 > 0) result = (result * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;\r\n      if (x & 0x4 > 0) result = (result * 0x10000000000000002C5C85FDF473DE6B2) >> 128;\r\n      if (x & 0x2 > 0) result = (result * 0x1000000000000000162E42FEFA39EF358) >> 128;\r\n      if (x & 0x1 > 0) result = (result * 0x10000000000000000B17217F7D1CF79AB) >> 128;\r\n\r\n      result >>= uint256(int256(63 - (x >> 64)));\r\n      require(result <= uint256(int256(MAX_64x64)));\r\n\r\n      return int128(int256(result));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp(int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n      require(x < 0x400000000000000000); // Overflow\r\n\r\n      if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n      return exp_2(int128((int256(x) * 0x171547652B82FE1777D0FFDA0D23A7D12) >> 128));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu(uint256 x, uint256 y) private pure returns (uint128) {\r\n    unchecked {\r\n      require(y != 0);\r\n\r\n      uint256 result;\r\n\r\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) result = (x << 64) / y;\r\n      else {\r\n        uint256 msb = 192;\r\n        uint256 xc = x >> 192;\r\n        if (xc >= 0x100000000) {\r\n          xc >>= 32;\r\n          msb += 32;\r\n        }\r\n        if (xc >= 0x10000) {\r\n          xc >>= 16;\r\n          msb += 16;\r\n        }\r\n        if (xc >= 0x100) {\r\n          xc >>= 8;\r\n          msb += 8;\r\n        }\r\n        if (xc >= 0x10) {\r\n          xc >>= 4;\r\n          msb += 4;\r\n        }\r\n        if (xc >= 0x4) {\r\n          xc >>= 2;\r\n          msb += 2;\r\n        }\r\n        if (xc >= 0x2) msb += 1; // No need to shift xc anymore\r\n\r\n        result = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1);\r\n        require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n        uint256 hi = result * (y >> 128);\r\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n        uint256 xh = x >> 192;\r\n        uint256 xl = x << 64;\r\n\r\n        if (xl < lo) xh -= 1;\r\n        xl -= lo; // We rely on overflow behavior here\r\n        lo = hi << 128;\r\n        if (xl < lo) xh -= 1;\r\n        xl -= lo; // We rely on overflow behavior here\r\n\r\n        assert(xh == hi >> 128);\r\n\r\n        result += xl / y;\r\n      }\r\n\r\n      require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return uint128(result);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu(uint256 x) private pure returns (uint128) {\r\n    unchecked {\r\n      if (x == 0) return 0;\r\n      else {\r\n        uint256 xx = x;\r\n        uint256 r = 1;\r\n        if (xx >= 0x100000000000000000000000000000000) {\r\n          xx >>= 128;\r\n          r <<= 64;\r\n        }\r\n        if (xx >= 0x10000000000000000) {\r\n          xx >>= 64;\r\n          r <<= 32;\r\n        }\r\n        if (xx >= 0x100000000) {\r\n          xx >>= 32;\r\n          r <<= 16;\r\n        }\r\n        if (xx >= 0x10000) {\r\n          xx >>= 16;\r\n          r <<= 8;\r\n        }\r\n        if (xx >= 0x100) {\r\n          xx >>= 8;\r\n          r <<= 4;\r\n        }\r\n        if (xx >= 0x10) {\r\n          xx >>= 4;\r\n          r <<= 2;\r\n        }\r\n        if (xx >= 0x8) {\r\n          r <<= 1;\r\n        }\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1; // Seven iterations should be enough\r\n        uint256 r1 = x / r;\r\n        return uint128(r < r1 ? r : r1);\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/Mocks/XReceiveMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\ncontract XReceiveMock {\r\n  address dao;\r\n  address public xprovider;\r\n  uint256 public value;\r\n\r\n  modifier onlyXProvider() {\r\n    require(msg.sender == xprovider);\r\n    _;\r\n  }\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"ConnextProvider: only DAO\");\r\n    _;\r\n  }\r\n\r\n  constructor(address _dao) {\r\n    dao = _dao;\r\n  }\r\n\r\n  function setXProvider(address _xprovider) external onlyDao {\r\n    xprovider = _xprovider;\r\n  }\r\n\r\n  function xReceiveAndSetSomeValue(uint256 _value) external onlyXProvider {\r\n    value = _value;\r\n  }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 5
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}