{
  "language": "Solidity",
  "sources": {
    "contracts/XProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IVault.sol\";\nimport \"./Interfaces/IGame.sol\";\nimport \"./Interfaces/ExternalInterfaces/IConnext.sol\";\nimport \"./Interfaces/ExternalInterfaces/IXReceiver.sol\";\n\ncontract XProvider is IXReceiver {\n  using SafeERC20 for IERC20;\n\n  address public immutable connext;\n\n  address private dao;\n  address private guardian;\n  address public game;\n\n  uint32 public homeChain;\n  uint32 public gameChain;\n\n  // Slippage tolerance and router fee for cross-chain swap, in BPS (i.e. 30 = 0.3%).\n  uint256 public connextRouterFee;\n  uint256 public slippage;\n\n  // minimum ether value for cross chain messages through connext\n  uint256 public minimumConnextFee;\n\n  // (domainID => contract address) mapping domainIDs to trusted remote xProvider on that specific domain\n  mapping(uint32 => address) public trustedRemoteConnext;\n  // (vaultAddress => bool): used for whitelisting vaults\n  mapping(address => bool) public vaultWhitelist;\n  // (vaultNumber => vaultAddress): used for guardian when xCall fails\n  mapping(uint256 => address) public vaults;\n\n  string public etherNotUsed = \"Ether sent not used\";\n  string public minValue = \"Minimum msg value\";\n\n  event SetTrustedRemote(uint32 _srcChainId, bytes _srcAddress);\n  event SetTrustedRemoteConnext(uint32 _srcChainId, address _srcAddress);\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"xProvider: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  modifier onlyVaults() {\n    require(vaultWhitelist[msg.sender], \"xProvider: only vault\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"xProvider: only Game\");\n    _;\n  }\n\n  /// @notice Solution for the low-level call in xReceive that is seen as an external call\n  modifier onlySelf() {\n    require(msg.sender == address(this), \"xProvider: only Self\");\n    _;\n  }\n\n  modifier onlySelfOrVault() {\n    require(\n      msg.sender == address(this) || vaultWhitelist[msg.sender],\n      \"xProvider: only Self or Vault\"\n    );\n    _;\n  }\n\n  /** @notice A modifier for authenticated calls.\n   * This is an important security consideration. If the target contract\n   * function should be authenticated, it must check three things:\n   *    1) The originating call comes from the expected origin domain.\n   *    2) The originating call comes from the expected source contract.\n   *    3) The call to this contract comes from Connext.\n   */\n  modifier onlySource(address _originSender, uint32 _origin) {\n    require(\n      trustedRemoteConnext[_origin] != address(0) &&\n        _originSender == trustedRemoteConnext[_origin] &&\n        msg.sender == connext,\n      \"Not trusted\"\n    );\n    _;\n  }\n\n  constructor(address _connext, address _dao, address _guardian, address _game, uint32 _homeChain) {\n    connext = _connext;\n    dao = _dao;\n    guardian = _guardian;\n    game = _game;\n    homeChain = _homeChain;\n    connextRouterFee = 5; // 0.05%\n    slippage = 50; // 0.5%\n    minimumConnextFee = 0.03 ether;\n  }\n\n  /// @notice Transfers funds from one chain to another using the Connext contract.\n  /// @dev The function first checks if the destination domain is trusted, then transfers\n  ///      and approves the specified token (if any), and finally calls the Connext contract to\n  ///      perform the cross-chain transfer.\n  /// @param _destinationDomain The destination domain ID.\n  /// @param _callData Additional data to be included in the cross-chain transfer.\n  /// @param _asset Address of the token on this domain (use address(0) for non currency transfers).\n  /// @param _amount The amount to transfer.\n  function xSend(\n    uint32 _destinationDomain,\n    bytes memory _callData,\n    address _asset,\n    uint256 _amount\n  ) internal {\n    address target = trustedRemoteConnext[_destinationDomain];\n    require(target != address(0), \"XProvider: destination chain not trusted\");\n\n    if (_asset != address(0)) transferAndApprove(_asset, _amount);\n\n    IConnext(connext).xcall{value: msg.value}(\n      _destinationDomain, // _destination: Domain ID of the destination chain\n      target, // _to: address receiving the funds on the destination\n      _asset, // _asset: address of the token contract\n      guardian, // _delegate: address that can revert or forceLocal on destination\n      _amount, // _amount: amount of tokens to transfer\n      slippage, // _slippage: the maximum amount of slippage the user will accept in BPS (e.g. 30 = 0.3%)\n      _callData // _callData: empty bytes because we're only sending funds\n    );\n  }\n\n  /// @notice Transfers the specified amount of tokens from the user to this contract,\n  ///         and approves the transfer of the same amount to the Connext contract.\n  /// @dev This function is called within the xSend function.\n  /// @param _asset The address of the token to transfer and approve.\n  /// @param _amount The amount of tokens to transfer and approve.\n  function transferAndApprove(address _asset, uint256 _amount) internal {\n    require(\n      IERC20(_asset).allowance(msg.sender, address(this)) >= _amount,\n      \"User must approve amount\"\n    );\n    // User sends funds to this contract\n    IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);\n    // This contract approves transfer to Connext\n    IERC20(_asset).safeIncreaseAllowance(address(connext), _amount);\n  }\n\n  /// @notice function implemented from IXReceive from connext, standard way to receive messages with connext.\n  /// @param _transferId not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _amount not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _asset not used here because only relevant in case of a value transfer. Still in the signature to comply with IXReceive.\n  /// @param _originSender sender contract.\n  /// @param _origin sender domain id.\n  /// @param _callData calldata, contains function signature which has to be called in this contract as well as the values, hashed and encoded.\n  function xReceive(\n    bytes32 _transferId,\n    uint256 _amount,\n    address _asset,\n    address _originSender,\n    uint32 _origin,\n    bytes memory _callData\n  ) external onlySource(_originSender, _origin) returns (bytes memory) {\n    (bool success, ) = address(this).call(_callData);\n    require(success, \"xReceive: No success\");\n  }\n\n  /// @notice Game pushes deltaAllocations to vaults\n  /// @notice Push protocol allocation array from the game to all vaults/chains\n  /// @param _chainId Number of chain used\n  /// @param _vault Address of the vault on given chainId\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\n  function pushProtocolAllocationsToVault(\n    uint32 _chainId,\n    address _vault,\n    int256[] memory _deltas\n  ) external payable onlyGame {\n    if (_chainId == homeChain) {\n      require(msg.value == 0, etherNotUsed);\n      return IVault(_vault).receiveProtocolAllocations(_deltas);\n    } else {\n      require(msg.value >= minimumConnextFee, minValue);\n      bytes4 selector = bytes4(keccak256(\"receiveProtocolAllocationsToVault(address,int256[])\"));\n      bytes memory callData = abi.encodeWithSelector(selector, _vault, _deltas);\n\n      xSend(_chainId, callData, address(0), 0);\n    }\n  }\n\n  /// @notice Game pushes deltaAllocations to vaults\n  /// @notice Receives protocol allocation array from the game to all vaults/chains\n  /// @param _vault Address of the vault on given chainId\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\n  function receiveProtocolAllocationsToVault(\n    address _vault,\n    int256[] memory _deltas\n  ) external onlySelf {\n    return IVault(_vault).receiveProtocolAllocations(_deltas);\n  }\n\n  /// @notice Game pushes user rewards to vaults\n  /// @param _chainId Number of chain used\n  /// @param _vault Address of the vault on given chainId\n  /// @param _user Address of the user who wants to redeem rewards\n  /// @param _value Rewards to be redeemed by the user, in\n  function pushRewardsToVault(\n    uint32 _chainId,\n    address _vault,\n    address _user,\n    uint256 _value\n  ) external payable onlyGame {\n    if (_chainId == homeChain) {\n      require(msg.value == 0, etherNotUsed);\n      return IVault(_vault).redeemRewardsGame(_value, _user);\n    } else {\n      require(msg.value >= minimumConnextFee, minValue);\n      bytes4 selector = bytes4(keccak256(\"receiveRewardsToVault(uint256,address,address)\"));\n      bytes memory callData = abi.encodeWithSelector(selector, _value, _user, _vault);\n\n      xSend(_chainId, callData, address(0), 0);\n    }\n  }\n\n  /// @notice Game pushes rewards of a user to vault for the user to redeem them\n  /// @param _value Address of the vault on given chainId\n  /// @param _user Array with delta allocations where the index matches the protocolId\n  /// @param _vault Address of the vault on given chainId\n  function receiveRewardsToVault(uint256 _value, address _user, address _vault) external onlySelf {\n    return IVault(_vault).redeemRewardsGame(_value, _user);\n  }\n\n  /// @notice Step 9 push; Vaults push rewardsPerLockedToken to game\n  /// @notice Push price and rewards array from vaults to the game\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function pushRewardsToGame(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external payable onlyVaults {\n    if (homeChain == gameChain) {\n      require(msg.value == 0, etherNotUsed);\n      return IGame(game).settleRewards(_vaultNumber, _chainId, _rewards);\n    } else {\n      require(msg.value >= minimumConnextFee, minValue);\n      bytes4 selector = bytes4(keccak256(\"receiveRewardsToGame(uint256,uint32,int256[])\"));\n      bytes memory callData = abi.encodeWithSelector(selector, _vaultNumber, _chainId, _rewards);\n\n      xSend(gameChain, callData, address(0), 0);\n    }\n  }\n\n  /// @notice Step 9 receive; Vaults push rewardsPerLockedToken to game\n  /// @notice Receives price and rewards array from vaults to the game\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function receiveRewardsToGame(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external onlySelf {\n    return IGame(game).settleRewards(_vaultNumber, _chainId, _rewards);\n  }\n\n  /// @notice Calculates the estimated amount after accounting for connextRouterFee and slippage.\n  /// @dev This function computes the estimated amount by subtracting the percentage fees from the input amount.\n  /// @param _amount The initial amount to be transferred, in vaultcurrency.decimals().\n  /// @return estAmount The estimated amount after accounting for connextRouterFee and slippage.\n  function calculateEstimatedAmount(uint256 _amount) public view returns (uint256) {\n    uint256 estAmount = _amount -\n      ((_amount * connextRouterFee) / 10_000) -\n      ((_amount * slippage) / 10_000);\n    return estAmount;\n  }\n\n  /// @notice Getter for dao address\n  function getDao() public view returns (address) {\n    return dao;\n  }\n\n  /*\n  Only Dao functions\n  */\n  /// @notice set trusted provider on remote chains, allow owner to set it multiple times.\n  /// @param _srcChainId Chain is for remote xprovider, some as the remote receiving contract chain id (xReceive)\n  /// @param _srcAddress Address of remote xprovider\n  function setTrustedRemoteConnext(uint32 _srcChainId, address _srcAddress) external onlyDao {\n    trustedRemoteConnext[_srcChainId] = _srcAddress;\n    emit SetTrustedRemoteConnext(_srcChainId, _srcAddress);\n  }\n\n  /// @notice Setter for homeChain Id\n  /// @param _homeChain New home chainId\n  function setHomeChain(uint32 _homeChain) external onlyDao {\n    homeChain = _homeChain;\n  }\n\n  /// @notice Setter for gameChain Id\n  /// @param _gameChain New chainId for game contract\n  function setGameChainId(uint32 _gameChain) external onlyDao {\n    gameChain = _gameChain;\n  }\n\n  /// @notice Whitelists vault address for onlyVault modifier\n  function toggleVaultWhitelist(address _vault) external onlyDao {\n    vaultWhitelist[_vault] = !vaultWhitelist[_vault];\n  }\n\n  /// @notice Setter for dao address\n  function setDao(address _dao) external onlyDao {\n    dao = _dao;\n  }\n\n  /// @notice Setter for guardian address\n  /// @param _guardian new address of the guardian\n  function setGuardian(address _guardian) external onlyDao {\n    guardian = _guardian;\n  }\n\n  /// @notice Setter for new game address\n  /// @param _game New address of the game\n  function setGame(address _game) external onlyDao {\n    game = _game;\n  }\n\n  /// @notice Setter for vault address to vaultNumber for guardian\n  function setVaultAddress(uint256 _vaultNumber, address _vault) external onlyDao {\n    vaults[_vaultNumber] = _vault;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice Sets the connextRouterFee variable.\n  /// @param _connextRouterFee The new value for the connextRouterFee.\n  function setConnextRouterFee(uint256 _connextRouterFee) external onlyGuardian {\n    connextRouterFee = _connextRouterFee;\n  }\n\n  /// @notice Sets the slippage variable.\n  /// @param _slippage The new value for the slippage.\n  function setSlippage(uint256 _slippage) external onlyGuardian {\n    slippage = _slippage;\n  }\n\n  /// @dev Sets the minimum ether value for cross chain messages through Connext.\n  /// @param _newMinimumConnextFee The new minimum Connext fee in ether to be set.\n  function setMinimumConnextFee(uint256 _newMinimumConnextFee) external onlyGuardian {\n    minimumConnextFee = _newMinimumConnextFee;\n  }\n}\n"
    },
    "contracts/Interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\ninterface IVault {\n  function rebalancingPeriod() external view returns (uint256);\n\n  function price(uint256) external view returns (uint256);\n\n  function setDeltaAllocations(uint256 _protocolNum, int256 _allocation) external;\n\n  function rewardPerLockedToken(\n    uint256 _rebalancingPeriod,\n    uint256 _protocolNum\n  ) external view returns (int256);\n\n  function performanceFee() external view returns (uint256);\n\n  function receiveProtocolAllocations(int256[] memory _deltas) external;\n\n  function decimals() external view returns (uint256);\n\n  function redeemRewardsGame(uint256 _amount, address _user) external;\n}\n"
    },
    "contracts/Interfaces/IGame.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\ninterface IGame {\n  function settleRewards(uint256 _vaultNumber, uint32 _chainId, int256[] memory rewards) external;\n}\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IConnext.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\ninterface IConnext {\n  function xcall(\n    uint32 _destination,\n    address _to,\n    address _asset,\n    address _delegate,\n    uint256 _amount,\n    uint256 _slippage,\n    bytes calldata _callData\n  ) external payable returns (bytes32);\n}\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IXReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\ninterface IXReceiver {\n  function xReceive(\n    bytes32 _transferId,\n    uint256 _amount,\n    address _asset,\n    address _originSender,\n    uint32 _origin,\n    bytes memory _callData\n  ) external returns (bytes memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/Game.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./DerbyToken.sol\";\n\nimport \"./Interfaces/IVault.sol\";\nimport \"./Interfaces/IXProvider.sol\";\n\ncontract Game is ERC721, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  struct Basket {\n    // the vault number for which this Basket was created\n    uint256 vaultNumber;\n    // the chainId for which this Basket was created\n    uint32 chainId;\n    // last period when this Basket got rebalanced\n    uint256 lastRebalancingPeriod;\n    // nr of total allocated tokens\n    int256 nrOfAllocatedTokens;\n    // total build up rewards\n    int256 totalUnRedeemedRewards; // In vaultCurrency.decimals() * BASE_SCALE of 1e18\n    // total redeemed rewards\n    int256 totalRedeemedRewards; // In vaultCurrency.decimals()\n    // (protocolNumber => allocation)\n    mapping(uint256 => int256) allocations;\n  }\n\n  struct vaultInfo {\n    address vaultAddress;\n    int256 deltaAllocationsVault;\n    bool rewardsReceived;\n    uint256 latestProtocolId;\n    // (protocolNumber => deltaAllocation)\n    mapping(uint256 => int256) deltaAllocationProtocol;\n    // (rebalancing period => protocol id => rewardPerLockedToken).\n    // in BASE_SCALE * vaultCurrency.decimals() nr of decimals (BASE_SCALE (same as DerbyToken.decimals()))\n    mapping(uint256 => mapping(uint256 => int256)) rewardPerLockedToken;\n  }\n\n  address private dao;\n  address private guardian;\n  address public xProvider;\n\n  IERC20 public derbyToken;\n\n  // used in notInSameBlock modifier\n  uint256 private lastBlock;\n\n  // latest basket id\n  uint256 private latestBasketId;\n\n  // interval in Unix timeStamp\n  uint256 public rebalanceInterval; // SHOULD BE REPLACED FOR REALISTIC NUMBER\n\n  // last rebalance timeStamp\n  mapping(uint256 => uint256) public lastTimeStamp;\n\n  // threshold in vaultCurrency e.g USDC for when user tokens will be sold / burned. Must be negative\n  int256 internal negativeRewardThreshold;\n  // percentage of tokens that will be sold at negative rewards\n  uint256 internal negativeRewardFactor;\n  // vaultNumber => tokenPrice || price of vaultCurrency / derbyToken\n  mapping(uint256 => uint256) public tokenPrice;\n\n  // used to scale rewards\n  uint256 public BASE_SCALE = 1e18;\n\n  // vaultNumber => vaultAddress\n  mapping(uint256 => address) public homeVault;\n\n  // baskets, maps tokenID from BasketToken NFT contract to the Basket struct in this contract.\n  // (basketTokenId => basket struct):\n  mapping(uint256 => Basket) private baskets;\n\n  // (chainId => vaultNumber => vaultInfo struct)\n  mapping(uint32 => mapping(uint256 => vaultInfo)) internal vaults;\n\n  event PushProtocolAllocations(uint32 chain, address vault, int256[] deltas);\n\n  event BasketId(address owner, uint256 basketId);\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"Game: only DAO\");\n    _;\n  }\n\n  modifier onlyBasketOwner(uint256 _basketId) {\n    require(msg.sender == ownerOf(_basketId), \"Game: Not the owner of the basket\");\n    _;\n  }\n\n  modifier onlyXProvider() {\n    require(msg.sender == xProvider, \"Game: only xProvider\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"Game: only Guardian\");\n    _;\n  }\n\n  modifier notInSameBlock() {\n    require(block.number != lastBlock, \"Cannot call functions in the same block\");\n    lastBlock = block.number;\n    _;\n  }\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    address _derbyToken,\n    address _dao,\n    address _guardian\n  ) ERC721(name_, symbol_) {\n    derbyToken = IERC20(_derbyToken);\n    dao = _dao;\n    guardian = _guardian;\n  }\n\n  /// @notice Setter for delta allocation in a particulair chainId\n  /// @param _chainId number of chainId\n  /// @param _vaultNumber number of vault\n  /// @param _deltaAllocationsVault delta allocation\n  function addDeltaAllocationsVault(\n    uint32 _chainId,\n    uint256 _vaultNumber,\n    int256 _deltaAllocationsVault\n  ) internal {\n    vaults[_chainId][_vaultNumber].deltaAllocationsVault += _deltaAllocationsVault;\n  }\n\n  /// @notice Getter for delta allocation in a particulair chainId\n  /// @param _chainId number of chainId\n  /// @param _vaultNumber number of vault\n  /// @return allocation delta allocation\n  function getDeltaAllocationsVault(\n    uint32 _chainId,\n    uint256 _vaultNumber\n  ) public view returns (int256) {\n    return vaults[_chainId][_vaultNumber].deltaAllocationsVault;\n  }\n\n  /// @notice Setter for the delta allocation in Protocol vault e.g compound_usdc_01\n  /// @dev Allocation can be negative\n  /// @param _chainId number of chainId\n  /// @param _vaultNumber number of vault\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  /// @param _deltaAllocation Delta allocation in tokens\n  function addDeltaAllocationsProtocol(\n    uint32 _chainId,\n    uint256 _vaultNumber,\n    uint256 _protocolNum,\n    int256 _deltaAllocation\n  ) internal {\n    vaults[_chainId][_vaultNumber].deltaAllocationProtocol[_protocolNum] += _deltaAllocation;\n  }\n\n  /// @notice Getter for the delta allocation in Protocol vault e.g compound_usdc_01\n  /// @param _chainId number of chainId\n  /// @param _vaultNumber number of vault\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  /// @return allocation Delta allocation in tokens\n  function getDeltaAllocationsProtocol(\n    uint32 _chainId,\n    uint256 _vaultNumber,\n    uint256 _protocolNum\n  ) public view returns (int256) {\n    return vaults[_chainId][_vaultNumber].deltaAllocationProtocol[_protocolNum];\n  }\n\n  /// @notice Setter to set the total number of allocated tokens. Only the owner of the basket can set this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @param _allocation Number of derby tokens that are allocated towards protocols.\n  function setBasketTotalAllocatedTokens(\n    uint256 _basketId,\n    int256 _allocation\n  ) internal onlyBasketOwner(_basketId) {\n    baskets[_basketId].nrOfAllocatedTokens += _allocation;\n    require(basketTotalAllocatedTokens(_basketId) >= 0, \"Basket: underflow\");\n  }\n\n  /// @notice function to see the total number of allocated tokens. Only the owner of the basket can view this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @return int256 Number of derby tokens that are allocated towards protocols.\n  function basketTotalAllocatedTokens(uint256 _basketId) public view returns (int256) {\n    return baskets[_basketId].nrOfAllocatedTokens;\n  }\n\n  /// @notice Setter to set the allocation of a specific protocol by a basketId. Only the owner of the basket can set this.\n  /// @param _chainId Chain ID of the vault\n  /// @param _vaultNumber Number of the vault\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @param _protocolId Id of the protocol of which the allocation is queried.\n  /// @param _allocation Number of derby tokens that are allocated towards this specific protocol.\n  function setBasketAllocationInProtocol(\n    uint32 _chainId,\n    uint256 _vaultNumber,\n    uint256 _basketId,\n    uint256 _protocolId,\n    int256 _allocation\n  ) internal onlyBasketOwner(_basketId) {\n    baskets[_basketId].allocations[_protocolId] += _allocation;\n\n    int256 currentAllocation = basketAllocationInProtocol(_basketId, _protocolId);\n    require(currentAllocation >= 0, \"Basket: underflow\");\n\n    int256 currentReward = getRewardsPerLockedToken(\n      _chainId,\n      _vaultNumber,\n      getRebalancingPeriod(_vaultNumber),\n      _protocolId\n    );\n\n    if (currentReward == -1) {\n      require(currentAllocation == 0, \"Allocations to blacklisted protocol\");\n    }\n  }\n\n  /// @notice function to see the allocation of a specific protocol by a basketId. Only the owner of the basket can view this\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _protocolId Id of the protocol of which the allocation is queried\n  /// @return int256 Number of derby tokens that are allocated towards this specific protocol\n  function basketAllocationInProtocol(\n    uint256 _basketId,\n    uint256 _protocolId\n  ) public view onlyBasketOwner(_basketId) returns (int256) {\n    return baskets[_basketId].allocations[_protocolId];\n  }\n\n  /// @notice Setter for rebalancing period of the basket, used to calculate the rewards\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _vaultNumber number of vault\n  function setBasketRebalancingPeriod(\n    uint256 _basketId,\n    uint256 _vaultNumber\n  ) internal onlyBasketOwner(_basketId) {\n    baskets[_basketId].lastRebalancingPeriod = getRebalancingPeriod(_vaultNumber) + 1;\n  }\n\n  /// @notice function to see the total unredeemed rewards the basket has built up. Only the owner of the basket can view this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @return int256 Total unredeemed rewards. (in vaultCurrency.decimals())\n  function basketUnredeemedRewards(\n    uint256 _basketId\n  ) external view onlyBasketOwner(_basketId) returns (int256) {\n    return baskets[_basketId].totalUnRedeemedRewards / int(BASE_SCALE);\n  }\n\n  /// @notice function to see the total reeemed rewards from the basket. Only the owner of the basket can view this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @return int256 Total redeemed rewards.\n  function basketRedeemedRewards(\n    uint256 _basketId\n  ) external view onlyBasketOwner(_basketId) returns (int) {\n    return baskets[_basketId].totalRedeemedRewards;\n  }\n\n  /// @notice Mints a new NFT with a Basket of allocations.\n  /// @dev The basket NFT is minted for a specific vault, starts with a zero allocation and the tokens are not locked here.\n  /// @param _chainId Chain ID of the vault.\n  /// @param _vaultNumber Number of the vault. Same as in Router.\n  /// @return basketId The basket Id the user has minted.\n  function mintNewBasket(\n    uint32 _chainId,\n    uint256 _vaultNumber\n  ) external nonReentrant returns (uint256) {\n    // mint Basket with nrOfUnAllocatedTokens equal to _lockedTokenAmount\n    baskets[latestBasketId].chainId = _chainId;\n    baskets[latestBasketId].vaultNumber = _vaultNumber;\n    baskets[latestBasketId].lastRebalancingPeriod = getRebalancingPeriod(_vaultNumber) + 1;\n    _safeMint(msg.sender, latestBasketId);\n    latestBasketId++;\n\n    emit BasketId(msg.sender, latestBasketId - 1);\n    return latestBasketId - 1;\n  }\n\n  /// @notice Function to lock xaver tokens to a basket. They start out to be unallocated.\n  /// @param _lockedTokenAmount Amount of xaver tokens to lock inside this contract.\n  function lockTokensToBasket(uint256 _lockedTokenAmount) internal {\n    uint256 balanceBefore = derbyToken.balanceOf(address(this));\n    derbyToken.safeTransferFrom(msg.sender, address(this), _lockedTokenAmount);\n    uint256 balanceAfter = derbyToken.balanceOf(address(this));\n\n    require((balanceAfter - balanceBefore - _lockedTokenAmount) == 0, \"Error lock: under/overflow\");\n  }\n\n  /// @notice Function to unlock xaver tokens. If tokens are still allocated to protocols they first hevae to be unallocated.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @param _unlockedTokenAmount Amount of derby tokens to unlock and send to the user.\n  function unlockTokensFromBasket(uint256 _basketId, uint256 _unlockedTokenAmount) internal {\n    uint256 tokensBurned = redeemNegativeRewards(_basketId, _unlockedTokenAmount);\n    uint256 tokensToUnlock = _unlockedTokenAmount -= tokensBurned;\n\n    uint256 balanceBefore = derbyToken.balanceOf(address(this));\n    derbyToken.safeTransfer(msg.sender, tokensToUnlock);\n    uint256 balanceAfter = derbyToken.balanceOf(address(this));\n\n    require((balanceBefore - balanceAfter - tokensToUnlock) == 0, \"Error unlock: under/overflow\");\n  }\n\n  /// @notice IMPORTANT: The negativeRewardFactor takes in account an approximation of the price of derby tokens by the dao\n  /// @notice IMPORTANT: This will change to an exact price when there is a derby token liquidity pool\n  /// @notice Calculates if there are any negative rewards and how many tokens to burn\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _unlockedTokens Amount of derby tokens to unlock and send to user\n  /// @return tokensToBurn Amount of derby tokens that are burned\n  function redeemNegativeRewards(\n    uint256 _basketId,\n    uint256 _unlockedTokens\n  ) internal returns (uint256) {\n    if (baskets[_basketId].totalUnRedeemedRewards / int(BASE_SCALE) > negativeRewardThreshold)\n      return 0;\n\n    uint256 vaultNumber = baskets[_basketId].vaultNumber;\n    uint256 unreedemedRewards = uint(-baskets[_basketId].totalUnRedeemedRewards);\n    uint256 price = tokenPrice[vaultNumber];\n\n    uint256 tokensToBurn = (((unreedemedRewards * negativeRewardFactor) / 100) / price);\n    tokensToBurn = tokensToBurn < _unlockedTokens ? tokensToBurn : _unlockedTokens;\n\n    baskets[_basketId].totalUnRedeemedRewards += int(\n      (tokensToBurn * 100 * price) / negativeRewardFactor\n    );\n\n    IERC20(derbyToken).safeTransfer(homeVault[vaultNumber], tokensToBurn);\n\n    return tokensToBurn;\n  }\n\n  /// @notice rebalances an existing Basket\n  /// @dev First calculates the rewards the basket has built up, then sets the new allocations and communicates the deltas to the vault\n  /// @dev Finally it locks or unlocks tokens\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @param _deltaAllocations delta allocations set by the user of the basket. Allocations are scaled (so * 1E18).\n  function rebalanceBasket(\n    uint256 _basketId,\n    int256[] memory _deltaAllocations\n  ) external onlyBasketOwner(_basketId) nonReentrant {\n    uint32 chainId = baskets[_basketId].chainId;\n    uint256 vaultNumber = baskets[_basketId].vaultNumber;\n    if (getRebalancingPeriod(vaultNumber) != 0) {\n      require(vaults[chainId][vaultNumber].rewardsReceived, \"Game: rewards not settled\");\n    }\n\n    addToTotalRewards(_basketId);\n    int256 totalDelta = settleDeltaAllocations(_basketId, chainId, vaultNumber, _deltaAllocations);\n\n    lockOrUnlockTokens(_basketId, totalDelta);\n    setBasketTotalAllocatedTokens(_basketId, totalDelta);\n    setBasketRebalancingPeriod(_basketId, vaultNumber);\n  }\n\n  /// @notice Internal helper to calculate and settle the delta allocations from baskets\n  /// @dev Sets the total allocations per ChainId, used in XChainController\n  /// @dev Sets the total allocations per protocol number, used in Vaults\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _chainId Chain id of the vault where the allocations need to be sent\n  /// @param _vaultNumber number of vault\n  /// @param _deltaAllocations delta allocations set by the user of the basket. Allocations are scaled (so * 1E18)\n  /// @return totalDelta total delta allocated tokens of the basket, used in lockOrUnlockTokens\n  function settleDeltaAllocations(\n    uint256 _basketId,\n    uint32 _chainId,\n    uint256 _vaultNumber,\n    int256[] memory _deltaAllocations\n  ) internal returns (int256 totalDelta) {\n    uint32 chainId = baskets[_basketId].chainId;\n    uint256 latestProtocol = vaults[chainId][_vaultNumber].latestProtocolId;\n    require(_deltaAllocations.length == latestProtocol, \"Invalid allocation length\");\n\n    for (uint256 i = 0; i < latestProtocol; i++) {\n      int256 allocation = _deltaAllocations[i];\n      if (allocation == 0) continue;\n      totalDelta += allocation;\n      addDeltaAllocationsProtocol(_chainId, _vaultNumber, i, allocation);\n      setBasketAllocationInProtocol(_chainId, _vaultNumber, _basketId, i, allocation);\n    }\n    addDeltaAllocationsVault(_chainId, _vaultNumber, totalDelta);\n  }\n\n  /// @notice rewards are calculated here.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  function addToTotalRewards(uint256 _basketId) internal onlyBasketOwner(_basketId) {\n    if (baskets[_basketId].nrOfAllocatedTokens == 0) return;\n    uint32 chainId = baskets[_basketId].chainId;\n    uint256 vaultNum = baskets[_basketId].vaultNumber;\n    uint256 currentRebalancingPeriod = IVault(vaults[chainId][vaultNum].vaultAddress)\n      .rebalancingPeriod(); //TODO: rebalancingPeriod should be communicated differently\n    uint256 lastRebalancingPeriod = baskets[_basketId].lastRebalancingPeriod;\n    require(currentRebalancingPeriod >= lastRebalancingPeriod, \"Already rebalanced\");\n\n    uint256 latestProtocol = vaults[chainId][vaultNum].latestProtocolId;\n    for (uint i = 0; i < latestProtocol; i++) {\n      int256 allocation = basketAllocationInProtocol(_basketId, i) / 1E18;\n      if (allocation == 0) continue;\n\n      int256 currentReward = getRewardsPerLockedToken(\n        chainId,\n        vaultNum,\n        currentRebalancingPeriod,\n        i\n      );\n      // -1 means the protocol is blacklisted\n      if (currentReward == -1) continue;\n\n      int256 lastRebalanceReward = getRewardsPerLockedToken(\n        chainId,\n        vaultNum,\n        lastRebalancingPeriod,\n        i\n      );\n\n      baskets[_basketId].totalUnRedeemedRewards +=\n        (currentReward - lastRebalanceReward) *\n        allocation;\n    }\n  }\n\n  /// @notice Internal helper to lock or unlock tokens from the game contract\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _totalDelta total delta allocated tokens of the basket, calculated in settleDeltaAllocations\n  function lockOrUnlockTokens(uint256 _basketId, int256 _totalDelta) internal {\n    if (_totalDelta > 0) {\n      lockTokensToBasket(uint256(_totalDelta));\n    }\n    if (_totalDelta < 0) {\n      int256 oldTotal = basketTotalAllocatedTokens(_basketId);\n      int256 newTotal = oldTotal + _totalDelta;\n      int256 tokensToUnlock = oldTotal - newTotal;\n      require(oldTotal >= tokensToUnlock, \"Not enough tokens locked\");\n\n      unlockTokensFromBasket(_basketId, uint256(tokensToUnlock));\n    }\n  }\n\n  /// @notice Game pushes deltaAllocations to vaults\n  /// @notice Trigger to push delta allocations in protocols to cross chain vaults\n  /// @param _chainId Chain id of the vault where the allocations need to be sent\n  /// @param _vaultNumber Number of vault\n  /// @dev Sends over an array where the index is the protocolId\n  function pushAllocationsToVault(\n    uint32 _chainId,\n    uint256 _vaultNumber\n  ) external payable notInSameBlock {\n    require(rebalanceNeeded(_vaultNumber), \"No rebalance needed\");\n    address vault = getVaultAddress(_vaultNumber, _chainId);\n    require(vault != address(0), \"Game: not a valid vaultnumber\");\n\n    int256[] memory deltas = protocolAllocationsToArray(_vaultNumber, _chainId);\n\n    IXProvider(xProvider).pushProtocolAllocationsToVault{value: msg.value}(_chainId, vault, deltas);\n\n    lastTimeStamp[_vaultNumber] = block.timestamp;\n    vaults[_chainId][_vaultNumber].rewardsReceived = false;\n\n    emit PushProtocolAllocations(_chainId, vault, deltas);\n  }\n\n  /// @notice Creates array with delta allocations in protocols for given chainId\n  /// @return deltas Array with allocations where the index matches the protocolId\n  function protocolAllocationsToArray(\n    uint256 _vaultNumber,\n    uint32 _chainId\n  ) internal returns (int256[] memory deltas) {\n    uint256 latestId = vaults[_chainId][_vaultNumber].latestProtocolId;\n    deltas = new int[](latestId);\n\n    for (uint256 i = 0; i < latestId; i++) {\n      deltas[i] = getDeltaAllocationsProtocol(_chainId, _vaultNumber, i);\n      vaults[_chainId][_vaultNumber].deltaAllocationProtocol[i] = 0;\n    }\n  }\n\n  /// @notice See settleRewardsInt below\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _rewards Rewards per locked token per protocol (each protocol is an element in the array)\n  function settleRewards(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external onlyXProvider {\n    settleRewardsInt(_chainId, _vaultNumber, _rewards);\n  }\n\n  // basket should not be able to rebalance before this\n  /// @notice Vaults push rewardsPerLockedToken to game\n  /// @notice Loops through the array and fills the rewardsPerLockedToken mapping with the values\n  /// @param _chainId Number of chain used\n  /// @param _vaultNumber Number of the vault\n  /// @param _rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function settleRewardsInt(\n    uint32 _chainId,\n    uint256 _vaultNumber,\n    int256[] memory _rewards\n  ) internal {\n    uint256 rebalancingPeriod = getRebalancingPeriod(_vaultNumber);\n    for (uint256 i = 0; i < _rewards.length; i++) {\n      int256 lastReward = getRewardsPerLockedToken(\n        _chainId,\n        _vaultNumber,\n        rebalancingPeriod - 1,\n        i\n      );\n      vaults[_chainId][_vaultNumber].rewardPerLockedToken[rebalancingPeriod][i] =\n        lastReward +\n        _rewards[i];\n    }\n\n    vaults[_chainId][_vaultNumber].rewardsReceived = true;\n  }\n\n  /// @notice Getter for rewardsPerLockedToken for given vaultNumber => chainId => rebalancingPeriod => protocolId\n  /// @param _chainId Number of chain used\n  /// @param _vaultNumber Number of the vault\n  /// @param _rebalancingPeriod Number of the rebalancing period\n  /// @param _protocolId Number of the protocol\n  function getRewardsPerLockedToken(\n    uint32 _chainId,\n    uint256 _vaultNumber,\n    uint256 _rebalancingPeriod,\n    uint256 _protocolId\n  ) internal view returns (int256) {\n    return vaults[_chainId][_vaultNumber].rewardPerLockedToken[_rebalancingPeriod][_protocolId];\n  }\n\n  /// @notice redeem funds from basket in the game.\n  /// @dev makes a (crosschain) call to the vault to make the actual transfer because the vault holds the funds.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  function redeemRewards(uint256 _basketId) external onlyBasketOwner(_basketId) {\n    int256 value = baskets[_basketId].totalUnRedeemedRewards / int(BASE_SCALE);\n    require(value > 0, \"Nothing to claim\");\n\n    baskets[_basketId].totalRedeemedRewards += value;\n    baskets[_basketId].totalUnRedeemedRewards = 0;\n\n    uint32 chainId = baskets[_basketId].chainId;\n    uint256 vaultNumber = baskets[_basketId].vaultNumber;\n    address vault = getVaultAddress(vaultNumber, chainId);\n\n    IXProvider(xProvider).pushRewardsToVault(chainId, vault, msg.sender, uint256(value));\n  }\n\n  /// @notice Checks if a rebalance is needed based on the set interval\n  /// @param _vaultNumber The vault number to check for rebalancing\n  /// @return bool True if rebalance is needed, false if not\n  function rebalanceNeeded(uint256 _vaultNumber) public view returns (bool) {\n    return\n      (block.timestamp - lastTimeStamp[_vaultNumber]) > rebalanceInterval || msg.sender == guardian;\n  }\n\n  /// @notice getter for vault address linked to a chainId\n  function getVaultAddress(uint256 _vaultNumber, uint32 _chainId) internal view returns (address) {\n    return vaults[_chainId][_vaultNumber].vaultAddress;\n  }\n\n  /// @notice Getter for dao address\n  function getDao() public view returns (address) {\n    return dao;\n  }\n\n  /// @notice Getter for guardian address\n  function getGuardian() public view returns (address) {\n    return guardian;\n  }\n\n  /// @notice Getter for rebalancing period for a vault\n  function getRebalancingPeriod(uint256 _vaultNumber) public view returns (uint256) {\n    return IVault(homeVault[_vaultNumber]).rebalancingPeriod();\n  }\n\n  /*\n  Only Dao functions\n  */\n\n  /// @notice Setter for xProvider address\n  /// @param _xProvider new address of xProvider on this chain\n  function setXProvider(address _xProvider) external onlyDao {\n    xProvider = _xProvider;\n  }\n\n  /// @notice Setter for homeVault address\n  /// @param _vaultNumber The vault number to set the home vault for\n  /// @param _homeVault new address of homeVault on this chain\n  function setHomeVault(uint256 _vaultNumber, address _homeVault) external onlyDao {\n    homeVault[_vaultNumber] = _homeVault;\n  }\n\n  /// @notice Set minimum interval for the rebalance function\n  /// @param _timestampInternal UNIX timestamp\n  function setRebalanceInterval(uint256 _timestampInternal) external onlyDao {\n    rebalanceInterval = _timestampInternal;\n  }\n\n  /// @notice Setter for DAO address\n  /// @param _dao DAO address\n  function setDao(address _dao) external onlyDao {\n    dao = _dao;\n  }\n\n  /// @notice Setter for guardian address\n  /// @param _guardian new address of the guardian\n  function setGuardian(address _guardian) external onlyDao {\n    guardian = _guardian;\n  }\n\n  /// @notice Setter Derby token address\n  /// @param _derbyToken new address of Derby token\n  function setDerbyToken(address _derbyToken) external onlyDao {\n    derbyToken = IERC20(_derbyToken);\n  }\n\n  /// @notice Setter for threshold at which user tokens will be sold / burned\n  /// @param _threshold treshold in vaultCurrency e.g USDC, must be negative\n  function setNegativeRewardThreshold(int256 _threshold) external onlyDao {\n    negativeRewardThreshold = _threshold;\n  }\n\n  /// @notice Setter for negativeRewardFactor\n  /// @param _factor percentage of tokens that will be sold / burned\n  function setNegativeRewardFactor(uint256 _factor) external onlyDao {\n    negativeRewardFactor = _factor;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice Setter for tokenPrice\n  /// @param _vaultNumber Number of the vault\n  /// @param _tokenPrice tokenPrice in vaultCurrency / derbyTokenPrice\n  function setTokenPrice(uint256 _vaultNumber, uint256 _tokenPrice) external onlyGuardian {\n    tokenPrice[_vaultNumber] = _tokenPrice;\n  }\n\n  /// @notice setter to link a chainId to a vault address for cross chain functions\n  function setVaultAddress(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    address _address\n  ) external onlyGuardian {\n    vaults[_chainId][_vaultNumber].vaultAddress = _address;\n  }\n\n  /// @notice Setter for latest protocol Id for given chainId.\n  /// @param _chainId number of chain id set in chainIds array\n  /// @param _vaultNumber number of vault\n  /// @param _latestProtocolId latest protocol Id aka number of supported protocol vaults, starts at 0\n  function setLatestProtocolId(\n    uint32 _chainId,\n    uint256 _vaultNumber,\n    uint256 _latestProtocolId\n  ) external onlyGuardian {\n    vaults[_chainId][_vaultNumber].latestProtocolId = _latestProtocolId;\n  }\n\n  /// @notice Guardian function\n  function settleRewardsGuard(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external onlyGuardian {\n    settleRewardsInt(_chainId, _vaultNumber, _rewards);\n  }\n\n  /// @notice setter for rewardsReceived\n  /// @param _chainId Number of chain used\n  /// @param _vaultNumber Number of the vault\n  /// @param _rewardsReceived bool to set if rewards are received\n  function setRewardsReceived(\n    uint32 _chainId,\n    uint256 _vaultNumber,\n    bool _rewardsReceived\n  ) external onlyGuardian {\n    vaults[_chainId][_vaultNumber].rewardsReceived = _rewardsReceived;\n  }\n}\n"
    },
    "contracts/DerbyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract DerbyToken is ERC20 {\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint256 _totalSupply\n  ) ERC20(_name, _symbol) {\n    _mint(msg.sender, _totalSupply);\n  }\n}\n"
    },
    "contracts/Interfaces/IXProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\ninterface IXProvider {\n  function xReceive(uint256 _value) external; // receiving a (permissioned) value crosschain.\n\n  function pushProtocolAllocationsToVault(\n    uint32 _chainId,\n    address _vault,\n    int256[] memory _deltas\n  ) external payable;\n\n  function pushRewardsToVault(\n    uint32 _chainId,\n    address _vault,\n    address _user,\n    uint256 _value\n  ) external payable;\n\n  function pushRewardsToGame(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external payable;\n\n  function calculateEstimatedAmount(uint256 _amount) external returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/Mocks/GameMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"../Game.sol\";\n\ncontract GameMock is Game {\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    address _derbyTokenAddress,\n    address _dao,\n    address _guardian\n  ) Game(name_, symbol_, _derbyTokenAddress, _dao, _guardian) {}\n\n  function lockTokensToBasketTEST(uint256 _lockedTokenAmount) public {\n    lockTokensToBasket(_lockedTokenAmount);\n  }\n\n  function addToTotalRewardsTEST(uint256 _basketId) public {\n    addToTotalRewards(_basketId);\n  }\n\n  function setDeltaAllocations(address _vault, uint256 _protocolNum, int256 _allocation) external {\n    IVault(_vault).setDeltaAllocations(_protocolNum, _allocation);\n  }\n\n  function triggerRedeemedRewardsVault(address _vault, address user, uint256 amount) external {\n    IVault(_vault).redeemRewardsGame(amount, user);\n  }\n\n  function mockRewards(uint256 _vaultNumber, uint32 _chainId, int256[] memory _rewards) external {\n    uint256 rebalancingPeriod = IVault(homeVault[_vaultNumber]).rebalancingPeriod();\n\n    for (uint256 i = 0; i < _rewards.length; i++) {\n      int256 lastReward = getRewardsPerLockedToken(\n        _chainId,\n        _vaultNumber,\n        rebalancingPeriod - 1,\n        i\n      );\n      vaults[_chainId][_vaultNumber].rewardPerLockedToken[rebalancingPeriod][i] =\n        lastReward +\n        _rewards[i];\n    }\n  }\n\n  function setRewardPerLockedTokenTEST(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _rebalancingPeriod,\n    uint256 _protocolId,\n    int256 _reward\n  ) external {\n    vaults[_chainId][_vaultNumber].rewardPerLockedToken[_rebalancingPeriod][_protocolId] = _reward;\n  }\n\n  function setRewardsReceivedTEST(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    bool _rewardsReceived\n  ) external {\n    vaults[_chainId][_vaultNumber].rewardsReceived = _rewardsReceived;\n  }\n\n  function getRewardsReceivedTEST(\n    uint256 _vaultNumber,\n    uint32 _chainId\n  ) external view returns (bool) {\n    return vaults[_chainId][_vaultNumber].rewardsReceived;\n  }\n\n  function getRewardsPerLockedTokenTEST(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _rebalancingPeriod,\n    uint256 _protocolId\n  ) external view returns (int256) {\n    return getRewardsPerLockedToken(_chainId, _vaultNumber, _rebalancingPeriod, _protocolId);\n  }\n\n  function getNegativeRewardFactor() external view returns (uint256) {\n    return negativeRewardFactor;\n  }\n\n  function getNegativeRewardThreshold() external view returns (int256) {\n    return negativeRewardThreshold;\n  }\n\n  function getVaultAddressTest(\n    uint256 _vaultNumber,\n    uint32 _chainId\n  ) external view returns (address) {\n    return getVaultAddress(_vaultNumber, _chainId);\n  }\n\n  function getVaultsLatestProtocolIdTEST(\n    uint32 _chainId,\n    uint256 _vaultNumber\n  ) external view returns (uint256) {\n    return vaults[_chainId][_vaultNumber].latestProtocolId;\n  }\n\n  function rebalanceBoth(uint256 _vaultNumber, uint32 _chain) external payable {\n    this.pushAllocationsToVault{value: msg.value / 2}(_chain, _vaultNumber);\n  }\n}\n"
    },
    "contracts/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./Interfaces/IController.sol\";\nimport \"./Interfaces/IProvider.sol\";\nimport \"./Interfaces/IXProvider.sol\";\n\nimport \"./VaultToken.sol\";\nimport \"./libraries/Swap.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Vault is ReentrancyGuard, VaultToken {\n  using SafeERC20 for IERC20Metadata;\n\n  struct UserInfo {\n    // amount in vaultCurrency the vault owes to the user\n    uint256 withdrawalAllowance;\n    // rebalancing period the withdrawal request is made\n    uint256 withdrawalRequestPeriod;\n    // amount in vaultCurrency the vault owes to the user\n    uint256 rewardAllowance;\n    // rebalancing period the reward request is made\n    uint256 rewardRequestPeriod;\n    // amount in vaultCurrency for the deposit request of the user\n    uint256 depositRequest;\n    // rebalancing period the deposit request is made\n    uint256 depositRequestPeriod;\n  }\n\n  IERC20Metadata internal vaultCurrency;\n  IController internal controller;\n\n  bool public deltaAllocationsReceived;\n\n  address public immutable nativeToken; // WETH\n  address private dao;\n  address private guardian;\n\n  uint256 public vaultNumber;\n  uint256 public liquidityPerc;\n  uint256 public performanceFee; // percentage\n  uint256 public rebalancingPeriod;\n  int256 public marginScale;\n  uint256 public exchangeRate; // always expressed in #decimals equal to the #decimals from the vaultCurrency\n\n  // used in storePriceAndRewards, must be equal to DerbyToken.decimals()\n  uint256 public BASE_SCALE = 1e18;\n\n  // UNIX timestamp\n  uint256 public rebalanceInterval;\n  uint256 public lastTimeStamp;\n\n  // total underlying of all protocols in vault, excluding vault balance\n  uint256 public savedTotalUnderlying;\n\n  // total amount of funds the vault reserved for users that made a withdrawalRequest\n  uint256 internal totalWithdrawalRequests;\n  uint256 internal totalDepositRequests;\n\n  // total number of allocated Derby tokens currently (in derbytoken.decimals())\n  uint256 public totalAllocatedTokens;\n  // delta of the total number of Derby tokens allocated on next rebalancing\n  int256 private deltaAllocatedTokens;\n\n  address public derbyToken;\n  address public game;\n  address public xProvider;\n\n  bool public vaultOff;\n\n  uint32 public homeChain;\n  uint256 public governanceFee; // Basis points\n  uint256 public minScale; // before decimals!\n  uint256 public minimumDeposit;\n  uint256 public lastRewardPeriod;\n\n  string internal allowanceError = \"!Allowance\";\n  string internal noFundsError = \"No funds\";\n\n  // training\n  bool private training;\n  uint256 private maxTrainingDeposit;\n  mapping(address => bool) private whitelist;\n\n  // (protocolNumber => currentAllocation): current allocations over the protocols\n  mapping(uint256 => uint256) internal currentAllocations;\n\n  // (protocolNumber => deltaAllocation): delta of the portfolio on next rebalancing\n  mapping(uint256 => int256) internal deltaAllocations;\n\n  // historical reward per protocol per token, formula: TVL * yield * perfFee / totalLockedTokens\n  // (rebalancingPeriod => protocolId => rewardPerLockedToken)\n  mapping(uint256 => mapping(uint256 => int256)) public rewardPerLockedToken; // in BASE_SCALE * vaultCurrency.decimals() nr of decimals\n\n  // (protocolNumber => lastPrice): last price of underlying protocol vault\n  mapping(uint256 => uint256) public lastPrices; // in protocol.LPToken.decimals()\n\n  // (userAddress => userInfo struct)\n  mapping(address => UserInfo) internal userInfo;\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"Vault: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  modifier onlyXProvider() {\n    require(msg.sender == xProvider, \"only xProvider\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"only game\");\n    _;\n  }\n\n  event PushedRewardsToGame(uint256 _vaultNumber, uint32 _chain, int256[] _rewards);\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    uint256 _vaultNumber,\n    address _dao,\n    address _game,\n    address _controller,\n    address _vaultCurrency,\n    address _nativeToken,\n    uint256 _minScale\n  ) VaultToken(_name, _symbol, _decimals) {\n    controller = IController(_controller);\n    vaultCurrency = IERC20Metadata(_vaultCurrency);\n\n    vaultNumber = _vaultNumber;\n    dao = _dao;\n    lastTimeStamp = block.timestamp;\n    nativeToken = _nativeToken;\n\n    exchangeRate = 10 ** vaultCurrency.decimals();\n    game = _game;\n    governanceFee = 0;\n    minScale = _minScale;\n    minimumDeposit = 100 * 10 ** (vaultCurrency.decimals() - minScale);\n  }\n\n  /// @notice Vaults rebalance\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev amountToProtocol = totalAmount * currentAllocation / totalAllocatedTokens\n  /// @dev amountToDeposit = amountToProtocol - currentBalanceProtocol\n  /// @dev if amountToDeposit < 0 => withdraw\n  /// @dev Execute all withdrawals before deposits\n  function rebalance() external nonReentrant {\n    require(rebalanceNeeded(), \"No rebalance needed\");\n    require(deltaAllocationsReceived, \"!Delta allocations\");\n    rebalancingPeriod++;\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n\n    storePriceAndRewardsLoop(latestID); // based on allocations and underlying of last period and the price increases between last and current period\n\n    setTotalUnderlying();\n    uint256 underlyingIncBalance = calcUnderlyingIncBalance();\n\n    settleDeltaAllocation();\n    uint256[] memory protocolToDeposit = rebalanceCheckProtocols(latestID, underlyingIncBalance);\n\n    executeDeposits(protocolToDeposit);\n\n    savedTotalUnderlying = underlyingIncBalance;\n    uint256 oldExchangeRate = exchangeRate;\n\n    exchangeRate = calculateExchangeRate(savedTotalUnderlying);\n\n    if (exchangeRate > oldExchangeRate)\n      exchangeRate = includePerformanceFee(exchangeRate, oldExchangeRate);\n\n    lastTimeStamp = block.timestamp;\n  }\n\n  /// @notice Function to include the performanceFee in the exchangeRate\n  /// @dev Calculated by first evaluating the performance by determining the increase in exchangeRate\n  /// @dev Next the performanceFee is calculated by multiplying the performance with the percentage after substracting the performanceFee\n  /// @param _exchangeRate The exchangeRate before the performanceFee is added\n  /// @param _oldExchangeRate The exchangeRate before the rebalance\n  /// @return uint256 The new exchangeRate including the performanceFee\n  function includePerformanceFee(\n    uint256 _exchangeRate,\n    uint256 _oldExchangeRate\n  ) internal view returns (uint256) {\n    uint256 nominator = (_exchangeRate - _oldExchangeRate) *\n      _oldExchangeRate *\n      (100 - performanceFee);\n    uint256 denominator = 100 * _oldExchangeRate;\n    return nominator / denominator + _oldExchangeRate;\n  }\n\n  /// @notice Helper to return underlying balance plus totalUnderlying - liquidty for the vault\n  /// @return underlying totalUnderlying - liquidityVault\n  function calcUnderlyingIncBalance() internal view returns (uint256) {\n    uint256 totalUnderlyingInclVaultBalance = savedTotalUnderlying +\n      getVaultBalance() -\n      totalWithdrawalRequests;\n    uint256 liquidityVault = (totalUnderlyingInclVaultBalance * liquidityPerc) / 100;\n    return totalUnderlyingInclVaultBalance - liquidityVault;\n  }\n\n  /// @notice Adds deltaAllocatedTokens to totalAllocatedTokens\n  function settleDeltaAllocation() internal {\n    int256 newTotalAllocatedTokens = int(totalAllocatedTokens) + deltaAllocatedTokens;\n    require(newTotalAllocatedTokens >= 0);\n\n    totalAllocatedTokens = uint(newTotalAllocatedTokens);\n    deltaAllocatedTokens = 0;\n    deltaAllocationsReceived = false;\n  }\n\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev Loops over all protocols in ETF, calculate new currentAllocation based on deltaAllocation\n  /// @dev Also calculate the performance fee here. This is an amount, based on the current TVL (before the rebalance),\n  /// @dev the performanceFee and difference between the current exchangeRate and the exchangeRate of the last rebalance of the vault.\n  /// @param _newTotalUnderlying this will be the new total underlying: Totalunderlying = TotalUnderlyingInProtocols - BalanceVault (in vaultCurrency.decimals())\n  /// @return uint256[] with amounts to deposit in protocols, the index being the protocol number.\n  function rebalanceCheckProtocols(\n    uint256 _latestId,\n    uint256 _newTotalUnderlying\n  ) internal returns (uint256[] memory) {\n    uint256[] memory protocolToDeposit = new uint[](controller.latestProtocolId(vaultNumber));\n\n    for (uint i = 0; i < _latestId; i++) {\n      bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, i);\n\n      if (isBlacklisted) continue;\n      setAllocation(i);\n\n      uint256 amountToProtocol = calcAmountToProtocol(_newTotalUnderlying, i);\n      uint256 currentBalance = balanceUnderlying(i);\n\n      int256 amountToDeposit = int(amountToProtocol) - int(currentBalance);\n      uint256 amountToWithdraw = amountToDeposit < 0 ? currentBalance - amountToProtocol : 0;\n\n      if (amountToDeposit > marginScale) {\n        protocolToDeposit[i] = uint256(amountToDeposit);\n      }\n      if (amountToWithdraw > uint(marginScale) || currentAllocations[i] == 0) {\n        withdrawFromProtocol(i, amountToWithdraw);\n      }\n    }\n\n    return protocolToDeposit;\n  }\n\n  /// @notice Calculates the amount to deposit or withdraw to protocol during a vault rebalance\n  /// @param _totalAmount TotalAmount = TotalAmountInProtocols - BalanceVault\n  /// @param _protocol Protocol id number\n  /// @return amountToProtocol amount to deposit or withdraw to protocol (in vaultCurency.decimals())\n  function calcAmountToProtocol(\n    uint256 _totalAmount,\n    uint256 _protocol\n  ) internal view returns (uint256 amountToProtocol) {\n    if (totalAllocatedTokens == 0) amountToProtocol = 0;\n    else amountToProtocol = (_totalAmount * currentAllocations[_protocol]) / totalAllocatedTokens;\n  }\n\n  /// @notice Harvest extra tokens from underlying protocols\n  /// @dev Loops over protocols in ETF and check if they are claimable in controller contract\n  function storePriceAndRewardsLoop(uint256 _latestId) internal {\n    for (uint i = 0; i < _latestId; i++) {\n      storePriceAndRewards(i);\n    }\n  }\n\n  /// @notice Stores the historical price and the reward per rounded locked token, ignoring decimals.\n  /// @dev formula yield protocol i at time t: y(it) = (P(it) - P(it-1)) / P(it-1).\n  /// @dev formula rewardPerLockedToken for protocol i at time t: r(it) = y(it) * TVL(t) * perfFee(t) / totalLockedTokens(t)\n  /// @dev later, when the total rewards are calculated for a game player we multiply this (r(it)) by the locked tokens on protocol i at time t\n  /// @param _protocolId Protocol id number.\n  function storePriceAndRewards(uint256 _protocolId) internal {\n    uint period = rebalancingPeriod;\n    uint256 currentPrice = price(_protocolId); // in protocol.LPToken.decimals()\n    if (controller.getProtocolBlacklist(vaultNumber, _protocolId)) {\n      rewardPerLockedToken[period][_protocolId] = -1;\n      lastPrices[_protocolId] = currentPrice;\n      return;\n    }\n\n    if (lastPrices[_protocolId] == 0) {\n      lastPrices[_protocolId] = currentPrice;\n      return;\n    }\n\n    int256 priceDiff = int256(currentPrice) - int256(lastPrices[_protocolId]);\n    int256 nominator = (int256(savedTotalUnderlying * performanceFee * BASE_SCALE) * priceDiff);\n    int256 totalAllocatedTokensRounded = int256(totalAllocatedTokens) / int(BASE_SCALE);\n    int256 denominator = totalAllocatedTokensRounded * int256(lastPrices[_protocolId]) * 100; // * 100 cause perfFee is in percentages\n\n    if (totalAllocatedTokensRounded == 0) {\n      rewardPerLockedToken[period][_protocolId] = 0;\n    } else {\n      rewardPerLockedToken[period][_protocolId] = nominator / denominator;\n    }\n\n    lastPrices[_protocolId] = currentPrice;\n  }\n\n  /// @notice Creates array out of the rewardsPerLockedToken mapping to send to the game\n  /// @return rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function rewardsToArray() internal view returns (int256[] memory rewards) {\n    uint256 latestId = controller.latestProtocolId(vaultNumber);\n\n    rewards = new int[](latestId);\n    for (uint256 i = 0; i < latestId; i++) {\n      rewards[i] = rewardPerLockedToken[rebalancingPeriod][i];\n    }\n  }\n\n  /// @notice Helper function to set allocations\n  /// @param _i Protocol number linked to an underlying protocol e.g compound_usdc_01\n  function setAllocation(uint256 _i) internal {\n    int256 newCurrentAllocation = int(currentAllocations[_i]) + deltaAllocations[_i];\n    require(newCurrentAllocation >= 0);\n\n    currentAllocations[_i] = uint(newCurrentAllocation);\n    deltaAllocations[_i] = 0;\n  }\n\n  /// @notice Helper function so the rebalance will execute all withdrawals first\n  /// @dev Executes and resets all deposits set in mapping(protocolToDeposit) by rebalanceETF\n  /// @param protocolToDeposit array with amounts to deposit in protocols, the index being the protocol number.\n  function executeDeposits(uint256[] memory protocolToDeposit) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      uint256 amount = protocolToDeposit[i];\n      if (amount == 0) continue;\n      depositInProtocol(i, amount);\n    }\n  }\n\n  /// @notice Deposit amount to underlying protocol\n  /// @dev Deposits VaultCurrency in Protocol e.g USDC\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to deposit\n  function depositInProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    if (getVaultBalance() < _amount) _amount = getVaultBalance();\n\n    IERC20Metadata(protocol.underlying).safeIncreaseAllowance(protocol.provider, _amount);\n    IProvider(protocol.provider).deposit(_amount, protocol.LPToken, protocol.underlying);\n  }\n\n  /// @notice Withdraw amount from underlying protocol\n  /// @dev shares = amount / PricePerShare\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to withdraw\n  function withdrawFromProtocol(\n    uint256 _protocolNum,\n    uint256 _amount\n  ) internal returns (uint256 amountReceived) {\n    if (_amount <= 0) return 0;\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    require(protocol.underlying == address(vaultCurrency), \"Provider underlying mismatch\");\n\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\n    uint256 balance = IProvider(protocol.provider).balance(address(this), protocol.LPToken);\n\n    if (shares == 0) return 0;\n    if (balance < shares) shares = balance;\n\n    IERC20Metadata(protocol.LPToken).safeIncreaseAllowance(protocol.provider, shares);\n    amountReceived = IProvider(protocol.provider).withdraw(\n      shares,\n      protocol.LPToken,\n      protocol.underlying\n    );\n  }\n\n  /// @notice Set total balance in VaultCurrency in all underlying protocols\n  function setTotalUnderlying() public {\n    uint totalUnderlying;\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n      totalUnderlying += balanceUnderlying(i);\n    }\n    savedTotalUnderlying = totalUnderlying;\n  }\n\n  /// @notice Get balance in VaultCurrency in underlying protocol\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @return Balance in VaultCurrency e.g USDC\n  function balanceUnderlying(uint256 _protocolNum) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    uint256 underlyingBalance = IProvider(protocol.provider).balanceUnderlying(\n      address(this),\n      protocol.LPToken\n    );\n    return underlyingBalance;\n  }\n\n  /// @notice Calculates how many shares are equal to the amount in vault currency\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _protocolNum, uint256 _amount) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\n\n    return shares;\n  }\n\n  /// @notice Get price for underlying protocol\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @return protocolPrice Price per lp token\n  function price(uint256 _protocolNum) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    return IProvider(protocol.provider).exchangeRate(protocol.LPToken);\n  }\n\n  /// @notice Set the delta allocated tokens by game contract\n  /// @dev Allocation can be negative\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  /// @param _allocation Delta allocation in tokens\n  function setDeltaAllocationsInt(uint256 _protocolNum, int256 _allocation) internal {\n    require(!controller.getProtocolBlacklist(vaultNumber, _protocolNum), \"Protocol on blacklist\");\n    deltaAllocations[_protocolNum] += _allocation;\n    deltaAllocatedTokens += _allocation;\n  }\n\n  /// @notice Claims and swaps tokens from the underlying protocol\n  /// @dev Claims governance tokens from the underlying protocol if claimable, and swaps them to the vault's underlying token\n  /// @param _protocolNum The protocol ID for which to claim and swap tokens\n  function claimAndSwapTokens(\n    uint256 _protocolNum,\n    uint256 _minAmount,\n    uint256 _deadline\n  ) public onlyGuardian {\n    bool claim = controller.claim(vaultNumber, _protocolNum);\n    if (claim) {\n      address govToken = controller.getGovToken(vaultNumber, _protocolNum);\n      uint256 tokenBalance = IERC20Metadata(govToken).balanceOf(address(this));\n      Swap.swapTokensMulti(\n        Swap.SwapInOut(\n          tokenBalance,\n          _deadline,\n          _minAmount,\n          nativeToken,\n          govToken,\n          address(vaultCurrency)\n        ),\n        controller.getUniswapParams(),\n        false\n      );\n    }\n  }\n\n  function getVaultBalance() public view returns (uint256) {\n    return vaultCurrency.balanceOf(address(this));\n  }\n\n  /// @notice Checks if a rebalance is needed based on the set interval\n  /// @return bool True of rebalance is needed, false if not\n  function rebalanceNeeded() public view returns (bool) {\n    return (block.timestamp - lastTimeStamp) > rebalanceInterval || msg.sender == guardian;\n  }\n\n  /// @notice Getter for dao address\n  function getDao() public view returns (address) {\n    return dao;\n  }\n\n  /// @notice Getter for guardian address\n  function getGuardian() public view returns (address) {\n    return guardian;\n  }\n\n  /// @notice Function to calculate the exchangeRate\n  /// @param totalUnderlying Total underlying in vaultCurrency\n  /// @return price Exchange rate\n  function calculateExchangeRate(uint256 totalUnderlying) public view returns (uint256) {\n    uint256 price;\n    price = totalSupply() == 0\n      ? 10 ** vaultCurrency.decimals()\n      : (totalUnderlying * (10 ** decimals())) / totalSupply();\n    return price;\n  }\n\n  /// @notice function that enables direct deposits into the vault\n  /// @dev this can only be done if the funds from the user will be deposited directly into the underlying protocols. Hence, this is very gas intensive\n  /// @param _amount Amount to deposit in vaultCurrency\n  /// @return shares Amount of shares minted in LPtoken.decimals()\n  function deposit(uint256 _amount) public returns (uint256) {\n    require(_amount >= minimumDeposit, \"Minimum deposit\");\n\n    if (training) {\n      require(whitelist[msg.sender]);\n    }\n\n    uint256 balanceBefore = getVaultBalance();\n    vaultCurrency.safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 balanceAfter = getVaultBalance();\n    uint256 amount = balanceAfter - balanceBefore;\n\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    uint256 totalUnderlying = 0;\n    for (uint i = 0; i < latestID; i++) {\n      bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, i);\n\n      if (isBlacklisted) continue;\n\n      uint256 amountToProtocol = calcAmountToProtocol(amount, i);\n      totalUnderlying += balanceUnderlying(i);\n      depositInProtocol(i, amountToProtocol);\n    }\n\n    exchangeRate = calculateExchangeRate(totalUnderlying);\n\n    uint256 shares = (amount * (10 ** decimals())) / exchangeRate;\n    _mint(msg.sender, shares);\n    return shares;\n  }\n\n  /// @notice Enables a user to make a deposit into the Vault.\n  /// @dev This function allows a user to deposit an amount greater than or equal to the minimum deposit,\n  /// transfers the deposited amount from the user to the Vault, and records the deposit request.\n  /// If the training mode is active, the function checks if the user is whitelisted and the deposit doesn't exceed the max training deposit.\n  /// @param _amount The amount that the user wants to deposit in vaultCurrency.\n  function depositRequest(uint256 _amount) external nonReentrant {\n    UserInfo storage user = userInfo[msg.sender];\n\n    require(_amount >= minimumDeposit, \"Minimum deposit\");\n\n    if (training) {\n      require(whitelist[msg.sender]);\n      require(user.depositRequest + _amount <= maxTrainingDeposit);\n    }\n\n    uint256 balanceBefore = getVaultBalance();\n    vaultCurrency.safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 balanceAfter = getVaultBalance();\n\n    uint256 amount = balanceAfter - balanceBefore;\n    user.depositRequest += amount;\n    user.depositRequestPeriod = rebalancingPeriod;\n    totalDepositRequests += amount;\n  }\n\n  /// @notice Redeems the pending deposit requests for the calling user.\n  /// @dev This function allows a user to redeem their deposit requests and receive shares.\n  /// This can only be done if a deposit request has been made and the current rebalancing period is greater than\n  /// the period in which the deposit request was made.\n  /// The function will mint new shares in exchange for the deposit and update the user's deposit request status.\n  /// @return shares The number of shares minted in exchange for the deposit.\n  function redeemDeposit() external nonReentrant returns (uint256 shares) {\n    UserInfo storage user = userInfo[msg.sender];\n    uint256 depositRequest = user.depositRequest;\n\n    require(rebalancingPeriod > user.depositRequestPeriod, noFundsError);\n    shares = (depositRequest * (10 ** decimals())) / exchangeRate;\n\n    deleteDepositRequest(user);\n\n    _mint(msg.sender, shares);\n  }\n\n  /// @notice Cancel the deposit request for the caller.\n  function cancelDepositRequest() external nonReentrant {\n    UserInfo storage user = userInfo[msg.sender];\n    uint256 depositRequest = user.depositRequest;\n    deleteDepositRequest(user);\n    vaultCurrency.safeTransfer(msg.sender, depositRequest);\n  }\n\n  /// @dev Deletes the user's deposit request and updates the total deposit requests.\n  /// @param user The user whose deposit request is being deleted.\n  function deleteDepositRequest(UserInfo storage user) internal {\n    require(user.depositRequest > 0, allowanceError);\n    totalDepositRequests -= user.depositRequest;\n    delete user.depositRequest;\n    delete user.depositRequestPeriod;\n  }\n\n  /// @notice function that enables direct withdrawals from the vault\n  /// @dev this can only be done if the funds from the user will be withdrawed directly from the underlying protocols. Hence, this is very gas intensive\n  /// @param _amount Amount to withdraw in vaultCurrency\n  /// @return shares Amount of shares the user needs to supply in LPtoken decimals()\n  function withdraw(uint256 _amount) public returns (uint256) {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    uint256 totalUnderlying = 0;\n    uint256 vaultBalance = getVaultBalance();\n    uint256 amountFromProtocol;\n    uint256 totalWithdrawal;\n    for (uint i = 0; i < latestID; i++) {\n      bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, i);\n\n      if (isBlacklisted) continue;\n\n      totalUnderlying += balanceUnderlying(i);\n\n      if (vaultBalance < _amount) {\n        amountFromProtocol = calcAmountToProtocol(_amount - vaultBalance, i);\n        totalWithdrawal += withdrawFromProtocol(i, amountFromProtocol);\n      } else {\n        totalWithdrawal = _amount;\n      }\n    }\n\n    exchangeRate = calculateExchangeRate(totalUnderlying);\n\n    uint256 shares = (_amount * (10 ** decimals())) / exchangeRate;\n    uint256 balance = balanceOf(msg.sender);\n    shares = checkForBalance(shares, balance, decimals());\n    _burn(msg.sender, shares);\n\n    transferFunds(msg.sender, totalWithdrawal);\n    return shares;\n  }\n\n  /// @notice Withdrawal request for when the vault doesnt have enough funds available\n  /// @dev Will give the user allowance for his funds and pulls the extra funds at the next rebalance\n  /// @param _amount Amount to withdraw in vaultCurrency\n  /// @return shares Amount of shares the user needs to supply in LPtoken decimals()\n  function withdrawalRequest(uint256 _amount) external nonReentrant returns (uint256 shares) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(rebalancingPeriod != 0 && user.withdrawalRequestPeriod == 0, \"Already a request\");\n\n    shares = (_amount * (10 ** decimals())) / exchangeRate;\n    uint256 balance = balanceOf(msg.sender);\n    shares = checkForBalance(shares, balance, decimals());\n    _burn(msg.sender, shares);\n\n    user.withdrawalAllowance = _amount;\n    user.withdrawalRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += _amount;\n  }\n\n  /// @notice Withdraw the allowance the user requested on the last rebalancing period\n  /// @dev Will send the user funds and reset the allowance\n  /// @return value Amount received by seller in vaultCurrency, in vaultcurrency.decimals()\n  function withdrawAllowance() external nonReentrant returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalAllowance > 0, allowanceError);\n    require(rebalancingPeriod > user.withdrawalRequestPeriod, noFundsError);\n\n    value = user.withdrawalAllowance;\n    value = IXProvider(xProvider).calculateEstimatedAmount(value);\n\n    totalWithdrawalRequests -= user.withdrawalAllowance;\n    delete user.withdrawalAllowance;\n    delete user.withdrawalRequestPeriod;\n\n    transferFunds(msg.sender, value);\n  }\n\n  /// @notice Substract governance fee from value\n  /// @param _receiver Receiving adress for the vaultcurrency\n  /// @param _value Amount received by seller in vaultCurrency\n  function transferFunds(address _receiver, uint256 _value) internal {\n    uint256 govFee = (_value * governanceFee) / 10_000;\n\n    vaultCurrency.safeTransfer(getDao(), govFee);\n    vaultCurrency.safeTransfer(_receiver, _value - govFee);\n  }\n\n  /// @notice Function for the game to set a withdrawalRequest for the rewards of the game user\n  /// @param _value Amount to set a request in vaultCurrency\n  /// @param _user Address of the user\n  function redeemRewardsGame(uint256 _value, address _user) external onlyXProvider nonReentrant {\n    UserInfo storage user = userInfo[_user];\n    require(user.rewardAllowance == 0, allowanceError);\n\n    user.rewardAllowance = _value;\n    user.rewardRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += _value;\n  }\n\n  /// @notice Withdraw the reward allowance set by the game using the redeemRewardsGame function\n  /// @dev Swaps vaultCurrency to Derby tokens, sends the funds to the user, and resets the allowance\n  /// @return value The amount of reward withdrawn by the user\n  function withdrawRewards() external nonReentrant returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.rewardAllowance > 0, allowanceError);\n    require(rebalancingPeriod > user.rewardRequestPeriod, noFundsError);\n\n    value = user.rewardAllowance;\n    totalWithdrawalRequests -= user.rewardAllowance;\n\n    delete user.rewardAllowance;\n    delete user.rewardRequestPeriod;\n\n    vaultCurrency.safeTransfer(msg.sender, value);\n  }\n\n  /// @notice Sometimes the balance of a coin is a fraction less then expected due to rounding errors\n  /// @notice This is to make sure the vault doesnt get stuck\n  /// @notice Value will be set to the balance\n  /// @notice When divergence is greater then minScale it will revert\n  /// @param _value Value the user wants\n  /// @param _balance Balance of the coin\n  /// @param _decimals Decimals of the coin and balance\n  /// @return value Value - divergence\n  function checkForBalance(\n    uint256 _value,\n    uint256 _balance,\n    uint256 _decimals\n  ) internal view returns (uint256) {\n    if (_value > _balance) {\n      uint256 oldValue = _value;\n      _value = _balance;\n      require(oldValue - _value <= (10 ** (_decimals - minScale)), \"Max divergence\");\n    }\n    return _value;\n  }\n\n  /// @notice See receiveProtocolAllocations below\n  function receiveProtocolAllocations(int256[] memory _deltas) external onlyXProvider {\n    receiveProtocolAllocationsInt(_deltas);\n  }\n\n  /// @notice Game pushes deltaAllocations to vaults\n  /// @notice Receives protocol allocation array from the game and settles the allocations\n  /// @param _deltas Array with delta allocations where the index matches the protocolId\n  function receiveProtocolAllocationsInt(int256[] memory _deltas) internal {\n    for (uint i = 0; i < _deltas.length; i++) {\n      int256 allocation = _deltas[i];\n      if (allocation == 0) continue;\n      setDeltaAllocationsInt(i, allocation);\n    }\n\n    deltaAllocationsReceived = true;\n  }\n\n  /// @notice Vaults push rewardsPerLockedToken to game\n  function sendRewardsToGame() external payable {\n    require(lastRewardPeriod < rebalancingPeriod, \"rewards already sent\");\n\n    int256[] memory rewards = rewardsToArray();\n    IXProvider(xProvider).pushRewardsToGame{value: msg.value}(vaultNumber, homeChain, rewards);\n\n    lastRewardPeriod = rebalancingPeriod;\n\n    emit PushedRewardsToGame(vaultNumber, homeChain, rewards);\n  }\n\n  /// @notice Returns the amount in vaultCurrency the user is able to withdraw\n  function getWithdrawalAllowance() external view returns (uint256) {\n    return userInfo[msg.sender].withdrawalAllowance;\n  }\n\n  /// @notice Returns the rewards the user is able to withdraw\n  function getRewardAllowance() external view returns (uint256) {\n    return userInfo[msg.sender].rewardAllowance;\n  }\n\n  /// @notice Get the deposit request for a specific user.\n  /// @return The deposit request of the user in vaultCurrency.\n  function getDepositRequest() external view returns (uint256) {\n    return userInfo[msg.sender].depositRequest;\n  }\n\n  /*\n  Only Dao functions\n  */\n\n  /// @notice Set the performanceFee, the percentage of the yield that goes to the game players.\n  /// @dev The actual performanceFee could be a bit more or a bit less than the performanceFee set here due to approximations in the game.\n  /// @param _performanceFee Value at which to set the performanceFee.\n  function setPerformanceFee(uint256 _performanceFee) external onlyDao {\n    require(_performanceFee <= 100);\n    performanceFee = _performanceFee;\n  }\n\n  /// @notice Set the governance address\n  /// @param _dao New address of the governance / DAO\n  function setDao(address _dao) external onlyDao {\n    dao = _dao;\n  }\n\n  /// @notice Setter for guardian address\n  /// @param _guardian new address of the guardian\n  function setGuardian(address _guardian) external onlyDao {\n    guardian = _guardian;\n  }\n\n  /// @notice Setter for controller address\n  function setController(address _controller) external onlyDao {\n    controller = IController(_controller);\n  }\n\n  /// @notice Setter for xProvider address\n  /// @param _xProvider new address of xProvider on this chain\n  function setHomeXProvider(address _xProvider) external onlyDao {\n    xProvider = _xProvider;\n  }\n\n  /// @notice Setter for derby token address\n  /// @param _token New address of the derby token\n  function setDaoToken(address _token) external onlyDao {\n    derbyToken = _token;\n  }\n\n  /// @notice Setter for new game address\n  /// @param _game New address of the game\n  function setGame(address _game) external onlyDao {\n    game = _game;\n  }\n\n  /// @notice Setter for maximum divergence a user can get during a withdraw\n  /// @param _minScale New maximum divergence in vaultCurrency\n  function setminScale(uint256 _minScale) external onlyDao {\n    minScale = _minScale;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice Set minimum interval for the rebalance function\n  /// @param _timestampInternal UNIX timestamp\n  function setRebalanceInterval(uint256 _timestampInternal) external onlyGuardian {\n    rebalanceInterval = _timestampInternal;\n  }\n\n  /// @notice The DAO should be able to blacklist protocols, the funds should be sent to the vault.\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  function blacklistProtocol(uint256 _protocolNum) external onlyGuardian {\n    totalAllocatedTokens -= currentAllocations[_protocolNum];\n    currentAllocations[_protocolNum] = 0;\n\n    controller.setProtocolBlacklist(vaultNumber, _protocolNum);\n  }\n\n  /// @notice Withdraws the funds from a blacklisted protocol and updates the savedTotalUnderlying.\n  /// @dev This function should only be called after a protocol has been blacklisted.\n  /// @param _protocolNum The protocol number from which to withdraw the funds.\n  function withdrawFromBlacklistedProtocol(\n    uint256 _protocolNum,\n    uint256 _minAmount,\n    uint256 _deadline\n  ) external onlyGuardian {\n    bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, _protocolNum);\n    require(isBlacklisted, \"!Blacklisted\");\n\n    claimAndSwapTokens(_protocolNum, _minAmount, _deadline);\n\n    uint256 balanceBefore = balanceUnderlying(_protocolNum);\n    withdrawFromProtocol(_protocolNum, balanceBefore);\n    uint256 balanceAfter = balanceUnderlying(_protocolNum);\n    uint256 balanceReceived = balanceBefore - balanceAfter;\n\n    savedTotalUnderlying = savedTotalUnderlying >= balanceReceived\n      ? savedTotalUnderlying - balanceReceived\n      : 0;\n  }\n\n  /// @notice Set the marginScale, the threshold used for deposits and withdrawals.\n  /// @notice If the threshold is not met the deposit/ withdrawal is not executed.\n  /// @dev Take into account the scale of the underlying.\n  /// @param _marginScale Value at which to set the marginScale.\n  function setMarginScale(int256 _marginScale) external onlyGuardian {\n    marginScale = _marginScale;\n  }\n\n  /// @notice Set the liquidityPerc, the amount of liquidity which should be held in the vault after rebalancing.\n  /// @dev The actual liquidityPerc could be a bit more or a bit less than the liquidityPerc set here.\n  /// @dev This is because some deposits or withdrawals might not execute because they don't meet the marginScale.\n  /// @param _liquidityPerc Value at which to set the liquidityPerc.\n  function setLiquidityPerc(uint256 _liquidityPerc) external onlyGuardian {\n    require(_liquidityPerc <= 100);\n    liquidityPerc = _liquidityPerc;\n  }\n\n  /// @notice Guardian function\n  function receiveProtocolAllocationsGuard(int256[] memory _deltas) external onlyGuardian {\n    receiveProtocolAllocationsInt(_deltas);\n  }\n\n  /// @notice Setter for new homeChain Id\n  function setHomeChain(uint32 _homeChain) external onlyGuardian {\n    homeChain = _homeChain;\n  }\n\n  /// @notice Setter for governance fee\n  /// @param _fee Fee in basis points\n  function setGovernanceFee(uint16 _fee) external onlyGuardian {\n    governanceFee = _fee;\n  }\n\n  /// @notice Setter to control the training state in de deposit function\n  function setTraining(bool _state) external onlyGuardian {\n    training = _state;\n  }\n\n  /// @notice Setter for maximum amount to be able to deposit in training state\n  function setTrainingDeposit(uint256 _maxDeposit) external onlyGuardian {\n    maxTrainingDeposit = _maxDeposit;\n  }\n\n  /// @notice Setter to add an address to the whitelist\n  function addToWhitelist(address _address) external onlyGuardian {\n    whitelist[_address] = true;\n  }\n\n  /// @dev Sets the minimum deposit amount allowed.\n  /// @param _newMinimumDeposit The new minimum deposit amount to be set.\n  function setMinimumDeposit(uint256 _newMinimumDeposit) external onlyGuardian {\n    minimumDeposit = _newMinimumDeposit;\n  }\n\n  /// @notice callback to receive Ether from unwrapping WETH\n  receive() external payable {\n    require(msg.sender == nativeToken, \"Not WETH\");\n  }\n}\n"
    },
    "contracts/Interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\ninterface IController {\n  struct ProtocolInfoS {\n    address LPToken;\n    address provider;\n    address underlying;\n  }\n\n  struct UniswapParams {\n    address router;\n    address quoter;\n    uint24 poolFee;\n  }\n\n  function claim(uint256 _ETFnumber, uint256 protocolNumber) external returns (bool);\n\n  function addProtocol(\n    string calldata name,\n    uint256 _ETFnumber,\n    address provider,\n    address protocolLPToken,\n    address underlying,\n    address govToken\n  ) external returns (uint256);\n\n  function getProtocolInfo(\n    uint256 _ETFnumber,\n    uint256 protocolNumber\n  ) external view returns (ProtocolInfoS memory);\n\n  function getUniswapParams() external view returns (UniswapParams memory);\n\n  function latestProtocolId(uint256 _ETFnumber) external view returns (uint256);\n\n  function setVaultWhitelistStatus(address _vault, bool _status) external;\n\n  function setUniswapRouter(address _uniswapRouter) external;\n\n  function setUniswapQuoter(address _uniswapQuoter) external;\n\n  function setUniswapPoolFee(uint24 _poolFee) external;\n\n  function getUniswapPoolFee() external view returns (uint24);\n\n  function getUniswapQuoter() external view returns (address);\n\n  function getProtocolBlacklist(\n    uint256 _ETFnumber,\n    uint256 _protocolNum\n  ) external view returns (bool);\n\n  function setProtocolBlacklist(uint256 _ETFnumber, uint256 _protocolNum) external;\n\n  function getGovToken(uint256 _vaultNumber, uint256 _protocolNum) external view returns (address);\n\n  function getDao() external view returns (address);\n}\n"
    },
    "contracts/Interfaces/IProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\ninterface IProvider {\n  function deposit(\n    uint256 _amount,\n    address _uToken,\n    address _protocolLPToken\n  ) external returns (uint256);\n\n  function withdraw(\n    uint256 _amount,\n    address _uToken,\n    address _protocolLPToken\n  ) external returns (uint256);\n\n  function exchangeRate(address _protocolLPToken) external view returns (uint256);\n\n  function balanceUnderlying(address _address, address _protocolLPToken)\n    external\n    view\n    returns (uint256);\n\n  function calcShares(uint256 _amount, address _protocolLPToken) external view returns (uint256);\n\n  function balance(address _address, address _protocolLPToken) external view returns (uint256);\n\n  function claim(address _protocolLPToken, address _claimer) external returns (bool);\n}\n"
    },
    "contracts/VaultToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract VaultToken is ERC20 {\n  uint8 private decimals_;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals\n  ) ERC20(_name, _symbol) {\n    decimals_ = _decimals;\n  }\n\n  function decimals() public view virtual override returns (uint8) {\n    return decimals_;\n  }\n}\n"
    },
    "contracts/libraries/Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../Interfaces/IController.sol\";\r\n\r\nimport \"../Interfaces/ExternalInterfaces/ISwapRouter.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IWETH.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IQuoter.sol\";\r\n\r\nlibrary Swap {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct SwapInOut {\r\n    uint256 amount;\r\n    uint256 deadline;\r\n    uint256 amountOutMin;\r\n    address nativeToken;\r\n    address tokenIn;\r\n    address tokenOut;\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswap Address of uniswapRouter, uniswapQuoter and poolfee\r\n  /// @return Amountout Number of tokens received\r\n  function swapTokensMulti(\r\n    SwapInOut memory _swap,\r\n    IController.UniswapParams memory _uniswap,\r\n    bool _rewardSwap\r\n  ) public returns (uint256) {\r\n    IERC20(_swap.tokenIn).safeIncreaseAllowance(_uniswap.router, _swap.amount);\r\n\r\n    uint256 amountOutMinimum = IQuoter(_uniswap.quoter).quoteExactInput(\r\n      abi.encodePacked(\r\n        _swap.tokenIn,\r\n        _uniswap.poolFee,\r\n        _swap.nativeToken,\r\n        _uniswap.poolFee,\r\n        _swap.tokenOut\r\n      ),\r\n      _swap.amount\r\n    );\r\n\r\n    uint256 balanceBefore = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n    if (_rewardSwap && balanceBefore >= amountOutMinimum && amountOutMinimum >= _swap.amountOutMin)\r\n      return amountOutMinimum;\r\n\r\n    ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\r\n      path: abi.encodePacked(\r\n        _swap.tokenIn,\r\n        _uniswap.poolFee,\r\n        _swap.nativeToken,\r\n        _uniswap.poolFee,\r\n        _swap.tokenOut\r\n      ),\r\n      recipient: address(this),\r\n      deadline: _swap.deadline,\r\n      amountIn: _swap.amount,\r\n      amountOutMinimum: _swap.amountOutMin\r\n    });\r\n\r\n    ISwapRouter(_uniswap.router).exactInput(params);\r\n    uint256 balanceAfter = IERC20(_swap.tokenOut).balanceOf(address(this));\r\n    require(balanceAfter - balanceBefore >= _swap.amountOutMin, \"Over/underflow\");\r\n\r\n    return balanceAfter - balanceBefore;\r\n  }\r\n\r\n  /// @notice Swap tokens on Uniswap Multi route\r\n  /// @param _swap Number of tokens to sell, token to sell, token to receive\r\n  /// @param _uniswapQuoter Address of uniswapQuoter\r\n  /// @param _poolFee Current uniswap pool fee set in router e.g 3000\r\n  /// @return amountOutMin minimum amount out of tokens to receive when executing swap\r\n  function amountOutMultiSwap(\r\n    SwapInOut memory _swap,\r\n    address _uniswapQuoter,\r\n    uint24 _poolFee\r\n  ) public returns (uint256) {\r\n    return\r\n      IQuoter(_uniswapQuoter).quoteExactInput(\r\n        abi.encodePacked(_swap.tokenIn, _poolFee, _swap.nativeToken, _poolFee, _swap.tokenOut),\r\n        _swap.amount\r\n      );\r\n  }\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/Interfaces/ExternalInterfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ninterface ISwapRouter {\r\n  struct ExactInputSingleParams {\r\n    address tokenIn;\r\n    address tokenOut;\r\n    uint24 fee;\r\n    address recipient;\r\n    uint256 deadline;\r\n    uint256 amountIn;\r\n    uint256 amountOutMinimum;\r\n    uint160 sqrtPriceLimitX96;\r\n  }\r\n\r\n  /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n  /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n  /// @return amountOut The amount of the received token\r\n  function exactInputSingle(ISwapRouter.ExactInputSingleParams memory params)\r\n    external\r\n    returns (uint256 amountOut);\r\n\r\n  struct ExactInputParams {\r\n    bytes path;\r\n    address recipient;\r\n    uint256 deadline;\r\n    uint256 amountIn;\r\n    uint256 amountOutMinimum;\r\n  }\r\n\r\n  /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n  /// @return amountOut The amount of the received token\r\n  function exactInput(ExactInputParams calldata params)\r\n    external\r\n    payable\r\n    returns (uint256 amountOut);\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/// @title Interface for WETH9\r\ninterface IWETH9 is IERC20 {\r\n  /// @notice Deposit ether to get wrapped ether\r\n  function deposit() external payable;\r\n\r\n  /// @notice Withdraw wrapped ether to get ether\r\n  function withdraw(uint256) external;\r\n}\r\n"
    },
    "contracts/Interfaces/ExternalInterfaces/IQuoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\n/// @title Quoter Interface\r\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\r\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\r\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\r\ninterface IQuoter {\r\n  /// @notice Returns the amount out received for a given exact input swap without executing the swap\r\n  /// @param path The path of the swap, i.e. each token pair and the pool fee\r\n  /// @param amountIn The amount of the first token to swap\r\n  /// @return amountOut The amount of the last token that would be received\r\n  function quoteExactInput(bytes memory path, uint256 amountIn)\r\n    external\r\n    returns (uint256 amountOut);\r\n\r\n  /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\r\n  /// @param tokenIn The token being swapped in\r\n  /// @param tokenOut The token being swapped out\r\n  /// @param fee The fee of the token pool to consider for the pair\r\n  /// @param amountIn The desired input amount\r\n  /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\r\n  /// @return amountOut The amount of `tokenOut` that would be received\r\n  function quoteExactInputSingle(\r\n    address tokenIn,\r\n    address tokenOut,\r\n    uint24 fee,\r\n    uint256 amountIn,\r\n    uint160 sqrtPriceLimitX96\r\n  ) external returns (uint256 amountOut);\r\n}\r\n"
    },
    "contracts/Mocks/VaultMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"../Vault.sol\";\n\ncontract VaultMock is Vault {\n  mapping(uint256 => uint256) private players;\n\n  event MinAmountOut(uint256 minAmountOut);\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    uint256 _vaultNumber,\n    address _dao,\n    address _Game,\n    address _controller,\n    address _vaultCurrency,\n    address _nativeToken,\n    uint256 _minScale\n  )\n    Vault(\n      _name,\n      _symbol,\n      _decimals,\n      _vaultNumber,\n      _dao,\n      _Game,\n      _controller,\n      _vaultCurrency,\n      _nativeToken,\n      _minScale\n    )\n  {}\n\n  function getAllocationTEST(uint256 _protocolNum) external view returns (uint256) {\n    return currentAllocations[_protocolNum];\n  }\n\n  function getDeltaAllocationTEST(uint256 _protocolNum) external view returns (int256) {\n    return deltaAllocations[_protocolNum];\n  }\n\n  function setDeltaAllocations(uint256 _protocolNum, int256 _allocation) external {\n    return setDeltaAllocationsInt(_protocolNum, _allocation);\n  }\n\n  function setDeltaAllocationsReceivedTEST(bool _state) external {\n    deltaAllocationsReceived = _state;\n  }\n\n  function setTotalAllocatedTokensTest(uint256 _tokens) external {\n    totalAllocatedTokens = _tokens;\n  }\n\n  function getLastPriceTEST(uint256 _protocolId) external view returns (uint256) {\n    return lastPrices[_protocolId];\n  }\n\n  function getWithdrawalAllowanceTEST(address _address) external view returns (uint256) {\n    return userInfo[_address].withdrawalAllowance;\n  }\n\n  function getRewardAllowanceTEST(address _address) external view returns (uint256) {\n    return userInfo[_address].rewardAllowance;\n  }\n\n  function getTotalWithdrawalRequestsTEST() external view returns (uint256) {\n    return totalWithdrawalRequests;\n  }\n\n  function setTotalWithdrawalRequestsTEST(uint256 _requests) external {\n    totalWithdrawalRequests = _requests;\n  }\n\n  function setExchangeRateTEST(uint256 _exchangeRate) external {\n    exchangeRate = _exchangeRate;\n  }\n\n  function upRebalancingPeriodTEST() external {\n    rebalancingPeriod++;\n  }\n\n  function setCurrentAllocation(uint256 _protocolNum, uint256 _allocation) external {\n    currentAllocations[_protocolNum] = _allocation;\n  }\n\n  function resetDeltaAllocations(uint256 _protocolNum) external {\n    deltaAllocations[_protocolNum] = 0;\n  }\n\n  function clearCurrencyBalance(uint256 _balance) external {\n    vaultCurrency.transfer(getDao(), _balance);\n  }\n\n  function balanceSharesTEST(\n    uint256 _protocolNum,\n    address _address\n  ) external view returns (uint256) {\n    IController.ProtocolInfoS memory p = controller.getProtocolInfo(vaultNumber, _protocolNum);\n    uint256 balance = IProvider(p.provider).balance(_address, p.LPToken);\n\n    return balance;\n  }\n\n  function swapTokensMultiTest(\n    uint256 _amount,\n    uint256 _deadline,\n    uint256 _minAmountOut,\n    address _tokenIn,\n    address _tokenOut,\n    bool _rewardsSwap\n  ) external returns (uint256) {\n    return\n      Swap.swapTokensMulti(\n        Swap.SwapInOut(_amount, _deadline, _minAmountOut, nativeToken, _tokenIn, _tokenOut),\n        controller.getUniswapParams(),\n        _rewardsSwap\n      );\n  }\n\n  function swapMinAmountOutMultiTest(\n    uint256 _amount,\n    uint256 _deadline,\n    uint256 _minAmountOut,\n    address _tokenIn,\n    address _tokenOut\n  ) external {\n    uint256 minAmountOut = Swap.amountOutMultiSwap(\n      Swap.SwapInOut(_amount, _deadline, _minAmountOut, nativeToken, _tokenIn, _tokenOut),\n      controller.getUniswapQuoter(),\n      controller.getUniswapPoolFee()\n    );\n\n    emit MinAmountOut(minAmountOut);\n  }\n\n  function testLargeGameplayerSet(uint256 _amountOfPlayers) public {\n    for (uint256 i = 0; i < _amountOfPlayers; i++) {\n      players[i] = exchangeRate;\n    }\n  }\n\n  function storePriceAndRewardsTest(uint256 _protocolId) external {\n    storePriceAndRewards(_protocolId);\n  }\n\n  function depositInProtocolTest(uint256 _protocolNum, uint256 _amount) external {\n    return depositInProtocol(_protocolNum, _amount);\n  }\n\n  function withdrawFromProtocolTest(\n    uint256 _protocolNum,\n    uint256 _amount\n  ) external returns (uint256) {\n    return withdrawFromProtocol(_protocolNum, _amount);\n  }\n\n  function getTotalDepositRequestsTest() external view returns (uint256) {\n    return totalDepositRequests;\n  }\n\n  function setSavedTotalUnderlyingTest(uint256 _amount) external {\n    savedTotalUnderlying = _amount;\n  }\n\n  // function testFormulaWithNRoot(uint256 _g, uint256 _n) public view returns(int128) {\n  //   int128 g_casted = ABDKMath64x64.fromUInt(_g);\n  //   int128 n_casted = ABDKMath64x64.fromUInt(_n);\n  //   int128 log2 = ABDKMath64x64.log_2(g_casted);\n  //   int128 endResult = ABDKMath64x64.exp_2(log2 / n_casted);\n  //   return endResult;\n  // }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 5
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}